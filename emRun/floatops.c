/*********************************************************************
*                   (c) SEGGER Microcontroller GmbH                  *
*                        The Embedded Experts                        *
*                           www.segger.com                           *
**********************************************************************

----------------------------------------------------------------------
Licensing information
For use with Embedded Studio only.
A valid license for Embedded Studio is required.
-------------------------- END-OF-HEADER -----------------------------
*/
# 1 "./floatops.c"
# 50 "./floatops.c"
#include "__SEGGER_RTL_FP.h"
#include "__SEGGER_RTL_FP_Int.h"
#include "__SEGGER_RTL_Inlines.h"
# 75 "./floatops.c"
#if __SEGGER_RTL_SIDE_BY_SIDE > 0
  #define __CHOOSE(F, C, I) (F)
#elif __SEGGER_RTL_OPTIMIZE >= 3
  #define __CHOOSE(F, C, I) (I)
#else
  #define __CHOOSE(F, C, I) (C)
#endif

#define CONCAT3(X,Y,Z) X ##Y ##Z
#define CONCAT2(X,Y) X ##Y

#if __SEGGER_RTL_SIDE_BY_SIDE > 0



  #define ENTRY_F32(X) CONCAT3(SEGGER_,X,f)
  #define ENTRY_F64(X) CONCAT2(SEGGER_,X)

#elif __SEGGER_RTL_INCLUDE_C_API



  #define ENTRY_F32(X) CONCAT2(X,f)
  #define ENTRY_F64(X) X

#else



  #define ENTRY_F32(X) CONCAT3(__SEGGER_RTL_float32_,X,_outline)
  #define ENTRY_F64(X) CONCAT3(__SEGGER_RTL_float64_,X,_outline)

#endif





#define SEGGER_ADDF(X,Y) __CHOOSE(SEGGER_addf((X), (Y)), (X) + (Y), (X) + (Y) )
#define SEGGER_ADD(X,Y) __CHOOSE(SEGGER_add ((X), (Y)), (X) + (Y), (X) + (Y) )
#define SEGGER_SUBF(X,Y) __CHOOSE(SEGGER_subf((X), (Y)), (X) - (Y), (X) - (Y) )
#define SEGGER_SUB(X,Y) __CHOOSE(SEGGER_sub ((X), (Y)), (X) - (Y), (X) - (Y) )
#define SEGGER_MULF(X,Y) __CHOOSE(SEGGER_mulf((X), (Y)), (X) * (Y), (X) * (Y) )
#define SEGGER_MUL(X,Y) __CHOOSE(SEGGER_mul ((X), (Y)), (X) * (Y), (X) * (Y) )
#define SEGGER_DIVF(X,Y) __CHOOSE(SEGGER_divf((X), (Y)), (X) / (Y), (X) / (Y) )
#define SEGGER_DIV(X,Y) __CHOOSE(SEGGER_div ((X), (Y)), (X) / (Y), (X) / (Y) )

#define SEGGER_NEGF(X) __CHOOSE(SEGGER_negf(X), (-(X)), (-(X)) )
#define SEGGER_NEG(X) __CHOOSE(SEGGER_neg(X), (-(X)), (-(X)) )
#if defined(__SEGGER_RTL_FLOAT32_ABS)
  #define SEGGER_FABSF(X) __SEGGER_RTL_FLOAT32_ABS(X)
#else
  #define SEGGER_FABSF(X) __CHOOSE(SEGGER_fabsf(X), __SEGGER_RTL_float32_abs_inline(X), __SEGGER_RTL_float32_abs_inline(X) )
#endif
#if defined(__SEGGER_RTL_FLOAT64_ABS)
  #define SEGGER_FABS(X) __SEGGER_RTL_FLOAT64_ABS(X)
#else
  #define SEGGER_FABS(X) __CHOOSE(SEGGER_fabs(X), __SEGGER_RTL_float64_abs_inline(X), __SEGGER_RTL_float64_abs_inline(X) )
#endif
#define SEGGER_SINF(X) __CHOOSE(SEGGER_sinf(X), ENTRY_F32(sin)(X), __SEGGER_RTL_float32_sin_inline(X) )
#define SEGGER_SIN(X) __CHOOSE(SEGGER_sin(X), ENTRY_F64(sin)(X), __SEGGER_RTL_float64_sin_inline(X) )
#define SEGGER_COSF(X) __CHOOSE(SEGGER_cosf(X), ENTRY_F32(cos)(X), __SEGGER_RTL_float32_cos_inline(X) )
#define SEGGER_COS(X) __CHOOSE(SEGGER_cos(X), ENTRY_F64(cos)(X), __SEGGER_RTL_float64_cos_inline(X) )
#define SEGGER_TANF(X) __CHOOSE(SEGGER_tanf(X), ENTRY_F32(tan)(X), __SEGGER_RTL_float32_tan_inline(X) )
#define SEGGER_TAN(X) __CHOOSE(SEGGER_tan(X), ENTRY_F64(tan)(X), __SEGGER_RTL_float64_tan_inline(X) )

#define SEGGER_SINHF(X) __CHOOSE(SEGGER_sinhf(X), ENTRY_F32(sinh)(X), __SEGGER_RTL_float32_sinh_inline(X) )
#define SEGGER_SINH(X) __CHOOSE(SEGGER_sinh(X), ENTRY_F64(sinh)(X), __SEGGER_RTL_float64_sinh_inline(X) )
#define SEGGER_COSHF(X) __CHOOSE(SEGGER_coshf(X), ENTRY_F32(cosh)(X), __SEGGER_RTL_float32_cosh_inline(X) )
#define SEGGER_COSH(X) __CHOOSE(SEGGER_cosh(X), ENTRY_F64(cosh)(X), __SEGGER_RTL_float64_cosh_inline(X) )
#define SEGGER_TANH(X) __CHOOSE(SEGGER_tanh(X), ENTRY_F64(tanh)(X), __SEGGER_RTL_float64_tanh_inline(X) )
#define SEGGER_TANHF(X) __CHOOSE(SEGGER_tanhf(X), ENTRY_F32(tanh)(X), __SEGGER_RTL_float32_tanh_inline(X) )

#define SEGGER_SQRTF(X) __CHOOSE(SEGGER_sqrtf(X), ENTRY_F32(sqrt)(X), __SEGGER_RTL_float32_sqrt_inline(X) )
#define SEGGER_SQRT(X) __CHOOSE(SEGGER_sqrt(X), ENTRY_F64(sqrt)(X), __SEGGER_RTL_float64_sqrt_inline(X) )
#define SEGGER_EXPF(X) __CHOOSE(SEGGER_expf(X), ENTRY_F32(exp)(X), __SEGGER_RTL_float32_exp_inline(X) )
#define SEGGER_EXP(X) __CHOOSE(SEGGER_exp(X), ENTRY_F64(exp)(X), __SEGGER_RTL_float64_exp_inline(X) )
#define SEGGER_LOGF(X) __CHOOSE(SEGGER_logf(X), ENTRY_F32(log)(X), __SEGGER_RTL_float32_log_inline(X) )
#define SEGGER_LOG(X) __CHOOSE(SEGGER_log(X), ENTRY_F64(log)(X), __SEGGER_RTL_float64_log_inline(X) )
#define SEGGER_LOG1PF(X) __CHOOSE(SEGGER_log1pf(X), ENTRY_F32(log1p)(X), __SEGGER_RTL_float32_log1p_inline(X) )
#define SEGGER_LOG1P(X) __CHOOSE(SEGGER_log1p(X), ENTRY_F64(log1p)(X), __SEGGER_RTL_float64_log1p_inline(X) )
#define SEGGER_ILOGBF(X) __CHOOSE(SEGGER_ilogbf(X), ENTRY_F32(ilogb)(X), __SEGGER_RTL_float32_ilogb_inline(X) )
#define SEGGER_ILOGB(X) __CHOOSE(SEGGER_ilogb(X), ENTRY_F64(ilogb)(X), __SEGGER_RTL_float64_ilogb_inline(X) )
#define SEGGER_POWF(X,Y) __CHOOSE(SEGGER_powf(X, Y), ENTRY_F32(pow)(X, Y), __SEGGER_RTL_float32_pow_inline(X, Y) )
#define SEGGER_POW(X,Y) __CHOOSE(SEGGER_pow(X, Y), ENTRY_F64(pow)(X, Y), __SEGGER_RTL_float64_pow_inline(X, Y) )
#define SEGGER_ATANF(X) __CHOOSE(SEGGER_atanf(X), ENTRY_F32(atan)(X), __SEGGER_RTL_float32_atan_inline(X) )
#define SEGGER_ATAN(X) __CHOOSE(SEGGER_atan(X), ENTRY_F64(atan)(X), __SEGGER_RTL_float64_atan_inline(X) )
#define SEGGER_ATAN2F(Y,X) __CHOOSE(SEGGER_atan2f(Y, X), ENTRY_F32(atan2)(Y, X), __SEGGER_RTL_float32_atan2_inline(Y, X) )
#define SEGGER_ATAN2(Y,X) __CHOOSE(SEGGER_atan2(Y, X), ENTRY_F64(atan2)(Y, X), __SEGGER_RTL_float64_atan2_inline(Y, X) )
#define SEGGER_HYPOTF(Y,X) __CHOOSE(SEGGER_hypotf(Y, X), ENTRY_F32(hypot)(Y, X), __SEGGER_RTL_float32_hypot_inline(Y, X) )
#define SEGGER_HYPOT(Y,X) __CHOOSE(SEGGER_hypot(Y, X), ENTRY_F64(hypot)(Y, X), __SEGGER_RTL_float64_hypot_inline(Y, X) )
#define SEGGER_FMAF(X,Y,Z) __CHOOSE(SEGGER_fmaf(X, Y, Z), __SEGGER_RTL_float32_fma_inline(X, Y, Z), __SEGGER_RTL_float32_fma_inline(X, Y, Z) )
#define SEGGER_FMA(X,Y,Z) __CHOOSE(SEGGER_fma(X, Y, Z), __SEGGER_RTL_float64_fma_inline(X, Y, Z), __SEGGER_RTL_float64_fma_inline(X, Y, Z) )
#define SEGGER_FMSF(X,Y,Z) __CHOOSE(SEGGER_fmsf(X, Y, Z), __SEGGER_RTL_float32_fma_inline(X, Y, -(Z)), __SEGGER_RTL_float32_fma_inline(X, Y, -(Z)) )
#define SEGGER_FMS(X,Y,Z) __CHOOSE(SEGGER_fms(X, Y, Z), __SEGGER_RTL_float64_fma_inline(X, Y, -(Z)), __SEGGER_RTL_float64_fma_inline(X, Y, -(Z)) )

#define SEGGER_MODFF(X,Y) __CHOOSE(SEGGER_modff(X, Y), ENTRY_F32(modf)(X, Y), __SEGGER_RTL_float32_modf_inline(X, Y) )
#define SEGGER_MODF(X,Y) __CHOOSE(SEGGER_modf(X, Y), ENTRY_F64(modf)(X, Y), __SEGGER_RTL_float64_modf_inline(X, Y) )


#define SEGGER_LTF(X,Y) __CHOOSE(SEGGER_ltf((X), (Y)), ((X) < (Y)), ((X) < (Y)) )
#define SEGGER_LT(X,Y) __CHOOSE(SEGGER_lt ((X), (Y)), ((X) < (Y)), ((X) < (Y)) )
#define SEGGER_LEF(X,Y) __CHOOSE(SEGGER_lef((X), (Y)), ((X) <= (Y)), ((X) <= (Y)) )
#define SEGGER_LE(X,Y) __CHOOSE(SEGGER_le ((X), (Y)), ((X) <= (Y)), ((X) <= (Y)) )
#define SEGGER_GTF(X,Y) __CHOOSE(SEGGER_gtf((X), (Y)), ((X) > (Y)), ((X) > (Y)) )
#define SEGGER_GT(X,Y) __CHOOSE(SEGGER_gt ((X), (Y)), ((X) > (Y)), ((X) > (Y)) )
#define SEGGER_GEF(X,Y) __CHOOSE(SEGGER_gef((X), (Y)), ((X) >= (Y)), ((X) >= (Y)) )
#define SEGGER_GE(X,Y) __CHOOSE(SEGGER_ge ((X), (Y)), ((X) >= (Y)), ((X) >= (Y)) )
#define SEGGER_EQF(X,Y) __CHOOSE(SEGGER_eqf((X), (Y)), ((X) == (Y)), ((X) == (Y)) )
#define SEGGER_EQ(X,Y) __CHOOSE(SEGGER_eq ((X), (Y)), ((X) == (Y)), ((X) == (Y)) )
#define SEGGER_NEF(X,Y) __CHOOSE(SEGGER_nef((X), (Y)), ((X) != (Y)), ((X) != (Y)) )
#define SEGGER_NE(X,Y) __CHOOSE(SEGGER_ne ((X), (Y)), ((X) != (Y)), ((X) != (Y)) )

#define SEGGER_LT0F(X) __CHOOSE(SEGGER_ltf((X), 0), ((X) < 0), ((X) < 0) )
#define SEGGER_LT0(X) __CHOOSE(SEGGER_lt ((X), 0), ((X) < 0), ((X) < 0) )
#define SEGGER_LE0F(X) __CHOOSE(SEGGER_lef((X), 0), ((X) <= 0), ((X) <= 0) )
#define SEGGER_LE0(X) __CHOOSE(SEGGER_le ((X), 0), ((X) <= 0), ((X) <= 0) )
#define SEGGER_EQ0F(X) __CHOOSE(SEGGER_eqf((X), 0), __SEGGER_RTL_float32_putative_iszero(X), __SEGGER_RTL_float32_putative_iszero(X) )
#define SEGGER_EQ0(X) __CHOOSE(SEGGER_eq ((X), 0), ((X) == 0), ((X) == 0) )
#define SEGGER_NE0F(X) __CHOOSE(SEGGER_nef((X), 0), ((X) != 0), ((X) != 0) )
#define SEGGER_NE0(X) __CHOOSE(SEGGER_ne ((X), 0), ((X) != 0), ((X) != 0) )
#define SEGGER_GT0F(X) __CHOOSE(SEGGER_gtf((X), 0), ((X) > 0), ((X) > 0) )
#define SEGGER_GT0(X) __CHOOSE(SEGGER_gt ((X), 0), ((X) > 0), ((X) > 0) )
#define SEGGER_GE0F(X) __CHOOSE(SEGGER_gef((X), 0), ((X) >= 0), ((X) >= 0) )
#define SEGGER_GE0(X) __CHOOSE(SEGGER_ge ((X), 0), ((X) >= 0), ((X) >= 0) )

#define SEGGER_F2I(X) __CHOOSE(SEGGER_float_to_int(X), (int)(float)(X), (int)(float)(X) )
#define SEGGER_I2F(X) __CHOOSE(SEGGER_int_to_float(X), (float)(int)(X), (float)(int)(X) )
#define SEGGER_F2L(X) __CHOOSE(SEGGER_float_to_long(X), (long)(float)(X), (long)(float)(X) )
#define SEGGER_F2LL(X) __CHOOSE(SEGGER_float_to_llong(X), (long long)(float)(X), (long long)(float)(X) )
#define SEGGER_F2U(X) __CHOOSE(SEGGER_float_to_uint(X), (unsigned)(float)(X), (unsigned)(float)(X) )
#define SEGGER_D2I(X) __CHOOSE(SEGGER_double_to_int(X), (int)(double)(X), (int)(double)(X) )
#define SEGGER_D2L(X) __CHOOSE(SEGGER_double_to_long(X), (long)(double)(X), (long)(double)(X) )
#define SEGGER_D2LL(X) __CHOOSE(SEGGER_double_to_llong(X), (long long)(double)(X), (long long)(double)(X) )
#define SEGGER_I2D(X) __CHOOSE(SEGGER_int_to_double(X), (double)(int)(X), (double)(int)(X) )
#define SEGGER_D2U(X) __CHOOSE(SEGGER_double_to_uint(X), (unsigned)(double)(X), (unsigned)(double)(X) )
#define SEGGER_U2D(X) __CHOOSE(SEGGER_uint_to_double(X), (double)(unsigned)(X), (double)(unsigned)(X) )
#define SEGGER_LD2D(X) __CHOOSE(SEGGER_ldouble_to_double(X), (double)(long double)(X), (double)(long double)(X) )
#define SEGGER_LD2F(X) __CHOOSE(SEGGER_ldouble_to_float(X), (float)(long double)(X), (float)(long double)(X) )

#define SEGGER_LDEXPF(X,N) __CHOOSE(SEGGER_ldexpf(X, N), ENTRY_F32(ldexp)(X, N), __SEGGER_RTL_float32_ldexp_inline(X, N) )
#define SEGGER_LDEXP(X,N) __CHOOSE(SEGGER_ldexp(X, N), ENTRY_F64(ldexp)(X, N), __SEGGER_RTL_float64_ldexp_inline(X, N) )
#define SEGGER_FREXPF(X,N) __CHOOSE(SEGGER_frexpf(X, N), ENTRY_F32(frexp)(X, N), __SEGGER_RTL_float32_frexp_inline(X, N) )
#define SEGGER_FREXP(X,N) __CHOOSE(SEGGER_frexp(X, N), ENTRY_F64(frexp)(X, N), __SEGGER_RTL_float64_frexp_inline(X, N) )

#if __SEGGER_RTL_FP_HW >= 1 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  #define SEGGER_MUL2F(X) ((X) * 2.0f)
  #define SEGGER_MULM2F(X) ((X) * -2.0f)
  #define SEGGER_DIV2F(X) ((X) * 0.5f)
#else
  #define SEGGER_MUL2F(X) __CHOOSE(SEGGER_ldexpf(X, +1), ENTRY_F32(ldexp)(X, +1), __SEGGER_RTL_float32_ldexp_inline(X, +1) )
  #define SEGGER_MULM2F(X) __CHOOSE(SEGGER_NEGF(SEGGER_ldexpf(X, +1)), SEGGER_NEGF(ENTRY_F32(ldexp)((X), +1)), SEGGER_NEGF(__SEGGER_RTL_float32_ldexp_inline(X, +1)) )
  #define SEGGER_DIV2F(X) __CHOOSE(SEGGER_ldexpf(X, -1), ENTRY_F32(ldexp)(X, -1), __SEGGER_RTL_float32_ldexp_inline(X, -1) )
#endif

#if __SEGGER_RTL_FP_HW >= 2 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  #define SEGGER_MUL2(X) ((X) * 2.0)
  #define SEGGER_MULM2(X) ((X) * -2.0)
  #define SEGGER_DIV2(X) ((X) * 0.5)
#else
  #define SEGGER_MUL2(X) __CHOOSE(SEGGER_ldexp(X, +1), ENTRY_F64(ldexp)(X, +1), __SEGGER_RTL_float64_ldexp_inline(X, +1) )
  #define SEGGER_MULM2(X) __CHOOSE(SEGGER_NEG(SEGGER_ldexp(X, +1)), SEGGER_NEG(ENTRY_F64(ldexp)(X, +1)), SEGGER_NEG(__SEGGER_RTL_float64_ldexp_inline(X, +1)) )
  #define SEGGER_DIV2(X) __CHOOSE(SEGGER_ldexp(X, -1), ENTRY_F64(ldexp)(X, -1), __SEGGER_RTL_float64_ldexp_inline(X, -1) )
#endif

#define M_E 2.7182818284590452354
#define M_LOG2E 1.4426950408889634074
#define M_LOG10E 0.43429448190325182765
#define M_LN2 0.693147180559945309417
#define M_LN10 2.30258509299404568402

#define M_PI 3.14159265358979323846
#define M_PI_2 1.57079632679489661923
#define M_PI_3 1.04719755119659774615
#define M_PI_4 0.78539816339744830962
#define M_PI_6 0.52359877559829887038
#define M_1_PI 0.31830988618379067154
#define M_2_PI 0.63661977236758134308
#define M_3_PI_4 2.3561944901923449288469825374596
#define M_SQRT_1_2 0.70710678118654752440
#define M_SQRT_3 1.73205080756887729353
#define M_INV_PI 0.31830988618379067154
#define M_LN_HUGE 709.78271289338397
#define M_LN_HUGEF 88.7228f

#define M_SQRT_HALF_DBL 0.70710678118654752440e+0
#define M_SQRT_HALF_FLT 0.70710678118654752440e+0f
#define M_LN2_DBL 6.93147180559945286227e-01
#define M_LN2_FLT 6.9314718246e-01f
#define M_LN10_DBL 2.30258509299404590109361379290930926799774169921875
#define M_LN10_FLT 2.302585124969482421875f
#define M_INV_LN2_DBL 1.44269504088896338700465094007086008787155151367187
#define M_INV_LN2_FLT __SEGGER_RTL_FLT_SELECT(0x1.715476p0f, 1.44269502162933349609375f)
#define M_INV_LN10_DBL 0.43429448190325181666793241674895398318767547607422
#define M_INV_LN10_FLT __SEGGER_RTL_FLT_SELECT(0x1.bcb7b2p-2f, 0.4342944920063018798828125f)

#define M_SQRT_PI 1.772453850905516027298167
#define M_LOG_2PI 1.8378770664093454835606594728112

#define K_SINCOS_P_DBL -0.16666666666666665052e+0, 0.83333333333331650315e-2, -0.19841269841201840457e-3, 0.27557319210152756119e-5, -0.25052106798274584544e-7, 0.16058936490371589114e-9, -0.76429178068910467734e-12, 0.27204790957888846175e-14


#define K_SINCOS_P_FLT __SEGGER_RTL_FLT_SELECT(-0x1.555556p-3f, -0.16666667163372039794921875f), __SEGGER_RTL_FLT_SELECT( 0x1.11112ep-7f, 8.333346806466579437255859375e-3f), __SEGGER_RTL_FLT_SELECT(-0x1.a0205p-13f, -1.98424444533884525299072265625e-4f), __SEGGER_RTL_FLT_SELECT( 0x1.725326p-19f, 2.759134758889558725059032440185546875e-6f), __SEGGER_RTL_FLT_SELECT(-0x1.ab55a8p-26f, -2.487414718643776723183691501617431640625e-8f)

#define K_ASINACOS_P_FLT -0.27368494524164255994e2f, 0.57208227877891731407e2f, -0.39688862997504877339e2f, 0.10152522233806463645e2f, -0.69674573447350646411e0f
#define K_ASINACOS_Q_FLT -0.16421096714498560795e3f, 0.41714430248260412556e3f, -0.38186303361750149284e3f, 0.15095270841030604719e3f, -0.23823859153670238830e2f

#define K_ASINACOS_P_DBL -0.27368494524164255994e2, 0.57208227877891731407e2, -0.39688862997504877339e2, 0.10152522233806463645e2, -0.69674573447350646411e0
#define K_ASINACOS_Q_DBL -0.16421096714498560795e3, 0.41714430248260412556e3, -0.38186303361750149284e3, 0.15095270841030604719e3, -0.23823859153670238830e2

#define K_TAN_P_FLT -0.13338350006421960681e+0f, 0.34248878235890589960e-2f, -0.17861707342254426711e-4f
#define K_TAN_Q_FLT -0.46671683339755294240e+0f, 0.25663832289440112864e-1f, -0.31181531907010027307e-3f, 0.49819433993786512270e-6f

#define K_TAN_P_DBL -0.13338350006421960681e+0, 0.34248878235890589960e-2, -0.17861707342254426711e-4
#define K_TAN_Q_DBL -0.46671683339755294240e+0, 0.25663832289440112864e-1, -0.31181531907010027307e-3, 0.49819433993786512270e-6

#define K_ATAN_P_FLT -0.13688768894191926929e2f, -0.20505855195861651981e2f, -0.84946240351320683534e1f, -0.83758299368150059274f
#define K_ATAN_Q_FLT 0.41066306682575781263e2f, 0.86157349597130242515e2f, 0.59578436142597344465e2f, 0.15024001160028576121e2f

#define K_ATAN_P_DBL -0.13688768894191926929e2, -0.20505855195861651981e2, -0.84946240351320683534e1, -0.83758299368150059274
#define K_ATAN_Q_DBL 0.41066306682575781263e2, 0.86157349597130242515e2, 0.59578436142597344465e2, 0.15024001160028576121e2

#define K_TANH_P_FLT -0.16134119023996228053e4f, -0.99225929672236083313e2f, -0.96437492777225469787e0f
#define K_TANH_Q_FLT 0.48402357071988688686e4f, 0.22337720718962312926e4f, 0.11274474380534949335e3f

#define K_TANH_P_DBL -0.16134119023996228053e4, -0.99225929672236083313e2, -0.96437492777225469787e0
#define K_TANH_Q_DBL 0.48402357071988688686e4, 0.22337720718962312926e4, 0.11274474380534949335e3

#define K_LOG_P_DBL 0.16383943563021534222e2, -0.78956112887491257267e0
#define K_LOG_Q_DBL -0.76949932108494879777e3, 0.31203222091924532844e3, -0.35667977739034646171e2

#define K_SINH_P_DBL -0.35181283430177117881e6, -0.11563521196851768270e5, -0.16375798202630751372e3, -0.78966127417357099479e0
#define K_SINH_Q_DBL -0.21108770058106271242e7, 0.36162723109421836460e5, -0.27773523119650701667e3

#define K_INT_MIN (int)((~0u >> 1) + 1u)
#define K_INT_MAX (int)(~0u >> 1)

#define K_FP_ILOGB0 K_INT_MIN
#define K_FP_ILOGBNAN K_INT_MAX




#define K_one_U32 __SEGGER_RTL_U32_C(0x3F800000)
#define K_one_U64 __SEGGER_RTL_U64_C(0x3FF0000000000000)
#define K_PiOver2_U32 __SEGGER_RTL_U32_C(0x3FC90FDB)
#define K_Pi_U32 __SEGGER_RTL_U32_C(0x40490FDB)
#define K_Sqrt_0v75_U32 __SEGGER_RTL_U32_C(0x3F5DB3D8)
#define K_log_HUGE_U32 __SEGGER_RTL_U32_C(0x42B17217)
#define K_log_SMALL_U32 __SEGGER_RTL_U32_C(0xC2AEAC4F)
#define K_Pi_2Q29 __SEGGER_RTL_U32_C(0x6487ED51)


#define K_NAN_U32 __SEGGER_RTL_U32_C(0x7FC00000)
#define K_NAN_U64 __SEGGER_RTL_U64_C(0x7FF8000000000000)
#define K_INF_U32 __SEGGER_RTL_U32_C(0x7F800000)
#define K_INF_U64 __SEGGER_RTL_U64_C(0x7FF0000000000000)
#define K_MINUS_INF_U32 __SEGGER_RTL_U32_C(0xFF800000)
#define K_MINUS_INF_U64 __SEGGER_RTL_U64_C(0xFFF0000000000000)
#define K_ZERO_U32 __SEGGER_RTL_U32_C(0x00000000)
#define K_ZERO_U64 __SEGGER_RTL_U64_C(0x0000000000000000)
#define K_MINUS_ZERO_U32 __SEGGER_RTL_U32_C(0x00000000)
#define K_MINUS_ZERO_U64 __SEGGER_RTL_U64_C(0x8000000000000000)


#define K_INF_F32 __SEGGER_RTL_BitcastToF32(K_INF_U32)
#define K_INF_F64 __SEGGER_RTL_BitcastToF64(K_INF_U64)
#define K_NAN_F32 __SEGGER_RTL_BitcastToF32(K_NAN_U32)
#define K_NAN_F64 __SEGGER_RTL_BitcastToF64(K_NAN_U64)




#define K_LOG2_E_H 0x2E2A8ECA
#define K_LOG2_E_M 0x5705FC2F
#define K_LOG2_E_L 0xEFA1FFB4

#define FLOAT16_TOTAL_BITS 16
#define FLOAT16_SIGNIFICAND_BITS 10
#define FLOAT16_EXPONENT_BITS 5
#define FLOAT16_EXPONENT_INF ((1u << FLOAT16_EXPONENT_BITS) - 1)
#define FLOAT16_EXPONENT_BIAS (FLOAT16_EXPONENT_INF >> 1)
#define FLOAT16_SIGNIFICAND_MASK ((UINT16_C(1) << FLOAT16_SIGNIFICAND_BITS) - 1)
#define FLOAT16_SIGN_MASK (UINT16_C(1) << (FLOAT16_TOTAL_BITS-1))
#define FLOAT16_HIDDEN_MASK ((UINT16_C(1) << FLOAT16_SIGNIFICAND_BITS))
#define FLOAT16_SIGN(x) ((x) & FLOAT16_SIGN_MASK)
#define FLOAT16_EXPONENT(x) ((__SEGGER_RTL_INT_LEAST16_T)((x) >> FLOAT16_SIGNIFICAND_BITS) & FLOAT16_EXPONENT_INF)
#define FLOAT16_MK(S,E,M) (((S) << (FLOAT16_TOTAL_BITS-1)) | ((E) << FLOAT16_SIGNIFICAND_BITS) | (M))

#define FLOAT32_TOTAL_BITS 32
#define FLOAT32_SIGNIFICAND_BITS 23
#define FLOAT32_EXPONENT_BITS 8
#define FLOAT32_EXPONENT_INF ((1u << FLOAT32_EXPONENT_BITS) - 1)
#define FLOAT32_EXPONENT_BIAS (FLOAT32_EXPONENT_INF >> 1)
#define FLOAT32_SIGNIFICAND_MASK ((__SEGGER_RTL_U32_C(1) << FLOAT32_SIGNIFICAND_BITS) - 1)
#define FLOAT32_SIGNIFICAND_X_MASK ((__SEGGER_RTL_U32_C(1) << (FLOAT32_SIGNIFICAND_BITS+1)) - 1)
#define FLOAT32_SIGN_MASK (__SEGGER_RTL_U32_C(1) << (FLOAT32_TOTAL_BITS-1))
#define FLOAT32_HIDDEN_MASK ((__SEGGER_RTL_U32_C(1) << FLOAT32_SIGNIFICAND_BITS))
#define FLOAT32_EXPONENT_MASK ((__SEGGER_RTL_U32)(FLOAT32_EXPONENT_INF) << FLOAT32_SIGNIFICAND_BITS)
#define FLOAT32_EXPONENT(x) ((__SEGGER_RTL_INT_LEAST16_T)((x) >> FLOAT32_SIGNIFICAND_BITS) & FLOAT32_EXPONENT_INF)
#define FLOAT32_SIGN(x) ((x) & FLOAT32_SIGN_MASK)
#define FLOAT32_MK(E,M,S) (((__SEGGER_RTL_U32)(S) << (FLOAT32_TOTAL_BITS-1)) | ((__SEGGER_RTL_U32)(E) << FLOAT32_SIGNIFICAND_BITS) | (__SEGGER_RTL_U32)(M))

#define FLOAT64_TOTAL_BITS 64
#define FLOAT64_SIGNIFICAND_BITS 52
#define FLOAT64_EXPONENT_BITS 11
#define FLOAT64_EXPONENT_INF ((1 << FLOAT64_EXPONENT_BITS) - 1)
#define FLOAT64_EXPONENT_BIAS (FLOAT64_EXPONENT_INF >> 1)
#define FLOAT64_SIGNIFICAND_MASK ((__SEGGER_RTL_U64_C(1) << FLOAT64_SIGNIFICAND_BITS) - 1)
#define FLOAT64_SIGNIFICAND_X_MASK ((__SEGGER_RTL_U64_C(1) << (FLOAT64_SIGNIFICAND_BITS+1)) - 1)
#define FLOAT64_SIGN_MASK (__SEGGER_RTL_U64_C(1) << (FLOAT64_TOTAL_BITS-1))
#define FLOAT64_HIDDEN_MASK ((__SEGGER_RTL_U64_C(1) << FLOAT64_SIGNIFICAND_BITS))
#define FLOAT64_EXPONENT_MASK ((__SEGGER_RTL_U64)(FLOAT64_EXPONENT_INF) << FLOAT64_SIGNIFICAND_BITS)
#define FLOAT64_EXPONENT(x) ((__SEGGER_RTL_INT_LEAST16_T)((x) >> FLOAT64_SIGNIFICAND_BITS) & FLOAT64_EXPONENT_INF)
#define FLOAT64_SIGN(x) ((x) & FLOAT64_SIGN_MASK)
#define FLOAT64_MK(E,M,S) (((__SEGGER_RTL_U64)(S) << (FLOAT64_TOTAL_BITS-1)) | ((__SEGGER_RTL_U64)(E) << FLOAT64_SIGNIFICAND_BITS) | (__SEGGER_RTL_U64)(M))

#define FLOAT128_TOTAL_BITS 128
#define FLOAT128_SIGNIFICAND_BITS 112
#define FLOAT128_EXPONENT_BITS 15
#define FLOAT128_EXPONENT_INF ((1u << FLOAT128_EXPONENT_BITS) - 1)
#define FLOAT128_EXPONENT_BIAS (FLOAT128_EXPONENT_INF >> 1)
#define FLOAT128_SIGNIFICAND_HI_MASK ((__SEGGER_RTL_U64_C(1) << (FLOAT128_SIGNIFICAND_BITS-64)) - 1)
#define FLOAT128_SIGN_HI_MASK (__SEGGER_RTL_U64_C(1) << (FLOAT128_TOTAL_BITS-64-1))
#define FLOAT128_EXPONENT_HI_MASK ((__SEGGER_RTL_U64)(FLOAT128_EXPONENT_INF) << (FLOAT128_SIGNIFICAND_BITS-64))
#define FLOAT128_EXPONENT_HI(x) ((__SEGGER_RTL_INT_LEAST16_T)((x) >> (FLOAT128_SIGNIFICAND_BITS-64)) & FLOAT128_EXPONENT_INF)
#define FLOAT128_SIGN_HI(x) ((x) & FLOAT128_SIGN_HI_MASK)

#define __SEGGER_RTL_SIGN_EXTEND(x,n) ((__SEGGER_RTL_I32)(x) << (32-(n)) >> (32-(n)))
#define __SEGGER_RTL_X2(X) ((__SEGGER_RTL_U32)(X) << 1)
#define __SEGGER_RTL_NORMALIZE_1UP(X,Y) if (((X) & __SEGGER_RTL_U32_C(0x40000000)) == 0) { (X) <<= 1; ++(Y); }
#define __SEGGER_RTL_NORMALIZE_1DN(X,Y) if ((X) & __SEGGER_RTL_U32_C(0x80000000)) { (X) >>= 1; --(Y); }

#define __SEGGER_RTL_ABS_I32(X) (((__SEGGER_RTL_I32)(X) ^ ((__SEGGER_RTL_I32)(X) >> 31)) - ((__SEGGER_RTL_I32)(X) >> 31))
#define __SEGGER_RTL_ABSX_I32(X) (((__SEGGER_RTL_I32)(X) ^ ((__SEGGER_RTL_I32)(X) >> 31)))
#define __SEGGER_RTL_SAFE_ASR_I32(X,N) ((__SEGGER_RTL_I32)(X) >> ((N) < 32 ? (N) : 31))
#define __SEGGER_RTL_SAFE_LSL_U32(X,N) ((__SEGGER_RTL_U32)(N) < 32 ? (X) << (__SEGGER_RTL_U32)(N) : 0)
#define __SEGGER_RTL_SAFE_LSR_U32(X,N) ((__SEGGER_RTL_U32)(N) < 32 ? (__SEGGER_RTL_U32)(X) >> (__SEGGER_RTL_U32)(N) : 0)
#define __SEGGER_RTL_LSL_U64_HI(H,L,N) (((H) << (N)) | ((L) >> (32-N)))
#define __SEGGER_RTL_PACK(EXP,SIG,SGN) (((__SEGGER_RTL_U32)(EXP) << 23) + (((SIG) + 64) >> 7) + ((SGN) & FLOAT32_SIGN_MASK))
#define __SEGGER_RTL_U64_ROUND(X) ((__SEGGER_RTL_U32)((X) >> 32) + ((__SEGGER_RTL_U32)(X) >> 31))
# 424 "./floatops.c"
#if defined(__SEGGER_RTL_FLOAT16)
typedef union {
  __SEGGER_RTL_U16 l;
  __SEGGER_RTL_FLOAT16 f;
} SEGGER_RTL_float16_t;
#endif

typedef union {
  __SEGGER_RTL_U32 l;
  float f;
} SEGGER_RTL_float32_t;

typedef union {
  __SEGGER_RTL_U64 l;
  double f;
#if __SEGGER_RTL_BYTE_ORDER < 0
  struct {
    __SEGGER_RTL_U32 lo;
    __SEGGER_RTL_U32 hi;
  } part;
  struct {
    __SEGGER_RTL_U16 hi;
    __SEGGER_RTL_U16 mohi;
    __SEGGER_RTL_U16 molo;
    __SEGGER_RTL_U16 lo;
  } u16;
#else
  struct {
    __SEGGER_RTL_U32 hi;
    __SEGGER_RTL_U32 lo;
  } part;
#endif
} SEGGER_RTL_float64_t;

typedef union {
  long double f;
#if __SEGGER_RTL_BYTE_ORDER < 0
  struct {
    __SEGGER_RTL_U64 lo;
    __SEGGER_RTL_U64 hi;
  } part;
#else
  struct {
    __SEGGER_RTL_U64 hi;
    __SEGGER_RTL_U64 lo;
  } part;
#endif
} SEGGER_RTL_float128_t;

typedef struct {
  __SEGGER_RTL_U32 S_value; unsigned S_scale;
  __SEGGER_RTL_U32 C_value; unsigned C_scale;
} SEGGER_RTL_SIN_COS_PARA;

typedef struct {
  __SEGGER_RTL_U32 Value[16];
  __SEGGER_RTL_U8 Scale[16];
} SEGGER_RTL_LOGF_PARA;

typedef struct {
  __SEGGER_RTL_U32 Value[17];
  __SEGGER_RTL_U8 Scale[17];
} SEGGER_RTL_EXPM1F_PARA;
# 496 "./floatops.c"
__SEGGER_RTL_RODATA __SEGGER_RTL_U8 __SEGGER_RTL_clz_lut[256] = {
  8, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4,
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};


static __SEGGER_RTL_RODATA __SEGGER_RTL_U16 __SEGGER_RTL_logf_1_over_1_plus_j_by_16[] = {
  0x0100, 0x00F1, 0x00E4, 0x00D8,
  0x00CD, 0x00C3, 0x00BA, 0x00B2,
  0x00AB, 0x00A4, 0x009E, 0x0098,
  0x0092, 0x008D, 0x0089, 0x0084,
  0x0080
};


static __SEGGER_RTL_RODATA SEGGER_RTL_LOGF_PARA __SEGGER_RTL_logf_log_1_plus_j_by_16 = {
  { __SEGGER_RTL_U32_C(0x00000000), __SEGGER_RTL_U32_C(0x3DD46380), __SEGGER_RTL_U32_C(0x3B4E4EC7), __SEGGER_RTL_U32_C(0x56FD01AD),
    __SEGGER_RTL_U32_C(0x38DFF78E), __SEGGER_RTL_U32_C(0x45AD732F), __SEGGER_RTL_U32_C(0x51C6370A), __SEGGER_RTL_U32_C(0x5D0761DB),
    __SEGGER_RTL_U32_C(0xB5DA97B1), __SEGGER_RTL_U32_C(0xC08DCF25), __SEGGER_RTL_U32_C(0x9430DAC6), __SEGGER_RTL_U32_C(0xA8033E3D),
    __SEGGER_RTL_U32_C(0xBCA2060D), __SEGGER_RTL_U32_C(0xCE797454), __SEGGER_RTL_U32_C(0xBA6B2445), __SEGGER_RTL_U32_C(0xE07D64F2) },
  { 0, 34, 33, 33,
    32, 32, 32, 32,
    32, 32, 33, 33,
    33, 33, 34, 34 }
};

static __SEGGER_RTL_RODATA SEGGER_RTL_EXPM1F_PARA __SEGGER_RTL_float32_Expfm1_exp_j_by_8 = {
  { __SEGGER_RTL_U32_C(0xAF16AC6C), __SEGGER_RTL_U32_C(0xB55BBC13), __SEGGER_RTL_U32_C(0xBC7681D8), __SEGGER_RTL_U32_C(0x8906E49A),
    __SEGGER_RTL_U32_C(0x9B4597E3), __SEGGER_RTL_U32_C(0xAFF230AF), __SEGGER_RTL_U32_C(0xC75F7CF5), __SEGGER_RTL_U32_C(0xC3D6A24F),
    __SEGGER_RTL_U32_C(0x00000000),
    __SEGGER_RTL_U32_C(0x442C08B7), __SEGGER_RTL_U32_C(0x48B5E3C4), __SEGGER_RTL_U32_C(0x3A3D289F), __SEGGER_RTL_U32_C(0x53094C71),
    __SEGGER_RTL_U32_C(0x6F22AEFC), __SEGGER_RTL_U32_C(0x477CEDA3), __SEGGER_RTL_U32_C(0x59872C3E), __SEGGER_RTL_U32_C(0x6DF85459)},
  { 31, 31, 31, 32,
    32, 32, 32, 33,
     0,
    33, 32, 31, 31,
    31, 30, 30, 30 }
};


static __SEGGER_RTL_RODATA __SEGGER_RTL_U8 __SEGGER_RTL_rsqrt_approx_bits[256] = {
  0xFE, 0xFC, 0xFA, 0xF8, 0xF6, 0xF4, 0xF2, 0xF0,
  0xEE, 0xED, 0xEB, 0xE9, 0xE7, 0xE6, 0xE4, 0xE2,
  0xE1, 0xDF, 0xDD, 0xDC, 0xDA, 0xD8, 0xD7, 0xD5,
  0xD4, 0xD2, 0xD1, 0xCF, 0xCE, 0xCC, 0xCB, 0xC9,
  0xC8, 0xC7, 0xC5, 0xC4, 0xC2, 0xC1, 0xC0, 0xBE,
  0xBD, 0xBC, 0xBA, 0xB9, 0xB8, 0xB7, 0xB5, 0xB4,
  0xB3, 0xB2, 0xB0, 0xAF, 0xAE, 0xAD, 0xAC, 0xAB,
  0xA9, 0xA8, 0xA7, 0xA6, 0xA5, 0xA4, 0xA3, 0xA2,
  0xA0, 0x9F, 0x9E, 0x9D, 0x9C, 0x9B, 0x9A, 0x99,
  0x98, 0x97, 0x96, 0x95, 0x94, 0x93, 0x92, 0x91,
  0x90, 0x8F, 0x8E, 0x8D, 0x8C, 0x8B, 0x8B, 0x8A,
  0x89, 0x88, 0x87, 0x86, 0x85, 0x84, 0x83, 0x83,
  0x82, 0x81, 0x80, 0x7F, 0x7E, 0x7D, 0x7D, 0x7C,
  0x7B, 0x7A, 0x79, 0x79, 0x78, 0x77, 0x76, 0x75,
  0x75, 0x74, 0x73, 0x72, 0x72, 0x71, 0x70, 0x6F,
  0x6F, 0x6E, 0x6D, 0x6C, 0x6C, 0x6B, 0x6A, 0x6A,
  0x68, 0x67, 0x65, 0x64, 0x63, 0x61, 0x60, 0x5F,
  0x5D, 0x5C, 0x5B, 0x5A, 0x58, 0x57, 0x56, 0x55,
  0x54, 0x52, 0x51, 0x50, 0x4F, 0x4E, 0x4D, 0x4C,
  0x4B, 0x4A, 0x48, 0x47, 0x46, 0x45, 0x44, 0x43,
  0x42, 0x41, 0x40, 0x3F, 0x3E, 0x3D, 0x3C, 0x3C,
  0x3B, 0x3A, 0x39, 0x38, 0x37, 0x36, 0x35, 0x34,
  0x33, 0x33, 0x32, 0x31, 0x30, 0x2F, 0x2E, 0x2D,
  0x2D, 0x2C, 0x2B, 0x2A, 0x29, 0x29, 0x28, 0x27,
  0x26, 0x26, 0x25, 0x24, 0x23, 0x23, 0x22, 0x21,
  0x20, 0x20, 0x1F, 0x1E, 0x1E, 0x1D, 0x1C, 0x1C,
  0x1B, 0x1A, 0x19, 0x19, 0x18, 0x17, 0x17, 0x16,
  0x16, 0x15, 0x14, 0x14, 0x13, 0x12, 0x12, 0x11,
  0x11, 0x10, 0x0F, 0x0F, 0x0E, 0x0E, 0x0D, 0x0C,
  0x0C, 0x0B, 0x0B, 0x0A, 0x0A, 0x09, 0x08, 0x08,
  0x07, 0x07, 0x06, 0x06, 0x05, 0x05, 0x04, 0x04,
  0x03, 0x03, 0x02, 0x02, 0x01, 0x01, 0x00, 0x00,
};
# 593 "./floatops.c"
static __SEGGER_RTL_RODATA __SEGGER_RTL_U8 __SEGGER_RTL_aSqrtData[] = {
  0xB5, 0xB5, 0xB6, 0xB7, 0xB7, 0xB8, 0xB9, 0xB9, 0xBA, 0xBB, 0xBB, 0xBC, 0xBD, 0xBD, 0xBE, 0xBF,
  0xC0, 0xC0, 0xC1, 0xC1, 0xC2, 0xC3, 0xC3, 0xC4, 0xC5, 0xC5, 0xC6, 0xC7, 0xC7, 0xC8, 0xC9, 0xC9,
  0xCA, 0xCB, 0xCB, 0xCC, 0xCC, 0xCD, 0xCE, 0xCE, 0xCF, 0xD0, 0xD0, 0xD1, 0xD1, 0xD2, 0xD3, 0xD3,
  0xD4, 0xD4, 0xD5, 0xD6, 0xD6, 0xD7, 0xD7, 0xD8, 0xD9, 0xD9, 0xDA, 0xDA, 0xDB, 0xDB, 0xDC, 0xDD,
  0xDD, 0xDE, 0xDE, 0xDF, 0xE0, 0xE0, 0xE1, 0xE1, 0xE2, 0xE2, 0xE3, 0xE3, 0xE4, 0xE5, 0xE5, 0xE6,
  0xE6, 0xE7, 0xE7, 0xE8, 0xE8, 0xE9, 0xEA, 0xEA, 0xEB, 0xEB, 0xEC, 0xEC, 0xED, 0xED, 0xEE, 0xEE,
  0xEF, 0xF0, 0xF0, 0xF1, 0xF1, 0xF2, 0xF2, 0xF3, 0xF3, 0xF4, 0xF4, 0xF5, 0xF5, 0xF6, 0xF6, 0xF7,
  0xF7, 0xF8, 0xF8, 0xF9, 0xF9, 0xFA, 0xFA, 0xFB, 0xFB, 0xFC, 0xFC, 0xFD, 0xFD, 0xFE, 0xFE, 0xFF,
  0x80, 0x80, 0x80, 0x81, 0x81, 0x82, 0x82, 0x83, 0x83, 0x84, 0x84, 0x85, 0x85, 0x86, 0x86, 0x87,
  0x87, 0x88, 0x88, 0x89, 0x89, 0x8A, 0x8A, 0x8B, 0x8B, 0x8B, 0x8C, 0x8C, 0x8D, 0x8D, 0x8E, 0x8E,
  0x8F, 0x8F, 0x90, 0x90, 0x90, 0x91, 0x91, 0x92, 0x92, 0x93, 0x93, 0x93, 0x94, 0x94, 0x95, 0x95,
  0x96, 0x96, 0x96, 0x97, 0x97, 0x98, 0x98, 0x99, 0x99, 0x99, 0x9A, 0x9A, 0x9B, 0x9B, 0x9B, 0x9C,
  0x9C, 0x9D, 0x9D, 0x9D, 0x9E, 0x9E, 0x9F, 0x9F, 0xA0, 0xA0, 0xA0, 0xA1, 0xA1, 0xA1, 0xA2, 0xA2,
  0xA3, 0xA3, 0xA3, 0xA4, 0xA4, 0xA5, 0xA5, 0xA5, 0xA6, 0xA6, 0xA7, 0xA7, 0xA7, 0xA8, 0xA8, 0xA8,
  0xA9, 0xA9, 0xAA, 0xAA, 0xAA, 0xAB, 0xAB, 0xAB, 0xAC, 0xAC, 0xAD, 0xAD, 0xAD, 0xAE, 0xAE, 0xAE,
  0xAF, 0xAF, 0xB0, 0xB0, 0xB0, 0xB1, 0xB1, 0xB1, 0xB2, 0xB2, 0xB2, 0xB3, 0xB3, 0xB3, 0xB4, 0xB4,

  0xB3, 0xB2, 0xB0, 0xAF, 0xAE, 0xAD, 0xAB, 0xAA, 0xA9, 0xA8, 0xA7, 0xA6, 0xA5, 0xA3, 0xA2, 0xA1,
  0xA0, 0x9F, 0x9E, 0x9E, 0x9D, 0x9C, 0x9B, 0x9A, 0x99, 0x98, 0x97, 0x96, 0x96, 0x95, 0x94, 0x93,
  0x93, 0x92, 0x91, 0x90, 0x90, 0x8F, 0x8E, 0x8E, 0x8D, 0x8C, 0x8B, 0x8B, 0x8A, 0x8A, 0x89, 0x88,
  0x88, 0x87, 0x87, 0x86, 0x85, 0x85, 0x84, 0x84, 0x83, 0x83, 0x82, 0x82, 0x81, 0x81, 0x80, 0x80,
  0xFE, 0xFC, 0xFA, 0xF8, 0xF6, 0xF4, 0xF3, 0xF1, 0xEF, 0xEE, 0xEC, 0xEA, 0xE9, 0xE7, 0xE6, 0xE4,
  0xE3, 0xE2, 0xE0, 0xDF, 0xDE, 0xDC, 0xDB, 0xDA, 0xD9, 0xD7, 0xD6, 0xD5, 0xD4, 0xD3, 0xD2, 0xD1,
  0xCF, 0xCE, 0xCD, 0xCC, 0xCB, 0xCA, 0xC9, 0xC8, 0xC7, 0xC6, 0xC5, 0xC5, 0xC4, 0xC3, 0xC2, 0xC1,
  0xC0, 0xBF, 0xBE, 0xBE, 0xBD, 0xBC, 0xBB, 0xBA, 0xBA, 0xB9, 0xB8, 0xB7, 0xB7, 0xB6, 0xB5, 0xB5,
};

static __SEGGER_RTL_RODATA struct {
  __SEGGER_RTL_U8 aInitialApprox[32];
  __SEGGER_RTL_U32 aMidRoot [32];
  __SEGGER_RTL_U32 aMult [ 3];
} __SEGGER_RTL_cbrt_paras = {
  { 0xFC, 0xF5, 0xED, 0xE7, 0xE0, 0xDA, 0xD5, 0xCF,
    0xCA, 0xC5, 0xC1, 0xBC, 0xB8, 0xB4, 0xB0, 0xAC,
    0xA9, 0xA5, 0xA2, 0x9F, 0x9C, 0x99, 0x96, 0x94,
    0x91, 0x8E, 0x8C, 0x8A, 0x87, 0x85, 0x83, 0x81
  },
  {
    __SEGGER_RTL_U32_C(0x40563BB0),
    __SEGGER_RTL_U32_C(0x40F19F34),
    __SEGGER_RTL_U32_C(0x41AA9F86),
    __SEGGER_RTL_U32_C(0x423AED69),
    __SEGGER_RTL_U32_C(0x42E9BB97),
    __SEGGER_RTL_U32_C(0x43857757),
    __SEGGER_RTL_U32_C(0x440BACEB),
    __SEGGER_RTL_U32_C(0x44B2618D),
    __SEGGER_RTL_U32_C(0x45424D5D),
    __SEGGER_RTL_U32_C(0x45D70DA4),
    __SEGGER_RTL_U32_C(0x4651B9F8),
    __SEGGER_RTL_U32_C(0x46EFEC05),
    __SEGGER_RTL_U32_C(0x477292C8),
    __SEGGER_RTL_U32_C(0x47F91155),
    __SEGGER_RTL_U32_C(0x48839B75),
    __SEGGER_RTL_U32_C(0x491268EC),
    __SEGGER_RTL_U32_C(0x49807339),
    __SEGGER_RTL_U32_C(0x4A174A2F),
    __SEGGER_RTL_U32_C(0x4A8BA80C),
    __SEGGER_RTL_U32_C(0x4B02EEB1),
    __SEGGER_RTL_U32_C(0x4B7D3F53),
    __SEGGER_RTL_U32_C(0x4BFABD4F),
    __SEGGER_RTL_U32_C(0x4C7B8E5C),
    __SEGGER_RTL_U32_C(0x4CD35BA4),
    __SEGGER_RTL_U32_C(0x4D5A11F2),
    __SEGGER_RTL_U32_C(0x4DE48CF5),
    __SEGGER_RTL_U32_C(0x4E430E98),
    __SEGGER_RTL_U32_C(0x4EA36181),
    __SEGGER_RTL_U32_C(0x4F37693A),
    __SEGGER_RTL_U32_C(0x4F9C8E92),
    __SEGGER_RTL_U32_C(0x5003C05A),
    __SEGGER_RTL_U32_C(0x506D1171),
  },
  {
    __SEGGER_RTL_U32_C(0x40000000),
    __SEGGER_RTL_U32_C(0x50A28BE6),
    __SEGGER_RTL_U32_C(0x6597FA94),
  }
};

static __SEGGER_RTL_RODATA __SEGGER_RTL_U16 __SEGGER_RTL_inv_pi[] = {
  0x0000,
  0x517C, 0xC1B7, 0x2722, 0x0A94,
  0xFE13, 0xABE8, 0xFA9A, 0x6EE0,
  0x6DB1, 0x4ACC, 0x9E21, 0xC820,
};

static __SEGGER_RTL_RODATA SEGGER_RTL_SIN_COS_PARA __SEGGER_RTL_float32_SinCosParas[] = {
  { __SEGGER_RTL_U32_C(0x00000000), 32, 0x40000000, -2 },
  { __SEGGER_RTL_U32_C(0x31F17079), 32, 0x7D8A5F40, -1 },
  { __SEGGER_RTL_U32_C(0x61F78A9B), 32, 0x7641AF3D, -1 },
  { __SEGGER_RTL_U32_C(0x471CECE7), 31, 0x6A6D98A4, -1 },
  { __SEGGER_RTL_U32_C(0x5A82799A), 31, 0x5A82799A, -1 },
  { __SEGGER_RTL_U32_C(0x6A6D98A4), 31, 0x471CECE7, -1 },
  { __SEGGER_RTL_U32_C(0x7641AF3D), 31, 0x61F78A9B, 0 },
  { __SEGGER_RTL_U32_C(0x7D8A5F40), 31, 0x31F17079, 0 },
  { __SEGGER_RTL_U32_C(0x40000000), 30, 0x00000000, 0 },
  { __SEGGER_RTL_U32_C(0x7D8A5F40), 31, 0xCE0E8F87, 0 },
  { __SEGGER_RTL_U32_C(0x7641AF3D), 31, 0x9E087565, 0 },
  { __SEGGER_RTL_U32_C(0x6A6D98A4), 31, 0xB8E31319, -1 },
  { __SEGGER_RTL_U32_C(0x5A82799A), 31, 0xA57D8666, -1 },
  { __SEGGER_RTL_U32_C(0x471CECE7), 31, 0x9592675C, -1 },
  { __SEGGER_RTL_U32_C(0x61F78A9B), 32, 0x89BE50C3, -1 },
  { __SEGGER_RTL_U32_C(0x31F17079), 32, 0x8275A0C0, -1 },
};

static __SEGGER_RTL_RODATA __SEGGER_RTL_U64 __SEGGER_RTL_float64_aExpCoeff[] = {
  __SEGGER_RTL_U64_C(0x4000000000000000),
  __SEGGER_RTL_U64_C(0x40B268F9DE0183BA),
  __SEGGER_RTL_U64_C(0x4166C34C5615D0EC),
  __SEGGER_RTL_U64_C(0x421D1461D66F2023),
  __SEGGER_RTL_U64_C(0x42D561B3E6243D8A),
  __SEGGER_RTL_U64_C(0x438FB0CB4F468808),
  __SEGGER_RTL_U64_C(0x444C0740496D4294),
  __SEGGER_RTL_U64_C(0x450A6ABAA4B77ECD),
  __SEGGER_RTL_U64_C(0x45CAE0F1F545EB73),
  __SEGGER_RTL_U64_C(0x468D6FADBF2DD4F3),
  __SEGGER_RTL_U64_C(0x47521CC5A2E6A9E0),
  __SEGGER_RTL_U64_C(0x4818EE218A3358EE),
  __SEGGER_RTL_U64_C(0x48E1E9B9D588E19B),
  __SEGGER_RTL_U64_C(0x49AD159789F37496),
  __SEGGER_RTL_U64_C(0x4A7A77D47F7B84B1),
  __SEGGER_RTL_U64_C(0x4B4A169B900C2D00),
  __SEGGER_RTL_U64_C(0x4C1BF828C6DC54B8),
  __SEGGER_RTL_U64_C(0x4CF022C9905BFD32),
  __SEGGER_RTL_U64_C(0x4DC69CDCEAA72A9C),
  __SEGGER_RTL_U64_C(0x4E9F6CD3967FDBA8),
  __SEGGER_RTL_U64_C(0x4F7A993048D088D7),
  __SEGGER_RTL_U64_C(0x50582887DCB8A7E1),
  __SEGGER_RTL_U64_C(0x513821818624B40C),
  __SEGGER_RTL_U64_C(0x521A8AD704F3404F),
  __SEGGER_RTL_U64_C(0x52FF6B54D8A89C75),
  __SEGGER_RTL_U64_C(0x53E6C9DA74B29AB5),
  __SEGGER_RTL_U64_C(0x54D0AD5A753E077C),
  __SEGGER_RTL_U64_C(0x55BD1CDAD49F699C),
  __SEGGER_RTL_U64_C(0x56AC1F752150A563),
  __SEGGER_RTL_U64_C(0x579DBC56B48521BA),
  __SEGGER_RTL_U64_C(0x5891FAC0E95612C8),
  __SEGGER_RTL_U64_C(0x5988E20954889245),
  __SEGGER_RTL_U64_C(0x5A827999FCEF3242),
  __SEGGER_RTL_U64_C(0x5B7EC8F19468BBC9),
  __SEGGER_RTL_U64_C(0x5C7DD7A3B17DCF75),
  __SEGGER_RTL_U64_C(0x5D7FAD59099F22FE),
  __SEGGER_RTL_U64_C(0x5E8451CFAC061B5F),
  __SEGGER_RTL_U64_C(0x5F8BCCDB3D398841),
  __SEGGER_RTL_U64_C(0x6096266533384A2B),
  __SEGGER_RTL_U64_C(0x61A3666D124BB204),
  __SEGGER_RTL_U64_C(0x62B39508AA836D6F),
  __SEGGER_RTL_U64_C(0x63C6BA6455DCD8AE),
  __SEGGER_RTL_U64_C(0x64DCDEC3371793D1),
  __SEGGER_RTL_U64_C(0x65F60A7F79393E2E),
  __SEGGER_RTL_U64_C(0x6712460A8FC24072),
  __SEGGER_RTL_U64_C(0x683199ED779592CA),
  __SEGGER_RTL_U64_C(0x69540EC8F895722D),
  __SEGGER_RTL_U64_C(0x6A79AD55E7F6FD10),
  __SEGGER_RTL_U64_C(0x6BA27E656B4EB57A),
  __SEGGER_RTL_U64_C(0x6CCE8AE13C57EBDB),
  __SEGGER_RTL_U64_C(0x6DFDDBCBED791BAB),
  __SEGGER_RTL_U64_C(0x6F307A412F074892),
  __SEGGER_RTL_U64_C(0x70666F76154A7089),
  __SEGGER_RTL_U64_C(0x719FC4B95F452D29),
  __SEGGER_RTL_U64_C(0x72DC8373BE41A454),
  __SEGGER_RTL_U64_C(0x741CB5281E25EE34),
  __SEGGER_RTL_U64_C(0x75606373EE921C97),
  __SEGGER_RTL_U64_C(0x76A7980F6CCA15C2),
  __SEGGER_RTL_U64_C(0x77F25CCDEE6D7AE6),
  __SEGGER_RTL_U64_C(0x7940BB9E2CFFD89D),
  __SEGGER_RTL_U64_C(0x7A92BE8A92436616),
  __SEGGER_RTL_U64_C(0x7BE86FB985689DDC),
  __SEGGER_RTL_U64_C(0x7D41D96DB915019D),
  __SEGGER_RTL_U64_C(0x7E9F06067A4360BA),
};

static __SEGGER_RTL_RODATA __SEGGER_RTL_U32 __SEGGER_RTL_kahan_aT2[64] = {
  __SEGGER_RTL_U32_C(0x01500),
  __SEGGER_RTL_U32_C(0x02EF8),
  __SEGGER_RTL_U32_C(0x04D67),
  __SEGGER_RTL_U32_C(0x06B02),
  __SEGGER_RTL_U32_C(0x087BE),
  __SEGGER_RTL_U32_C(0x0A395),
  __SEGGER_RTL_U32_C(0x0BE7A),
  __SEGGER_RTL_U32_C(0x0D866),
  __SEGGER_RTL_U32_C(0x0F14A),
  __SEGGER_RTL_U32_C(0x1091B),
  __SEGGER_RTL_U32_C(0x11FCD),
  __SEGGER_RTL_U32_C(0x13552),
  __SEGGER_RTL_U32_C(0x14999),
  __SEGGER_RTL_U32_C(0x15C98),
  __SEGGER_RTL_U32_C(0x16E34),
  __SEGGER_RTL_U32_C(0x17E5F),
  __SEGGER_RTL_U32_C(0x18D03),
  __SEGGER_RTL_U32_C(0x19A01),
  __SEGGER_RTL_U32_C(0x1A545),
  __SEGGER_RTL_U32_C(0x1AE8A),
  __SEGGER_RTL_U32_C(0x1B5C4),
  __SEGGER_RTL_U32_C(0x1BB01),
  __SEGGER_RTL_U32_C(0x1BFDE),
  __SEGGER_RTL_U32_C(0x1C28D),
  __SEGGER_RTL_U32_C(0x1C2DE),
  __SEGGER_RTL_U32_C(0x1C0DB),
  __SEGGER_RTL_U32_C(0x1BA73),
  __SEGGER_RTL_U32_C(0x1B11C),
  __SEGGER_RTL_U32_C(0x1A4B5),
  __SEGGER_RTL_U32_C(0x1953D),
  __SEGGER_RTL_U32_C(0x18266),
  __SEGGER_RTL_U32_C(0x16BE0),
  __SEGGER_RTL_U32_C(0x1683E),
  __SEGGER_RTL_U32_C(0x179D8),
  __SEGGER_RTL_U32_C(0x18A4D),
  __SEGGER_RTL_U32_C(0x19992),
  __SEGGER_RTL_U32_C(0x1A789),
  __SEGGER_RTL_U32_C(0x1B445),
  __SEGGER_RTL_U32_C(0x1BF61),
  __SEGGER_RTL_U32_C(0x1C989),
  __SEGGER_RTL_U32_C(0x1D16D),
  __SEGGER_RTL_U32_C(0x1D77B),
  __SEGGER_RTL_U32_C(0x1DDDF),
  __SEGGER_RTL_U32_C(0x1E2AD),
  __SEGGER_RTL_U32_C(0x1E5BF),
  __SEGGER_RTL_U32_C(0x1E6E8),
  __SEGGER_RTL_U32_C(0x1E654),
  __SEGGER_RTL_U32_C(0x1E3CD),
  __SEGGER_RTL_U32_C(0x1DF2A),
  __SEGGER_RTL_U32_C(0x1D635),
  __SEGGER_RTL_U32_C(0x1CB16),
  __SEGGER_RTL_U32_C(0x1BE2C),
  __SEGGER_RTL_U32_C(0x1AE4E),
  __SEGGER_RTL_U32_C(0x19BDE),
  __SEGGER_RTL_U32_C(0x1868E),
  __SEGGER_RTL_U32_C(0x16E2E),
  __SEGGER_RTL_U32_C(0x1527F),
  __SEGGER_RTL_U32_C(0x1334A),
  __SEGGER_RTL_U32_C(0x11051),
  __SEGGER_RTL_U32_C(0x0E951),
  __SEGGER_RTL_U32_C(0x0BE01),
  __SEGGER_RTL_U32_C(0x08E0D),
  __SEGGER_RTL_U32_C(0x05924),
  __SEGGER_RTL_U32_C(0x01EDD)
};

static __SEGGER_RTL_RODATA struct {
  struct { double P[8]; } Poly;
} __SEGGER_RTL_float64_SinCos = {
  { { K_SINCOS_P_DBL } }
};

static __SEGGER_RTL_RODATA struct {
  struct { float P[5]; } Poly;
} __SEGGER_RTL_float32_SinCos = {
  { { K_SINCOS_P_FLT } }
};

static __SEGGER_RTL_RODATA struct {
  struct { float A[2]; float B[2]; } Quadrant;
  struct { float P[5]; float Q[5]; } Poly;
} __SEGGER_RTL_float32_ASinACos = {
  { { 0.0f, (float)M_PI_4 },
    { (float)M_PI_2, (float)M_PI_4 } },
  { { K_ASINACOS_P_FLT },
    { K_ASINACOS_Q_FLT } },
};

static __SEGGER_RTL_RODATA struct {
  double P[4];
  double Q[3];
} __SEGGER_RTL_float64_Sinh = {
  { K_SINH_P_DBL },
  { K_SINH_Q_DBL }
};

static __SEGGER_RTL_RODATA struct {
  struct { double A[2]; double B[2]; } Quadrant;
  struct { double P[5]; double Q[5]; } Poly;
} __SEGGER_RTL_float64_ASinACos = {
  { { 0.0, M_PI_4 },
    { M_PI_2, M_PI_4 } },
  { { K_ASINACOS_P_DBL },
    { K_ASINACOS_Q_DBL } }
};

static __SEGGER_RTL_RODATA struct {
  struct { double P[2]; double Q[3]; } Poly;
} __SEGGER_RTL_float64_Log = {
  { { K_LOG_P_DBL },
    { K_LOG_Q_DBL } }
};

static __SEGGER_RTL_RODATA struct {
  struct { double P[3]; double Q[4]; } Poly;
} __SEGGER_RTL_float64_Tan = {
  { { K_TAN_P_DBL },
    { K_TAN_Q_DBL } }
};

static __SEGGER_RTL_RODATA struct {
  struct { float P[3]; float Q[4]; } Poly;
} __SEGGER_RTL_float32_Tan = {
  { { K_TAN_P_FLT },
    { K_TAN_Q_FLT } }
};

static __SEGGER_RTL_RODATA struct {
  struct { double A[4]; } Quadrant;
  struct { double P[4]; double Q[4]; } Poly;
} __SEGGER_RTL_float64_ATan = {
  { { 0.0, M_PI_6, M_PI_2, M_PI_3 } },
  { { K_ATAN_P_DBL },
    { K_ATAN_Q_DBL } }
};

static __SEGGER_RTL_RODATA struct {
  struct { float A[4]; } Quadrant;
  struct { float P[4]; float Q[4]; } Poly;
} __SEGGER_RTL_float32_ATan = {
  { { 0.0, (float)M_PI_6, (float)M_PI_2, (float)M_PI_3 } },
  { { K_ATAN_P_FLT },
    { K_ATAN_Q_FLT } }
};

static __SEGGER_RTL_RODATA struct {
  struct { double P[3]; double Q[3]; } Poly;
} __SEGGER_RTL_float64_Tanh = {
  { { K_TANH_P_DBL },
    { K_TANH_Q_DBL } }
};

static __SEGGER_RTL_RODATA struct {
  struct { float P[3]; float Q[3]; } Poly;
} __SEGGER_RTL_float32_Tanh = {
  { { K_TANH_P_FLT },
    { K_TANH_Q_FLT } }
};






static __SEGGER_RTL_RODATA __SEGGER_RTL_U32 __SEGGER_RTL_float32_Exp_std_2tojby8[] = {
  __SEGGER_RTL_U32_C(0x2D413CCD),
  __SEGGER_RTL_U32_C(0x3159CA84),
  __SEGGER_RTL_U32_C(0x35D13F33),
  __SEGGER_RTL_U32_C(0x3AB031BA),
  __SEGGER_RTL_U32_C(0x40000000),
  __SEGGER_RTL_U32_C(0x45CAE0F2),
  __SEGGER_RTL_U32_C(0x4C1BF829),
  __SEGGER_RTL_U32_C(0x52FF6B55),
  __SEGGER_RTL_U32_C(0x5A82799A),
};
# 951 "./floatops.c"
static __SEGGER_RTL_RODATA __SEGGER_RTL_U32 __SEGGER_RTL_float32_Exp_rot_twojby8[] = {
  __SEGGER_RTL_U32_C(0x40000000),
  __SEGGER_RTL_U32_C(0x45CAE0F2),
  __SEGGER_RTL_U32_C(0x4C1BF829),
  __SEGGER_RTL_U32_C(0x52FF6B55),
  __SEGGER_RTL_U32_C(0x2D413CCD),
  __SEGGER_RTL_U32_C(0x3159CA84),
  __SEGGER_RTL_U32_C(0x35D13F33),
  __SEGGER_RTL_U32_C(0x3AB031BA),
};


static __SEGGER_RTL_RODATA __SEGGER_RTL_U8 __SEGGER_RTL_float32_tanh_Reciprocal[] = {
  0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,
  0xC8, 0xC8, 0xC9, 0xCA, 0xCA, 0xCB, 0xCC, 0xCC,
  0xCD, 0xCE, 0xCE, 0xCF, 0xD0, 0xD0, 0xD1, 0xD1,
  0xD2, 0xD2, 0xD3, 0xD3, 0xD4, 0xD4, 0xD5, 0xD5,
  0xD6, 0xD6, 0xD6, 0xD7, 0xD7, 0xD8, 0xD8, 0xD8,
  0xD9, 0xD9, 0xDA, 0xDA, 0xDA, 0xDB, 0xDB, 0xDB,
  0xDC, 0xDC, 0xDC, 0xDD, 0xDD, 0xDD, 0xDD, 0xDE,
  0xDE, 0xDE, 0xDF, 0xDF, 0xDF, 0xDF, 0xE0, 0xE0,
};
# 998 "./floatops.c"
static __SEGGER_RTL_INLINE __SEGGER_RTL_U32 __SEGGER_RTL_Div64by32_Moeller(__SEGGER_RTL_U32 u1, __SEGGER_RTL_U32 d) {
  __SEGGER_RTL_U32 q0, q1;
  __SEGGER_RTL_U32 p0, p1;
  __SEGGER_RTL_U32 d0;
  __SEGGER_RTL_U32 v0, v1, v2;
  __SEGGER_RTL_U32 e;
  __SEGGER_RTL_U32 r;



  d0 = d & 1;
  v0 = ((1uL << 24) - (1uL<<14) + (1uL << 9)) / (d >> 22);
  v1 = (v0 << 4) - __SEGGER_RTL_UMULL_HI(v0*v0, (d >> 11) + 1) - 1;
  e = 0u - (v1 * ((d >> 1) + d0));
  if (d0) {
    e += v1 >> 1;
  }
  v2 = (v1 << 15) + (__SEGGER_RTL_UMULL_HI(v1, e) >> 1);

  p0 = d;
  p1 = d;
  __SEGGER_RTL_UMLAL(p0, p1, v2, d);



  __SEGGER_RTL_UMULL(q0, q1, v2 - p1, u1);
  q1 += u1 + 1;



  r = 0u - q1*d;
  if (r > q0) {
    q1 -= 1;
    r += d;
  }
  if (r >= d) {
    q1 += 1;

  }
  return q1;
}
# 1060 "./floatops.c"
static __SEGGER_RTL_INLINE __SEGGER_RTL_U32 __SEGGER_RTL_Div64by32_Warren(__SEGGER_RTL_U32 u1, __SEGGER_RTL_U32 v) {
#if __SEGGER_RTL_OPTIMIZE < 0




  return (((__SEGGER_RTL_U64)u1) << 32) / v;

#else



  __SEGGER_RTL_U32 base = 65536;
  __SEGGER_RTL_U32 vn1, vn0;
  __SEGGER_RTL_U32 q1, q0;
  __SEGGER_RTL_U32 un21;
  __SEGGER_RTL_U32 rhat;



  vn1 = v >> 16;
  vn0 = v & 0xFFFF;



  __SEGGER_RTL_DIVMOD_U32(q1, rhat, u1, vn1);
  for (;;) {
    if (q1 >= base || q1*vn0 > base*rhat) {
      q1 -= 1;
      rhat += vn1;
      if (rhat >= base) {
        break;
      }
    } else {
      break;
    }
  }



  un21 = u1*base - q1*v;
  __SEGGER_RTL_DIVMOD_U32(q0, rhat, un21, vn1);

  for (;;) {
    if (q0 >= base || q0*vn0 > base*rhat) {
      q0 -= 1;
      rhat += vn1;
      if (rhat >= base) {
        break;
      }
    } else {
      break;
    }
  }



  return q1*base + q0;

#endif
}
# 1139 "./floatops.c"
static __SEGGER_RTL_INLINE __SEGGER_RTL_U64 __SEGGER_RTL_Div128by64(__SEGGER_RTL_U64 u1, __SEGGER_RTL_U64 v) {
  __SEGGER_RTL_U64 base = __SEGGER_RTL_U64_C(1) << 32;
  __SEGGER_RTL_U64 vn1, vn0;
  __SEGGER_RTL_U64 q1, q0;
  __SEGGER_RTL_U64 un21;
  __SEGGER_RTL_U64 rhat;



  vn1 = __SEGGER_RTL_U64_H(v);
  vn0 = __SEGGER_RTL_U64_L(v);



  __SEGGER_RTL_DIVMOD_U64(q1, rhat, u1, vn1);

  do {
    if (q1 < base && q1*vn0 <= base*rhat) {
      break;
    }
    q1 -= 1;
    rhat += vn1;
  } while (rhat < base);



  un21 = u1*base - q1*v;
  __SEGGER_RTL_DIVMOD_U64(q0, rhat, un21, vn1);

  do {
    if (q0 < base && q0*vn0 <= base*rhat) {
      break;
    }
    q0 -= 1;
    rhat += vn1;
  } while (rhat < base);



  return q1*base + q0;
}
# 1194 "./floatops.c"
static __SEGGER_RTL_INLINE __SEGGER_RTL_U64 __SEGGER_RTL_SquareHi_U64(__SEGGER_RTL_U64 x) {
  __SEGGER_RTL_U64 hh;
  __SEGGER_RTL_U32 hl;

  hh = __SEGGER_RTL_UMULL_X (__SEGGER_RTL_U64_H(x), __SEGGER_RTL_U64_H(x));
  hl = __SEGGER_RTL_UMULL_HI(__SEGGER_RTL_U64_H(x), __SEGGER_RTL_U64_L(x));

  return hh + hl + hl;
}

#if defined(__SEGGER_RTL_FLOAT16)
# 1219 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE __SEGGER_RTL_U16 __SEGGER_RTL_BitcastToU16_inline(__SEGGER_RTL_FLOAT16 x) {
  SEGGER_RTL_float16_t xx;

  xx.f = x;
  return xx.l;
}
#endif

#if defined(__SEGGER_RTL_FLOAT16)
# 1241 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE __SEGGER_RTL_FLOAT16 __SEGGER_RTL_BitcastToF16_inline(__SEGGER_RTL_U16 x) {
  SEGGER_RTL_float16_t xx;

  xx.l = x;
  return xx.f;
}
#endif
# 1263 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE __SEGGER_RTL_U32 __SEGGER_RTL_BitcastToU32_inline(float x) {
  SEGGER_RTL_float32_t xx;

  xx.f = x;
  return xx.l;
}
# 1283 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE float __SEGGER_RTL_BitcastToF32_inline(__SEGGER_RTL_U32 x) {
  SEGGER_RTL_float32_t xx;

  xx.l = x;
  return xx.f;
}
# 1303 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE __SEGGER_RTL_U64 __SEGGER_RTL_BitcastToU64_inline(double x) {
  SEGGER_RTL_float64_t xx;

  xx.f = x;
  return xx.l;
}
# 1323 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE double __SEGGER_RTL_BitcastToF64_inline(__SEGGER_RTL_U64 x) {
  SEGGER_RTL_float64_t xx;

  xx.l = x;
  return xx.f;
}
# 1356 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float32_isspecial_soft(__SEGGER_RTL_U32 x) {
  return (x << 1 >> 24) - 1u >= 0xFE;
}
# 1379 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float32_isspecial(float x) {
#if defined(__SEGGER_RTL_FLOAT32_ISSPECIAL)
  return __SEGGER_RTL_FLOAT32_ISSPECIAL(x);
#else
  return __SEGGER_RTL_float32_isspecial_soft(__SEGGER_RTL_BitcastToU32(x));
#endif
}
# 1406 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float32_isspecial_or_negative_soft(__SEGGER_RTL_U32 x) {
  return (__SEGGER_RTL_UINT_LEAST16_T)(x >> 23) - 1u >= 0xFE;
}
# 1429 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float32_isspecial_or_negative(float x) {
#if defined(__SEGGER_RTL_FLOAT32_ISSPECIAL_OR_NEGATIVE)
  return __SEGGER_RTL_FLOAT32_ISSPECIAL_OR_NEGATIVE(x);
#else
  return __SEGGER_RTL_float32_isspecial_or_negative_soft(__SEGGER_RTL_BitcastToU32(x));
#endif
}
# 1456 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float64_isspecial_soft(__SEGGER_RTL_U64 x) {
  return ((__SEGGER_RTL_UINT_LEAST16_T)(x >> 52) & 0x7FFu) - 1u >= 0x7FEu;
}
# 1479 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float64_isspecial(double x) {
#if defined(__SEGGER_RTL_FLOAT64_ISSPECIAL)
  return __SEGGER_RTL_FLOAT64_ISSPECIAL(x);
#else
  return __SEGGER_RTL_float64_isspecial_soft(__SEGGER_RTL_BitcastToU64(x));
#endif
}
# 1506 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float64_isspecial_or_negative(double x) {
#if defined(__SEGGER_RTL_FLOAT64_ISSPECIAL_OR_NEGATIVE)
  return __SEGGER_RTL_FLOAT64_ISSPECIAL_OR_NEGATIVE(x);
#else
  return (__SEGGER_RTL_UINT_LEAST16_T)(__SEGGER_RTL_BitcastToU64(x) >> 52) - 1u >= 0x7FEu;
#endif
}
# 1528 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float32_isinf_soft(__SEGGER_RTL_U32 x) {
  return (x << 1) == __SEGGER_RTL_X2(K_INF_U32);
}






static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float32_isinf_inline(float x) {
#if defined(__SEGGER_RTL_FLOAT32_ISINF)
  return __SEGGER_RTL_FLOAT32_ISINF(x);
#else
  return __SEGGER_RTL_float32_isinf_soft(__SEGGER_RTL_BitcastToU32(x));
#endif
}
# 1559 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float32_isposinf_soft(__SEGGER_RTL_U32 x) {
  return x == K_INF_U32;
}






static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float32_isposinf_inline(float x) {
#if defined(__SEGGER_RTL_FLOAT32_ISPOSINF)
  return __SEGGER_RTL_FLOAT32_ISPOSINF(x);
#else
  return __SEGGER_RTL_float32_isposinf_soft(__SEGGER_RTL_BitcastToU32(x));
#endif
}
# 1590 "./floatops.c"
static __SEGGER_RTL_INLINE int __SEGGER_RTL_float32_iszero_inline(float x) {
#if __SEGGER_RTL_FP_HW >= 1 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return x == 0;
#else
  return (__SEGGER_RTL_BitcastToU32(x) << 1) == 0;
#endif
}
# 1617 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float32_putative_iszero_soft(__SEGGER_RTL_U32 x) {
#if __SEGGER_RTL_TYPESET == 16
  return FLOAT32_EXPONENT(x) == 0;
#else
  return (x << 1) < __SEGGER_RTL_U32_C(0x01000000);
#endif
}
# 1644 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float64_putative_iszero_soft(__SEGGER_RTL_U64 x) {
#if __SEGGER_RTL_TYPESET == 16
  return FLOAT64_EXPONENT(x) == 0;
#else
  return (x << 1) < __SEGGER_RTL_U64_C(0x0020000000000000);
#endif
}
# 1674 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float32_putative_iszero(float x) {
#if __SEGGER_RTL_FP_HW >= 1 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return x == 0;
#else
  return (__SEGGER_RTL_BitcastToU32(x) << 1) < __SEGGER_RTL_U32_C(0x01000000);
#endif
}
# 1704 "./floatops.c"
static __SEGGER_RTL_INLINE int __SEGGER_RTL_float64_putative_iszero(double x) {
#if __SEGGER_RTL_FP_HW >= 2 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return x == 0;
#else
  return __SEGGER_RTL_float64_putative_iszero_soft(__SEGGER_RTL_BitcastToU64(x));
#endif
}
# 1729 "./floatops.c"
static __SEGGER_RTL_INLINE int __SEGGER_RTL_float32_exact_iszero(float x) {
#if __SEGGER_RTL_FP_HW >= 1 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return x == 0;
#else
  return (__SEGGER_RTL_BitcastToU32(x) << 1) == 0;
#endif
}
# 1754 "./floatops.c"
static __SEGGER_RTL_INLINE int __SEGGER_RTL_float64_exact_iszero(double x) {
#if __SEGGER_RTL_FP_HW >= 2 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return x == 0;
#else
  return (__SEGGER_RTL_BitcastToU64(x) << 1) == 0;
#endif
}
# 1776 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float32_isnan_soft(__SEGGER_RTL_U32 x) {
#if __SEGGER_RTL_NAN_FORMAT == __SEGGER_RTL_NAN_FORMAT_IEEE
  return (x << 1) > __SEGGER_RTL_U32_C(0xFF000000);
#elif __SEGGER_RTL_NAN_FORMAT == __SEGGER_RTL_NAN_FORMAT_FAST
  return (x << 1) > __SEGGER_RTL_U32_C(0xFF000000);
#elif __SEGGER_RTL_NAN_FORMAT == __SEGGER_RTL_NAN_FORMAT_COMPACT
  return (__SEGGER_RTL_U16)((__SEGGER_RTL_U16)(x >> 16) << 1) > 0xFF00u;
#else
  #error should not happen: misconfigured __SEGGER_RTL_NAN_FORMAT
#endif
}
# 1802 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float32_isnan_inline(float x) {
#if defined(__SEGGER_RTL_FLOAT32_ISNAN)
  return __SEGGER_RTL_FLOAT32_ISNAN(x);
#elif __SEGGER_RTL_FP_HW >= 1 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return x != x;
#else
  return __SEGGER_RTL_float32_isnan_soft(__SEGGER_RTL_BitcastToU32(x));
#endif
}
# 1826 "./floatops.c"
static __SEGGER_RTL_INLINE int __SEGGER_RTL_float32_isfinite_soft(__SEGGER_RTL_U32 x) {
  return (x << 1) < __SEGGER_RTL_U32_C(0xFF000000);
}
# 1841 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float32_isfinite_inline(float x) {
#if defined(__SEGGER_RTL_FLOAT32_ISFINITE)
  return __SEGGER_RTL_FLOAT32_ISFINITE(x);
#else
  return __SEGGER_RTL_float32_isfinite_soft(__SEGGER_RTL_BitcastToU32(x));
#endif
}






static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float32_isnormal_inline(float x) {
#if defined(__SEGGER_RTL_FLOAT32_ISNORMAL)
  return __SEGGER_RTL_FLOAT32_ISNORMAL(x);
#else
  return (__SEGGER_RTL_BitcastToU32(x) << 1) < __SEGGER_RTL_U32_C(0xFF000000) &&
         (__SEGGER_RTL_BitcastToU32(x) << 1) >= __SEGGER_RTL_U32_C(0x01000000);
#endif
}






static __SEGGER_RTL_INLINE int __SEGGER_RTL_float32_lt0_true(float x) {
#if __SEGGER_RTL_FP_HW >= 1
  return x < 0;
#else
  return !__SEGGER_RTL_float32_iszero_inline(x) && (__SEGGER_RTL_BitcastToU32(x) & FLOAT32_SIGN_MASK);
#endif
}
# 1898 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float32_lt0_nonzero_finite(float x) {
#if __SEGGER_RTL_FP_HW >= 1
  return x < 0;
#else
  return __SEGGER_RTL_BitcastToU32(x) & FLOAT32_SIGN_MASK;
#endif
}
# 1928 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float64_lt0_nonzero_finite(double x) {
#if __SEGGER_RTL_FP_HW >= 2
  return x < 0;
#else
  return (__SEGGER_RTL_BitcastToU64(x) & FLOAT64_SIGN_MASK) != 0;
#endif
}
# 1950 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float64_isinf_soft(__SEGGER_RTL_U64 x) {
#if __SEGGER_RTL_NAN_FORMAT == __SEGGER_RTL_NAN_FORMAT_IEEE

  #if 1






    return (x == K_INF_U64) || (x == K_MINUS_INF_U64);
  #else
    return (x << 1) == __SEGGER_RTL_U64_C(0xFFE0000000000000);
  #endif

#elif __SEGGER_RTL_NAN_FORMAT == __SEGGER_RTL_NAN_FORMAT_FAST
  return (__SEGGER_RTL_U64_H(x) << 1) == __SEGGER_RTL_U32_C(0xFFE00000);
#elif __SEGGER_RTL_NAN_FORMAT == __SEGGER_RTL_NAN_FORMAT_COMPACT
  return (__SEGGER_RTL_U16)((__SEGGER_RTL_U16)(__SEGGER_RTL_U64_H(x) >> 16) << 1) == (__SEGGER_RTL_U16)0xFFE0;
#else
  #error should not happen: misconfigured __SEGGER_RTL_NAN_FORMAT
#endif
}






static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float64_isinf_inline(double x) {
#if defined(__SEGGER_RTL_FLOAT64_ISINF)
  return __SEGGER_RTL_FLOAT64_ISINF(x);
#else
  return __SEGGER_RTL_float64_isinf_soft(__SEGGER_RTL_BitcastToU64(x));
#endif
}
# 2001 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float64_isposinf_soft(__SEGGER_RTL_U64 x) {
#if __SEGGER_RTL_NAN_FORMAT == __SEGGER_RTL_NAN_FORMAT_IEEE
  return x == K_INF_U64;
#elif __SEGGER_RTL_NAN_FORMAT == __SEGGER_RTL_NAN_FORMAT_FAST
  return __SEGGER_RTL_U64_H(x) == __SEGGER_RTL_U64_H(K_INF_U64);
#elif __SEGGER_RTL_NAN_FORMAT == __SEGGER_RTL_NAN_FORMAT_COMPACT
  return (__SEGGER_RTL_U16)(__SEGGER_RTL_U64_H(x) >> 16) == (__SEGGER_RTL_U16)(__SEGGER_RTL_U64_H(K_INF_U64) >> 16);
#else
  #error should not happen: misconfigured __SEGGER_RTL_NAN_FORMAT
#endif
}






static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float64_isposinf_inline(double x) {
#if defined(__SEGGER_RTL_FLOAT64_ISPOSINF)
  return __SEGGER_RTL_FLOAT64_ISPOSINF(x);
#else
  return __SEGGER_RTL_float64_isposinf_soft(__SEGGER_RTL_BitcastToU64(x));
#endif
}
# 2040 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float32_isneginf_soft(__SEGGER_RTL_U32 x) {
  return x == K_MINUS_INF_U32;
}
# 2058 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float64_isneginf_soft(__SEGGER_RTL_U64 x) {
#if __SEGGER_RTL_NAN_FORMAT == __SEGGER_RTL_NAN_FORMAT_IEEE
  return x == K_MINUS_INF_U64;
#elif __SEGGER_RTL_NAN_FORMAT == __SEGGER_RTL_NAN_FORMAT_FAST
  return __SEGGER_RTL_U64_H(x) == __SEGGER_RTL_U64_H(K_MINUS_INF_U64);
#elif __SEGGER_RTL_NAN_FORMAT == __SEGGER_RTL_NAN_FORMAT_COMPACT
  return (__SEGGER_RTL_U16)(__SEGGER_RTL_U64_H(x) >> 16) == (__SEGGER_RTL_U16)(__SEGGER_RTL_U64_H(K_MINUS_INF_U64) >> 16);
#else
  #error should not happen: misconfigured __SEGGER_RTL_NAN_FORMAT
#endif
}






static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float32_isneginf_inline(float x) {
#if defined(__SEGGER_RTL_FLOAT32_ISNEGINF)
  return __SEGGER_RTL_FLOAT32_ISNEGINF(x);
#else
  return __SEGGER_RTL_float32_isneginf_soft(__SEGGER_RTL_BitcastToU32(x));
#endif
}






static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float64_isneginf_inline(double x) {
#if defined(__SEGGER_RTL_FLOAT64_ISNEGINF)
  return __SEGGER_RTL_FLOAT64_ISNEGINF(x);
#else
  return __SEGGER_RTL_float64_isneginf_soft(__SEGGER_RTL_BitcastToU64(x));
#endif
}
# 2110 "./floatops.c"
static __SEGGER_RTL_INLINE int __SEGGER_RTL_float64_iszero_inline(double x) {
#if __SEGGER_RTL_FP_HW >= 1 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return x == 0;
#else
  return (__SEGGER_RTL_BitcastToU64(x) << 1) == 0;
#endif
}
# 2132 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float64_isnan_soft(__SEGGER_RTL_U64 x) {
#if __SEGGER_RTL_NAN_FORMAT == __SEGGER_RTL_NAN_FORMAT_IEEE
  return (x << 1) > __SEGGER_RTL_U64_C(0xFFE0000000000000);
#elif __SEGGER_RTL_NAN_FORMAT == __SEGGER_RTL_NAN_FORMAT_FAST
  return (__SEGGER_RTL_U64_H(x) << 1) > __SEGGER_RTL_U32_C(0xFFE00000);
#elif __SEGGER_RTL_NAN_FORMAT == __SEGGER_RTL_NAN_FORMAT_COMPACT
  return (__SEGGER_RTL_U16)((__SEGGER_RTL_U16)(__SEGGER_RTL_U64_H(x) >> 16) << 1) > (__SEGGER_RTL_U16)(0xFFE0u);
#else
  #error should not happen: misconfigured __SEGGER_RTL_NAN_FORMAT
#endif
}
# 2158 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float64_isnan_inline(double x) {
#if defined(__SEGGER_RTL_FLOAT64_ISNAN)
  return __SEGGER_RTL_FLOAT64_ISNAN(x);
#elif __SEGGER_RTL_FP_HW >= 2 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return x != x;
#else
  return __SEGGER_RTL_float64_isnan_soft(__SEGGER_RTL_BitcastToU64(x));
#endif
}
# 2182 "./floatops.c"
static __SEGGER_RTL_INLINE int __SEGGER_RTL_float64_isfinite_soft(__SEGGER_RTL_U64 x) {
#if __SEGGER_RTL_NAN_FORMAT == __SEGGER_RTL_NAN_FORMAT_IEEE
  return (x << 1) < __SEGGER_RTL_U64_C(0xFFE0000000000000);
#else
  return (__SEGGER_RTL_U64_H(x) << 1) < __SEGGER_RTL_U32_C(0xFFE00000);
#endif
}






static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float64_isfinite_inline(double x) {
#if defined(__SEGGER_RTL_FLOAT64_ISFINITE)
  return __SEGGER_RTL_FLOAT64_ISFINITE(x);
#else
  return __SEGGER_RTL_float64_isfinite_soft(__SEGGER_RTL_BitcastToU64(x));
#endif
}






static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float64_isnormal_inline(double x) {
#if defined(__SEGGER_RTL_FLOAT64_ISNORMAL)
  return __SEGGER_RTL_FLOAT64_ISNORMAL(x);
#else
  return (__SEGGER_RTL_BitcastToU64(x) << 1) < __SEGGER_RTL_U64_C(0xFFE0000000000000) &&
         (__SEGGER_RTL_BitcastToU64(x) << 1) >= __SEGGER_RTL_U64_C(0x0020000000000000);
#endif
}
# 2237 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE __SEGGER_RTL_U32 __SEGGER_RTL_float32_subnormal_flush_soft(__SEGGER_RTL_U32 x) {
  return x & FLOAT32_SIGN_MASK;
}
# 2254 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE __SEGGER_RTL_U64 __SEGGER_RTL_float64_subnormal_flush_soft(__SEGGER_RTL_U64 x) {
  return x & FLOAT64_SIGN_MASK;
}
# 2271 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE float __SEGGER_RTL_float32_subnormal_flush(float x) {
#if __SEGGER_RTL_FP_HW >= 1 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return x;
#else
  return __SEGGER_RTL_BitcastToF32(__SEGGER_RTL_float32_subnormal_flush_soft(__SEGGER_RTL_BitcastToU32(x)));
#endif
}
# 2292 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE double __SEGGER_RTL_float64_subnormal_flush(double x) {
#if __SEGGER_RTL_FP_HW >= 2 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return x;
#else
  return __SEGGER_RTL_BitcastToF64(__SEGGER_RTL_float64_subnormal_flush_soft(__SEGGER_RTL_BitcastToU64(x)));
#endif
}
# 2313 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE __SEGGER_RTL_U32 __SEGGER_RTL_float32_conditional_subnormal_flush_soft(__SEGGER_RTL_U32 x) {
  if (__SEGGER_RTL_float32_putative_iszero_soft(x)) {
    return __SEGGER_RTL_float32_subnormal_flush_soft(x);
  } else {
    return x;
  }
}
# 2334 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE __SEGGER_RTL_U64 __SEGGER_RTL_float64_conditional_subnormal_flush_soft(__SEGGER_RTL_U64 x) {
  if (__SEGGER_RTL_float64_putative_iszero_soft(x)) {
    return __SEGGER_RTL_float64_subnormal_flush_soft(x);
  } else {
    return x;
  }
}
# 2359 "./floatops.c"
static __SEGGER_RTL_INLINE int __SEGGER_RTL_float64_normalize(__SEGGER_RTL_U64 *pI, int q0) {

#if defined(__SEGGER_RTL_CLZ_U32) && !defined(__SEGGER_RTL_CLZ_U32_SYNTHESIZED)

  __SEGGER_RTL_U64 i0;
  unsigned q1;

  i0 = *pI;

  q1 = __SEGGER_RTL_CLZ_U64(i0) - 11;
  i0 <<= q1;
  q0 -= q1;

#else

  __SEGGER_RTL_U64 i0;

  i0 = *pI;

  while (i0 < __SEGGER_RTL_U64_C(0x0010000000000000)) {
    i0 <<= 1;
    q0 -= 1;
  }

#endif

  *pI = i0;

  return q0;
}
# 2407 "./floatops.c"
static __SEGGER_RTL_INLINE int __SEGGER_RTL_float32_normalize(__SEGGER_RTL_U32 *pI, int q0) {

#if defined(__SEGGER_RTL_CLZ_U32) && !defined(__SEGGER_RTL_CLZ_U32_SYNTHESIZED)

  __SEGGER_RTL_U32 i0;
  unsigned q1;

  i0 = *pI;

  q1 = __SEGGER_RTL_CLZ_U32(i0) - 8;
  i0 <<= q1;
  q0 -= q1;

#else

  __SEGGER_RTL_U32 i0;

  i0 = *pI;

  while (i0 < __SEGGER_RTL_U32_C(0x00800000)) {
    i0 <<= 1;
    q0 -= 1;
  }

#endif

  *pI = i0;

  return q0;
}
# 2450 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float32_signbit_soft(__SEGGER_RTL_U32 x) {
  return x >> 31;
}






static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float32_signbit_inline(float x) {
  return __SEGGER_RTL_float32_signbit_soft(__SEGGER_RTL_BitcastToU32(x));
}






static __SEGGER_RTL_INLINE int __SEGGER_RTL_float64_signbit_soft(__SEGGER_RTL_U64 x) {
  return x >> 63;
}






static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float64_signbit_inline(double x) {
  return __SEGGER_RTL_float64_signbit_soft(__SEGGER_RTL_BitcastToU64(x));
}






static __SEGGER_RTL_ALWAYS_INLINE __SEGGER_RTL_U32 __SEGGER_RTL_float32_signbit_xor_soft(__SEGGER_RTL_U32 x, __SEGGER_RTL_U32 y) {
  return x ^ (y & FLOAT32_SIGN_MASK);
}






static __SEGGER_RTL_ALWAYS_INLINE __SEGGER_RTL_U64 __SEGGER_RTL_float64_signbit_xor_soft(__SEGGER_RTL_U64 x, __SEGGER_RTL_U64 y) {
  return x ^ (y & FLOAT64_SIGN_MASK);
}






static __SEGGER_RTL_ALWAYS_INLINE float __SEGGER_RTL_float32_signbit_xor(float x, float y) {
#if defined(__SEGGER_RTL_FLOAT32_SIGNBIT_XOR)
  return __SEGGER_RTL_FLOAT32_SIGNBIT_XOR(x, y);
#else
  return __SEGGER_RTL_BitcastToF32(
           __SEGGER_RTL_float32_signbit_xor_soft(
             __SEGGER_RTL_BitcastToU32(x),
             __SEGGER_RTL_BitcastToU32(y)));
#endif
}






static __SEGGER_RTL_ALWAYS_INLINE double __SEGGER_RTL_float64_signbit_xor(double x, double y) {
#if defined(__SEGGER_RTL_FLOAT64_SIGNBIT_XOR)
  return __SEGGER_RTL_FLOAT64_SIGNBIT_XOR(x, y);
#else
  return __SEGGER_RTL_BitcastToF64(
           __SEGGER_RTL_float64_signbit_xor_soft(
             __SEGGER_RTL_BitcastToU64(x),
             __SEGGER_RTL_BitcastToU64(y)));
#endif
}






static __SEGGER_RTL_INLINE __SEGGER_RTL_U32 __SEGGER_RTL_float32_signbit_copy_soft(__SEGGER_RTL_U32 x, __SEGGER_RTL_U32 y) {
  return (x & ~FLOAT32_SIGN_MASK) | (y & FLOAT32_SIGN_MASK);
}






static __SEGGER_RTL_INLINE __SEGGER_RTL_U64 __SEGGER_RTL_float64_signbit_copy_soft(__SEGGER_RTL_U64 x, __SEGGER_RTL_U64 y) {
  return (x & ~FLOAT64_SIGN_MASK) | (y & FLOAT64_SIGN_MASK);
}






static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_signbit_copy(float x, float y) {
#if defined(__SEGGER_RTL_FLOAT32_SIGNBIT_COPY)

  return __SEGGER_RTL_FLOAT32_SIGNBIT_COPY(x, y);

#elif (__SEGGER_RTL_FP_HW >= 1) && defined(__SEGGER_RTL_FLOAT32_ABS)

  x = __SEGGER_RTL_FLOAT32_ABS(x);
  if (__SEGGER_RTL_BitcastToU32(y) & FLOAT32_SIGN_MASK) {
    return -x;
  } else {
    return x;
  }
#else
  return __SEGGER_RTL_BitcastToF32(
           __SEGGER_RTL_float32_signbit_copy_soft(
             __SEGGER_RTL_BitcastToU32(x),
             __SEGGER_RTL_BitcastToU32(y)));
#endif
}






static __SEGGER_RTL_INLINE double __SEGGER_RTL_float64_signbit_copy(double x, double y) {
#if defined(__SEGGER_RTL_FLOAT64_SIGNBIT_COPY)
  return __SEGGER_RTL_FLOAT64_SIGNBIT_COPY(x, y);
#else
  return __SEGGER_RTL_BitcastToF64(
           __SEGGER_RTL_float64_signbit_copy_soft(
             __SEGGER_RTL_BitcastToU64(x),
             __SEGGER_RTL_BitcastToU64(y)));
#endif
}






static __SEGGER_RTL_INLINE int __SEGGER_RTL_float32_opposite_signs(float x, float y) {
  return ((__SEGGER_RTL_BitcastToU32(x) ^ __SEGGER_RTL_BitcastToU32(y)) & FLOAT32_SIGN_MASK) != 0;
}






static __SEGGER_RTL_INLINE int __SEGGER_RTL_float64_opposite_signs(double x, double y) {
  return ((__SEGGER_RTL_BitcastToU64(x) ^ __SEGGER_RTL_BitcastToU64(y)) & FLOAT64_SIGN_MASK) != 0;
}
# 2624 "./floatops.c"
static __SEGGER_RTL_INLINE int __SEGGER_RTL_float32_lt_soft(__SEGGER_RTL_U32 x, __SEGGER_RTL_U32 y) {
  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_isnan_soft(x) || __SEGGER_RTL_float32_isnan_soft(y))) {
    return 0;
  } else if (__SEGGER_RTL_UNLIKELY(((x | y) << 1) == 0)) {
    return 0;
  } else if (FLOAT32_SIGN(x | y)) {
    return y < x;
  } else {
    return x < y;
  }
}
# 2651 "./floatops.c"
static __SEGGER_RTL_INLINE int __SEGGER_RTL_float32_lt(float x, float y) {
#if __SEGGER_RTL_FP_HW >= 1 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return x < y;
#else
  return __SEGGER_RTL_float32_lt_soft(__SEGGER_RTL_BitcastToU32(x),
                                      __SEGGER_RTL_BitcastToU32(y));
#endif
}
# 2675 "./floatops.c"
static __SEGGER_RTL_INLINE int __SEGGER_RTL_float64_lt_soft(__SEGGER_RTL_U64 x, __SEGGER_RTL_U64 y) {
  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_isnan_soft(x) || __SEGGER_RTL_float64_isnan_soft(y))) {
    return 0;
  } else if (__SEGGER_RTL_UNLIKELY(((x | y) << 1) == 0)) {
    return 0;
  } else if (FLOAT64_SIGN(x | y)) {
    return y < x;
  } else {
    return x < y;
  }
}
# 2702 "./floatops.c"
static __SEGGER_RTL_INLINE int __SEGGER_RTL_float64_lt(double x, double y) {
#if __SEGGER_RTL_FP_HW >= 2 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return x < y;
#else
  return __SEGGER_RTL_float64_lt_soft(__SEGGER_RTL_BitcastToU64(x),
                                      __SEGGER_RTL_BitcastToU64(y));
#endif
}
# 2726 "./floatops.c"
static __SEGGER_RTL_INLINE int __SEGGER_RTL_float32_gt(float x, float y) {
  return __SEGGER_RTL_float32_lt(y, x);
}
# 2745 "./floatops.c"
static __SEGGER_RTL_INLINE int __SEGGER_RTL_float64_gt(double x, double y) {
  return __SEGGER_RTL_float64_lt(y, x);
}
# 2764 "./floatops.c"
static __SEGGER_RTL_INLINE int __SEGGER_RTL_float32_le_soft(__SEGGER_RTL_I32 x, __SEGGER_RTL_I32 y) {
  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_isnan_soft(x) || __SEGGER_RTL_float32_isnan_soft(y))) {
    return 0;
  } else if (__SEGGER_RTL_UNLIKELY(((x | y) << 1) == 0)) {
    return 1;
  } else if (x < 0 && y < 0) {
    return y <= x;
  } else {
    return x <= y;
  }
}
# 2791 "./floatops.c"
static __SEGGER_RTL_INLINE int __SEGGER_RTL_float32_le(float x, float y) {
#if __SEGGER_RTL_FP_HW >= 1 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return x <= y;
#else
  return __SEGGER_RTL_float32_le_soft(__SEGGER_RTL_BitcastToU32(x),
                                      __SEGGER_RTL_BitcastToU32(y));
#endif
}
# 2815 "./floatops.c"
static __SEGGER_RTL_INLINE int __SEGGER_RTL_float64_le_soft(__SEGGER_RTL_U64 x, __SEGGER_RTL_U64 y) {
  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_isnan_soft(x) || __SEGGER_RTL_float64_isnan_soft(y))) {
    return 0;
  } else if (__SEGGER_RTL_UNLIKELY(((x | y) << 1) == 0)) {
    return 1;
  } else if (FLOAT64_SIGN(x | y)) {
    return y <= x;
  } else {
    return x <= y;
  }
}
# 2842 "./floatops.c"
static __SEGGER_RTL_INLINE int __SEGGER_RTL_float64_le(double x, double y) {
#if __SEGGER_RTL_FP_HW >= 2 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return x <= y;
#else
  return __SEGGER_RTL_float64_le_soft(__SEGGER_RTL_BitcastToU64(x),
                                      __SEGGER_RTL_BitcastToU64(y));
#endif
}
# 2866 "./floatops.c"
static __SEGGER_RTL_INLINE int __SEGGER_RTL_float32_ge(float x, float y) {
  return __SEGGER_RTL_float32_le(y, x);
}
# 2885 "./floatops.c"
static __SEGGER_RTL_INLINE int __SEGGER_RTL_float64_ge(double x, double y) {
  return __SEGGER_RTL_float64_le(y, x);
}
# 2904 "./floatops.c"
static __SEGGER_RTL_INLINE int __SEGGER_RTL_float32_eq_soft(__SEGGER_RTL_U32 x, __SEGGER_RTL_U32 y) {
  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_isnan_soft(x) || __SEGGER_RTL_float32_isnan_soft(y))) {
    return 0;
  } else {
    return (x == y) || __SEGGER_RTL_UNLIKELY(((x | y) << 1) == 0);
  }
}
# 2927 "./floatops.c"
static __SEGGER_RTL_INLINE int __SEGGER_RTL_float32_eq(float x, float y) {
#if __SEGGER_RTL_FP_HW >= 1 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return x == y;
#else
  return __SEGGER_RTL_float32_eq_soft(__SEGGER_RTL_BitcastToU32(x),
                                      __SEGGER_RTL_BitcastToU32(y));
#endif
}
# 2951 "./floatops.c"
static int __SEGGER_RTL_float64_eq_soft(__SEGGER_RTL_U64 x, __SEGGER_RTL_U64 y) {
  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_isnan_soft(x) || __SEGGER_RTL_float64_isnan_soft(y))) {
    return 0;
  } else {
    return x == y || __SEGGER_RTL_UNLIKELY(((x | y) << 1) == 0);
  }
}
# 2974 "./floatops.c"
static __SEGGER_RTL_INLINE int __SEGGER_RTL_float64_eq(double x, double y) {
#if __SEGGER_RTL_FP_HW >= 2 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return x == y;
#else
  return __SEGGER_RTL_float64_eq_soft(__SEGGER_RTL_BitcastToU64(x),
                                      __SEGGER_RTL_BitcastToU64(y));
#endif
}
# 2998 "./floatops.c"
static __SEGGER_RTL_INLINE int __SEGGER_RTL_float32_ne_soft(__SEGGER_RTL_U32 x, __SEGGER_RTL_U32 y) {
  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_isnan_soft(x) || __SEGGER_RTL_float32_isnan_soft(y))) {
    return 1;
  } else {
    return x == y ? 0 : ((x | y) << 1) != 0;
  }
}
# 3021 "./floatops.c"
static __SEGGER_RTL_INLINE int __SEGGER_RTL_float32_ne(float x, float y) {
#if __SEGGER_RTL_FP_HW >= 1 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return x != y;
#else
  return __SEGGER_RTL_float32_ne_soft(__SEGGER_RTL_BitcastToU32(x),
                                      __SEGGER_RTL_BitcastToU32(y));
#endif
}
# 3044 "./floatops.c"
static __SEGGER_RTL_INLINE int __SEGGER_RTL_float64_ne_soft(__SEGGER_RTL_U64 x, __SEGGER_RTL_U64 y) {
  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_isnan_soft(x) || __SEGGER_RTL_float64_isnan_soft(y))) {
    return 1;
  } else {
    return x == y ? 0 : ((x | y) << 1) != 0;
  }
}
# 3067 "./floatops.c"
static __SEGGER_RTL_INLINE int __SEGGER_RTL_float64_ne(double x, double y) {
#if __SEGGER_RTL_FP_HW >= 2 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return x != y;
#else
  return __SEGGER_RTL_float64_ne_soft(__SEGGER_RTL_BitcastToU64(x),
                                      __SEGGER_RTL_BitcastToU64(y));
#endif
}
# 3091 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float32_eq_bitwise(float x, float y) {
#if __SEGGER_RTL_FP_HW >= 1 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return x == y;
#else
  return __SEGGER_RTL_BitcastToU32(x) == __SEGGER_RTL_BitcastToU32(y);
#endif
}
# 3114 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float64_eq_bitwise(double x, double y) {
#if __SEGGER_RTL_FP_HW >= 2 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return x == y;
#else
  return __SEGGER_RTL_BitcastToU64(x) == __SEGGER_RTL_BitcastToU64(y);
#endif
}
# 3137 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float64_eq_bitwise_zeros_compare_equal(double x, double y) {
#if __SEGGER_RTL_FP_HW >= 2 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return x == y;
#else
  if (__SEGGER_RTL_BitcastToU64(x) == __SEGGER_RTL_BitcastToU64(y)) {
    return 1;
  } else {
    return __SEGGER_RTL_float64_exact_iszero(x) && __SEGGER_RTL_float64_exact_iszero(y);
  }
#endif
}
# 3164 "./floatops.c"
static __SEGGER_RTL_INLINE int __SEGGER_RTL_float64_eq_finite(double x, double y) {
#if (__SEGGER_RTL_FP_HW >= 2 && !__SEGGER_RTL_FORCE_SOFT_FLOAT) || __SEGGER_RTL_CONFIG_CODE_COVERAGE
  return x == y;
#else
  return __SEGGER_RTL_BitcastToU64(x) == __SEGGER_RTL_BitcastToU64(y);
#endif
}
# 3193 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float32_lt_rhs_positive(float x, float y) {
#if __SEGGER_RTL_FP_HW >= 1 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return x < y;
#else
  return (__SEGGER_RTL_I32)__SEGGER_RTL_BitcastToU32(x) < (__SEGGER_RTL_I32)__SEGGER_RTL_BitcastToU32(y);
#endif
}
# 3222 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float64_lt_rhs_positive(double x, double y) {
#if __SEGGER_RTL_FP_HW >= 2 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return x < y;
#else
  return (__SEGGER_RTL_I64)__SEGGER_RTL_BitcastToU64(x) < (__SEGGER_RTL_I64)__SEGGER_RTL_BitcastToU64(y);
#endif
}
# 3251 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float32_lt_bitwise_unsigned(float x, float y) {
  return (__SEGGER_RTL_I32)__SEGGER_RTL_BitcastToU32(x) < (__SEGGER_RTL_I32)__SEGGER_RTL_BitcastToU32(y);
}
# 3276 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float64_lt_bitwise_unsigned(double x, double y) {
  return (__SEGGER_RTL_I64)__SEGGER_RTL_BitcastToU64(x) < (__SEGGER_RTL_I64)__SEGGER_RTL_BitcastToU64(y);
}
# 3301 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float64_gt_rhs_positive(double x, double y) {
#if __SEGGER_RTL_FP_HW >= 2 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return x > y;
#else
  return (__SEGGER_RTL_I64)__SEGGER_RTL_BitcastToU64(x) > (__SEGGER_RTL_I64)__SEGGER_RTL_BitcastToU64(y);
#endif
}
# 3330 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float64_ge_rhs_positive(double x, double y) {
#if __SEGGER_RTL_FP_HW >= 2 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return x >= y;
#else
  return (__SEGGER_RTL_I64)__SEGGER_RTL_BitcastToU64(x) >= (__SEGGER_RTL_I64)__SEGGER_RTL_BitcastToU64(y);
#endif
}
# 3379 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float32_lt_one_negative(float x, float y) {
#if __SEGGER_RTL_FP_HW >= 1 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return x < y;
#else
  return __SEGGER_RTL_BitcastToU32(y) < __SEGGER_RTL_BitcastToU32(x);
#endif
}
# 3428 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float64_lt_one_negative(double x, double y) {
#if __SEGGER_RTL_FP_HW >= 2 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return x < y;
#else
  return __SEGGER_RTL_BitcastToU64(y) < __SEGGER_RTL_BitcastToU64(x);
#endif
}
# 3451 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float32_gt_rhs_positive(float x, float y) {
#if __SEGGER_RTL_FP_HW >= 1 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return x > y;
#else
  return (__SEGGER_RTL_I32)__SEGGER_RTL_BitcastToU32(x) > (__SEGGER_RTL_I32)__SEGGER_RTL_BitcastToU32(y);
#endif
}
# 3474 "./floatops.c"
static __SEGGER_RTL_INLINE int __SEGGER_RTL_float64_gt_finite(double x, double y) {
#if __SEGGER_RTL_FP_HW >= 2 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return x > y;
#else
  return __SEGGER_RTL_BitcastToU64(x) > __SEGGER_RTL_BitcastToU64(y);
#endif
}
# 3497 "./floatops.c"
static __SEGGER_RTL_INLINE int __SEGGER_RTL_float32_ge_finite(float x, float y) {
#if __SEGGER_RTL_FP_HW >= 1 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return x >= y;
#else
  return __SEGGER_RTL_BitcastToU32(x) >= __SEGGER_RTL_BitcastToU32(y);
#endif
}
# 3520 "./floatops.c"
static __SEGGER_RTL_INLINE int __SEGGER_RTL_float64_ge_finite(double x, double y) {
#if (__SEGGER_RTL_FP_HW >= 2 && !__SEGGER_RTL_FORCE_SOFT_FLOAT) || __SEGGER_RTL_CONFIG_CODE_COVERAGE
  return x >= y;
#else
  return __SEGGER_RTL_BitcastToU64(x) >= __SEGGER_RTL_BitcastToU64(y);
#endif
}
# 3542 "./floatops.c"
static __SEGGER_RTL_INLINE __SEGGER_RTL_U32 __SEGGER_RTL_float32_add_soft(__SEGGER_RTL_U32 x, __SEGGER_RTL_U32 y) {
  unsigned cx, rs;
  int bx, shift;

  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_isspecial_soft(x) || __SEGGER_RTL_float32_isspecial_soft(y))) {



    x = __SEGGER_RTL_float32_conditional_subnormal_flush_soft(x);
    y = __SEGGER_RTL_float32_conditional_subnormal_flush_soft(y);



    if (__SEGGER_RTL_float32_isfinite_soft(x)) {
      if (__SEGGER_RTL_float32_isnan_soft(y)) {
        return K_NAN_U32;
      } else if (__SEGGER_RTL_float32_isinf_soft(y)) {
        return y;
      }
    } else {
      if (__SEGGER_RTL_float32_isnan_soft(x)) {
        return K_NAN_U32;
      } else if (__SEGGER_RTL_float32_isnan_soft(y)) {
        return K_NAN_U32;
      } else if (x == K_INF_U32 && y == K_MINUS_INF_U32) {
        return K_NAN_U32;
      } else if (x == K_MINUS_INF_U32 && y == K_INF_U32) {
        return K_NAN_U32;
      } else if (__SEGGER_RTL_float32_isinf_soft(x)) {
        return x;
      }
    }



    if ((x ^ y) & FLOAT32_SIGN_MASK) {
      if (x == __SEGGER_RTL_U32_C(0x80000000)) {
        return y;
      } else if (y == __SEGGER_RTL_U32_C(0x80000000)) {
        return x;
      } else if (x == __SEGGER_RTL_U32_C(0x00000000)) {
        return y;
      } else if (y == __SEGGER_RTL_U32_C(0x00000000)) {
        return x;
      }
    }
  }



  if ((x ^ y) & FLOAT32_SIGN_MASK) {



    y ^= FLOAT32_SIGN_MASK;



    if (x < y) {



      x ^= y;
      y ^= x;
      x ^= y;



      x ^= FLOAT32_SIGN_MASK;
      y ^= FLOAT32_SIGN_MASK;
    }



    bx = (x >> 23) & 0xFF;
    cx = (y >> 23) & 0xFF;
    rs = x >> 23;

    shift = bx - cx;
    if (shift > 25) {
      return x;
    }



    x &= FLOAT32_SIGNIFICAND_MASK;
    x |= FLOAT32_HIDDEN_MASK;
    y &= FLOAT32_SIGNIFICAND_MASK;
    y |= FLOAT32_HIDDEN_MASK;



    x -= y >> shift;
    y = 0 - y;
    if (shift == 0) {
      y = 0;
    } else {
      y <<= 32 - shift;
    }
    if (y) {
      --x;
      if (x == 0) {
        x = y & __SEGGER_RTL_U32_C(0x80000000) ? 1 : 0;
        --bx;
        y <<= 1;
      }
    }

    if (x == 0) {
      return 0;
    }



    while ((x & __SEGGER_RTL_U32_C(0x00800000)) == 0) {
      x <<= 1;
      if (y & __SEGGER_RTL_U32_C(0x80000000)) {
        ++x;
      }
      y <<= 1;
      --bx;
    }



    if (y >= __SEGGER_RTL_U32_C(0x80000000)) {
      ++x;
      if (y == __SEGGER_RTL_U32_C(0x80000000)) {
        x &= ~__SEGGER_RTL_U32_C(1);
      }
    }
    if (x & __SEGGER_RTL_U32_C(0x01000000)) {
      x >>= 1;
      ++bx;
    }
  } else {



    if (x < y) {



      x ^= y;
      y ^= x;
      x ^= y;
    }



    if ((y << 1) == 0) {
      return x;
    }



    bx = (x >> 23) & 0xFF;
    cx = (y >> 23) & 0xFF;
    rs = x >> 23;




    shift = bx - cx;
    if (shift > 25) {
      return x;
    }



    x &= FLOAT32_SIGNIFICAND_MASK;
    x |= FLOAT32_HIDDEN_MASK;
    y &= FLOAT32_SIGNIFICAND_MASK;
    y |= FLOAT32_HIDDEN_MASK;



    x += y >> shift;
    if (shift == 0) {
      y = 0;
    } else {
      y <<= 32-shift;
    }



    if (x & __SEGGER_RTL_U32_C(0x01000000)) {



      y >>= 1;
      if (x & 1) {
        y |= __SEGGER_RTL_U32_C(0x80000000);
      }
      x >>= 1;
      ++bx;
    }



    if (y >= __SEGGER_RTL_U32_C(0x80000000)) {
      ++x;
      if (y == __SEGGER_RTL_U32_C(0x80000000)) {
        x &= ~__SEGGER_RTL_U32_C(1);
      }
      if (x & __SEGGER_RTL_U32_C(0x01000000)) {
        x >>= 1;
        ++bx;
      }
    }
  }




  if (bx >= 0xFF) {
    bx = 0xFF;
    x = 0;
  } else if (bx <= 0) {
    bx = 0;
    x = 0;
  }



  bx |= (rs & 0x100);



  return (x & ~__SEGGER_RTL_U32_C(0x800000)) | ((__SEGGER_RTL_U32)bx << 23);
}
# 3788 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_add(float x, float y) {
#if __SEGGER_RTL_FP_HW >= 1 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return x + y;
#else
  return __SEGGER_RTL_BitcastToF32(
           __SEGGER_RTL_float32_add_soft(
             __SEGGER_RTL_BitcastToU32(x),
             __SEGGER_RTL_BitcastToU32(y)));
#endif
}
# 3813 "./floatops.c"
static __SEGGER_RTL_INLINE __SEGGER_RTL_U64 __SEGGER_RTL_float64_add_soft(__SEGGER_RTL_U64 b, __SEGGER_RTL_U64 c) {
  unsigned cx;
  unsigned rs;
  int bx;
  int shift;

  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_isspecial_soft(b) || __SEGGER_RTL_float64_isspecial_soft(c))) {



    b = __SEGGER_RTL_float64_conditional_subnormal_flush_soft(b);
    c = __SEGGER_RTL_float64_conditional_subnormal_flush_soft(c);



    if (__SEGGER_RTL_float64_isfinite_soft(b)) {
      if (__SEGGER_RTL_float64_isnan_soft(c)) {
        return K_NAN_U64;
      } else if (__SEGGER_RTL_float64_isinf_soft(c)) {
        return c;
      }
    } else {
      if (__SEGGER_RTL_float64_isnan_soft(b)) {
        return K_NAN_U64;
      } else if (__SEGGER_RTL_float64_isnan_soft(c)) {
        return K_NAN_U64;
      } else if (b == __SEGGER_RTL_U64_C(0x7FF0000000000000) && c == __SEGGER_RTL_U64_C(0xFFF0000000000000)) {
        return K_NAN_U64;
      } else if (b == __SEGGER_RTL_U64_C(0xFFF0000000000000) && c == __SEGGER_RTL_U64_C(0x7FF0000000000000)) {
        return K_NAN_U64;
      } else if (__SEGGER_RTL_float64_isinf_soft(b)) {
        return b;
      }
    }



    if ((b ^ c) & FLOAT64_SIGN_MASK) {
      if (b == K_MINUS_ZERO_U64) {
        return c;
      } else if (c == K_MINUS_ZERO_U64) {
        return b;
      } else if (b == K_ZERO_U64) {
        return c;
      } else if (c == K_ZERO_U64) {
        return b;
      }
    }
  }





  if ((b ^ c) & FLOAT64_SIGN_MASK) {





    c ^= FLOAT64_SIGN_MASK;



    if (b < c) {



      b ^= c;
      c ^= b;
      b ^= c;



      b ^= FLOAT64_SIGN_MASK;
      c ^= FLOAT64_SIGN_MASK;
    }



    rs = b >> FLOAT64_SIGNIFICAND_BITS;



    bx = FLOAT64_EXPONENT(b);
    cx = FLOAT64_EXPONENT(c);

    shift = bx - cx;
    if (shift > 54) {
      return b;
    }



    b &= FLOAT64_SIGNIFICAND_MASK;
    b |= FLOAT64_HIDDEN_MASK;
    c &= FLOAT64_SIGNIFICAND_MASK;
    c |= FLOAT64_HIDDEN_MASK;



    b -= (c >> shift);
    c = 0u - c;
    if (shift == 0) {
      c = 0;
    } else {
      c <<= (64 - shift);
    }
    if (c) {
      --b;
      if (b == 0) {
        b = c & __SEGGER_RTL_U64_C(0x8000000000000000) ? 1 : 0;
        --bx;
        c <<= 1;
      }
    }



    if (b == 0) {
      return 0;
    }



#if defined(__SEGGER_RTL_CLZ_U64) && !defined(__SEGGER_RTL_CLZ_U64_SYNTHESIZED)

    shift = __SEGGER_RTL_CLZ_U64(b) - 11;
    if (shift) {
      b <<= shift;
      b |= c >> (64 - shift);
      c <<= shift;
      bx -= shift;
    }

#else

    while ((b & __SEGGER_RTL_U64_C(0x10000000000000)) == 0) {
      b <<= 1;
      if (c & __SEGGER_RTL_U64_C(0x8000000000000000)) {
        ++b;
      }
      c <<= 1;
      --bx;
    }

#endif



    if (c >= __SEGGER_RTL_U64_C(0x8000000000000000)) {
      ++b;
      if (c == __SEGGER_RTL_U64_C(0x8000000000000000)) {
        b &= ~__SEGGER_RTL_U64_C(1);
      }
    }



    if (b & __SEGGER_RTL_U64_C(0x20000000000000)) {
      b >>= 1;
      ++bx;
    }
  } else {



    if (b < c) {



      b ^= c;
      c ^= b;
      b ^= c;
    }



    if (c == __SEGGER_RTL_U64_C(0x0000000000000000) || c == __SEGGER_RTL_U64_C(0x8000000000000000)) {
      return b;
    }



    rs = b >> FLOAT64_SIGNIFICAND_BITS;



    bx = FLOAT64_EXPONENT(b);
    cx = FLOAT64_EXPONENT(c);




    shift = bx - cx;
    if (shift > 54) {
      return b;
    }



    b &= FLOAT64_SIGNIFICAND_MASK;
    b |= FLOAT64_HIDDEN_MASK;
    c &= FLOAT64_SIGNIFICAND_MASK;
    c |= FLOAT64_HIDDEN_MASK;



    b += c >> shift;
    if (shift == 0) {
      c = 0;
    } else {
      c <<= 64-shift;
    }



    if (b & __SEGGER_RTL_U64_C(0x20000000000000)) {



      c >>= 1;
      if (b & 1) {
        c |= __SEGGER_RTL_U64_C(0x8000000000000000);
      }
      b >>= 1;
      ++bx;
    }



    if (c >= __SEGGER_RTL_U64_C(0x8000000000000000)) {
      ++b;
      if (c == __SEGGER_RTL_U64_C(0x8000000000000000)) {
        b &= ~__SEGGER_RTL_U64_C(1);
      }
      if (b & __SEGGER_RTL_U64_C(0x20000000000000)) {
        b >>= 1;
        ++bx;
      }
    }
  }




  if (bx >= 0x7FF) {
    b = 0;
    bx = 0x7FF;
  } else if (bx <= 0) {
    b = 0;
    bx = 0;
  }



  bx |= (rs & 0x800);



  b &= ~FLOAT64_HIDDEN_MASK;



  return b | ((__SEGGER_RTL_U64)bx << FLOAT64_SIGNIFICAND_BITS);
}
# 4094 "./floatops.c"
static __SEGGER_RTL_INLINE double __SEGGER_RTL_float64_add(double x, double y) {
#if __SEGGER_RTL_FP_HW >= 2 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return x + y;
#else
  return __SEGGER_RTL_BitcastToF64(
           __SEGGER_RTL_float64_add_soft(
             __SEGGER_RTL_BitcastToU64(x),
             __SEGGER_RTL_BitcastToU64(y)));
#endif
}
# 4119 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_sub(float x, float y) {
#if __SEGGER_RTL_FP_HW >= 1 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return x - y;
#else
  return __SEGGER_RTL_BitcastToF32(
           __SEGGER_RTL_float32_add_soft(
             __SEGGER_RTL_BitcastToU32(x),
             __SEGGER_RTL_BitcastToU32(y) ^ FLOAT32_SIGN_MASK));
#endif
}
# 4144 "./floatops.c"
static __SEGGER_RTL_INLINE double __SEGGER_RTL_float64_sub(double x, double y) {
#if __SEGGER_RTL_FP_HW >= 2 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return x - y;
#else
  return __SEGGER_RTL_BitcastToF64(
           __SEGGER_RTL_float64_add_soft(
             __SEGGER_RTL_BitcastToU64(x),
             __SEGGER_RTL_BitcastToU64(y) ^ FLOAT64_SIGN_MASK));
#endif
}
# 4169 "./floatops.c"
static __SEGGER_RTL_INLINE __SEGGER_RTL_U32 __SEGGER_RTL_float32_mul_soft(__SEGGER_RTL_U32 x, __SEGGER_RTL_U32 y) {
  unsigned xx;
  unsigned yx;
  unsigned rs;
  __SEGGER_RTL_UINT_LEAST32_T rb;
  __SEGGER_RTL_U64 p;



  xx = (unsigned)(x >> 23);
  yx = (unsigned)(y >> 23);
  rs = (xx ^ yx) & 0x100;
  xx &= 0xFF;
  yx &= 0xFF;



  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_isspecial_soft(x) || __SEGGER_RTL_float32_isspecial_soft(y))) {
    if (xx == 0 && !__SEGGER_RTL_float32_isfinite_soft(y)) {
       return K_NAN_U32;
    } else if (yx == 0 && !__SEGGER_RTL_float32_isfinite_soft(x)) {
       return K_NAN_U32;
    } else if (__SEGGER_RTL_float32_isnan_soft(x) || __SEGGER_RTL_float32_isnan_soft(y)) {
       return K_NAN_U32;
    } else if (__SEGGER_RTL_float32_isinf_soft(x) || __SEGGER_RTL_float32_isinf_soft(y)) {
      return ((x ^ y) & FLOAT32_SIGN_MASK) | K_INF_U32;
    } else if (xx == 0 || yx == 0) {
      return (x ^ y) & FLOAT32_SIGN_MASK;
    }
  }



  xx += yx - 0x7E;



  x &= __SEGGER_RTL_U32_C(0x7FFFFF);
  x |= __SEGGER_RTL_U32_C(0x800000);
  y &= __SEGGER_RTL_U32_C(0x7FFFFF);
  y |= __SEGGER_RTL_U32_C(0x800000);



  p = __SEGGER_RTL_UMULL_X(x, y);



  if ((p & __SEGGER_RTL_U64_C(0x800000000000)) == 0) {
    p <<= 1;
    --xx;
  }
  rb = __SEGGER_RTL_U64_L(p) & __SEGGER_RTL_U32_C(0xFFFFFF);
  p >>= 24;
  if (rb >= __SEGGER_RTL_U32_C(0x800000)) {
    ++p;
    if (rb == __SEGGER_RTL_U32_C(0x800000)) {
      p &= ~__SEGGER_RTL_U64_C(1);
    }
    if (p & __SEGGER_RTL_U32_C(0x1000000)) {
      p >>= 1;
      ++xx;
    }
  }




  if ((__SEGGER_RTL_I16)xx <= 0) {
    xx = 0;
    p = 0;
  } else if (xx >= 0xFF) {
    xx = 0xFF;
    p = 0;
  }



  xx |= rs;



  return (__SEGGER_RTL_U64_L(p) & ~__SEGGER_RTL_U32_C(0x800000)) | ((__SEGGER_RTL_U32)xx << 23);
}
# 4268 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_mul(float x, float y) {
#if __SEGGER_RTL_FP_HW >= 1 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return x * y;
#else
  return __SEGGER_RTL_BitcastToF32(
           __SEGGER_RTL_float32_mul_soft(
             __SEGGER_RTL_BitcastToU32(x),
             __SEGGER_RTL_BitcastToU32(y)));
#endif
}
# 4293 "./floatops.c"
static __SEGGER_RTL_INLINE __SEGGER_RTL_U64 __SEGGER_RTL_float64_mul_soft(__SEGGER_RTL_U64 x, __SEGGER_RTL_U64 y) {

  __SEGGER_RTL_INT_LEAST16_T xx;
  __SEGGER_RTL_UINT_LEAST16_T yx, rs;

#if defined(__SEGGER_RTL_U128) && defined(__SEGGER_RTL_CORE_HAS_MUL_MULH) && __SEGGER_RTL_CORE_HAS_MUL_MULH
  __SEGGER_RTL_U128 product;
#else
  __SEGGER_RTL_U64 x0, x1, ma, mb;
#endif

  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_isspecial_soft(x) || __SEGGER_RTL_float64_isspecial_soft(y))) {



    x = __SEGGER_RTL_float64_conditional_subnormal_flush_soft(x);
    y = __SEGGER_RTL_float64_conditional_subnormal_flush_soft(y);



    if (__SEGGER_RTL_float64_isnan_soft(x)) {
      return K_NAN_U64;
    } else if (__SEGGER_RTL_float64_isnan_soft(y)) {
      return K_NAN_U64;
    } else if (__SEGGER_RTL_float64_isinf_soft(x)) {



      if ((y << 1) == 0) {
        return K_NAN_U64;
      } else {
        return x ^ (y & __SEGGER_RTL_U64_C(0x8000000000000000));
      }
    } else if (__SEGGER_RTL_float64_isinf_soft(y)) {



      if ((x << 1) == 0) {
        return K_NAN_U64;
      } else {
        return y ^ (x & __SEGGER_RTL_U64_C(0x8000000000000000));
      }
    }



    if (x == __SEGGER_RTL_U64_C(0x8000000000000000)) {
      return (y & __SEGGER_RTL_U64_C(0x8000000000000000)) ^ __SEGGER_RTL_U64_C(0x8000000000000000);
    } else if (y == __SEGGER_RTL_U64_C(0x8000000000000000)) {
      return (x & __SEGGER_RTL_U64_C(0x8000000000000000)) ^ __SEGGER_RTL_U64_C(0x8000000000000000);
    } else if (x == __SEGGER_RTL_U64_C(0x0000000000000000)) {
      return y & __SEGGER_RTL_U64_C(0x8000000000000000);
    } else if (y == __SEGGER_RTL_U64_C(0x0000000000000000)) {
      return x & __SEGGER_RTL_U64_C(0x8000000000000000);
    }
  }



  xx = (__SEGGER_RTL_INT_LEAST16_T)(x >> FLOAT64_SIGNIFICAND_BITS);
  yx = (__SEGGER_RTL_INT_LEAST16_T)(y >> FLOAT64_SIGNIFICAND_BITS);
  rs = xx ^ yx;
  xx &= 0x7FF;
  yx &= 0x7FF;
  xx += yx - 0x3FF;



  x &= __SEGGER_RTL_U64_C(0x0FFFFFFFFFFFFF);
  x |= __SEGGER_RTL_U64_C(0x10000000000000);
  y &= __SEGGER_RTL_U64_C(0x0FFFFFFFFFFFFF);
  y |= __SEGGER_RTL_U64_C(0x10000000000000);



  x <<= 10;
  y <<= 11;

#if defined(__SEGGER_RTL_U128) && defined(__SEGGER_RTL_CORE_HAS_MUL_MULH) && __SEGGER_RTL_CORE_HAS_MUL_MULH



  product = (__SEGGER_RTL_U128)x * (__SEGGER_RTL_U128)y;



  x = product >> 64;
  x |= (product & __SEGGER_RTL_U64_C(0xFFFFFFFFFFFFFFFF)) != 0;

#else



  x1 = __SEGGER_RTL_UMULL_X(__SEGGER_RTL_U64_L(x), __SEGGER_RTL_U64_L(y));
  ma = __SEGGER_RTL_UMULL_X(__SEGGER_RTL_U64_L(x), __SEGGER_RTL_U64_H(y));
  mb = __SEGGER_RTL_UMULL_X(__SEGGER_RTL_U64_H(x), __SEGGER_RTL_U64_L(y));
  x0 = __SEGGER_RTL_UMULL_X(__SEGGER_RTL_U64_H(x), __SEGGER_RTL_U64_H(y));



  ma += mb;
  x0 += (ma >> 32);
  if (ma < mb) {
    x0 += __SEGGER_RTL_U64_C(0x100000000);
  }
  ma <<= 32;
  x1 += ma;
  if (x1 < ma) {
    ++x0;
  }



  if (x1) {
    x0 |= 1;
  }
  x = x0;

#endif



  ++xx;
  if ((x & __SEGGER_RTL_U64_C(0x4000000000000000)) == 0) {
    x <<= 1;
    --xx;
  }



  if (xx <= 0) {
    xx = 0;
    x = 0;
  }



  if ((x & 0x3FF) > 0x200) {
    x += __SEGGER_RTL_U64_C(0x200);
  } else if ((x & 0x3FF) == 0x200) {
    x = (x + 0x400) & ~0x7FF;
  }
  if (x & __SEGGER_RTL_U64_C(0x8000000000000000)) {
    x >>= 1;
    ++xx;
  }



  x >>= 10;



  x &= ~__SEGGER_RTL_U64_C(0x0010000000000000);



  if (xx >= 0x7FF) {
    xx = 0x7FF;
    x = 0;
  }



  xx |= rs & 0x800;



  return x | ((__SEGGER_RTL_U64)xx << FLOAT64_SIGNIFICAND_BITS);
}
# 4478 "./floatops.c"
static __SEGGER_RTL_INLINE double __SEGGER_RTL_float64_mul(double x, double y) {
#if __SEGGER_RTL_FP_HW >= 2 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return x * y;
#else
  return __SEGGER_RTL_BitcastToF64(
           __SEGGER_RTL_float64_mul_soft(
             __SEGGER_RTL_BitcastToU64(x),
             __SEGGER_RTL_BitcastToU64(y)));
#endif
}
# 4503 "./floatops.c"
static __SEGGER_RTL_INLINE __SEGGER_RTL_U32 __SEGGER_RTL_float32_div_soft(__SEGGER_RTL_U32 b, __SEGGER_RTL_U32 c) {
  unsigned bx;
  unsigned cx;
  unsigned rs;
  __SEGGER_RTL_U64 q;

  bx = (unsigned)(b >> 23);
  cx = (unsigned)(c >> 23);
  rs = (bx ^ cx) & 0x100;
  bx &= 0xFF;
  cx &= 0xFF;

  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_isspecial_soft(b) || __SEGGER_RTL_float32_isspecial_soft(c))) {
    if (__SEGGER_RTL_float32_isnan_soft(b)) {
      return K_NAN_U32;
    } else if (__SEGGER_RTL_float32_isnan_soft(c)) {
      return K_NAN_U32;
    } else if (cx == 0) {
      if (bx == 0) {
        return K_NAN_U32;
      } else {
        return K_INF_U32 | ((__SEGGER_RTL_U32)rs << 23);
      }
    } else if (bx == 0) {
      return ((__SEGGER_RTL_U32)rs << 23);
    } else if (__SEGGER_RTL_float32_isinf_soft(b)) {
      if (__SEGGER_RTL_float32_isinf_soft(c)) {
        return K_NAN_U32;
      } else {
        return b ^ (c & FLOAT32_SIGN_MASK);
      }
    } else if (__SEGGER_RTL_float32_isinf_soft(c)) {
      return (__SEGGER_RTL_U32)rs << 23;
    }
  }



  b &= __SEGGER_RTL_U32_C(0x7FFFFF);
  b |= __SEGGER_RTL_U32_C(0x800000);
  c &= __SEGGER_RTL_U32_C(0x7FFFFF);
  c |= __SEGGER_RTL_U32_C(0x800000);



  bx = bx-cx + 0x7F;



  if (sizeof(long) == 4) {
    q = __SEGGER_RTL_Div64by32_Moeller(b << 7, c << 8);
  } else {
    q = ((__SEGGER_RTL_U64)b << 31) / c;
  }



  if ((q & __SEGGER_RTL_U64_C(0x080000000)) == 0) {
    q <<= 1;
    --bx;
  }
  q += (q & 0x80) << 1;



  if ((__SEGGER_RTL_I16)bx <= 0) {
    bx = 0;
    q = 0;
  } else if ((__SEGGER_RTL_I16)bx >= 0xFF) {
    bx = 0xFF;
    q = 0;
  }



  bx |= rs;
  return (__SEGGER_RTL_U32)((q >> 8) & ~__SEGGER_RTL_U32_C(0x800000)) | ((__SEGGER_RTL_U32)bx << 23);
}
# 4596 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_div(float x, float y) {
#if __SEGGER_RTL_FP_HW >= 1 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return x / y;
#else
  return __SEGGER_RTL_BitcastToF32(
           __SEGGER_RTL_float32_div_soft(
             __SEGGER_RTL_BitcastToU32(x),
             __SEGGER_RTL_BitcastToU32(y)));
#endif
}
# 4622 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE __SEGGER_RTL_U64 __SEGGER_RTL_Div53by53(__SEGGER_RTL_U64 u, __SEGGER_RTL_U64 v, int *pExponent) {
  __SEGGER_RTL_U32 Q;
  __SEGGER_RTL_U32 R;
  __SEGGER_RTL_U64 S;






  if (u < v) {
    u <<= 1;
  } else {
    ++(*pExponent);
  }

  u <<= 10;
# 4656 "./floatops.c"
  __SEGGER_RTL_DIVMOD_U32(Q, R, __SEGGER_RTL_U64_H(u), __SEGGER_RTL_U64_H(v));
  u = __SEGGER_RTL_U64_MK(R, __SEGGER_RTL_U64_L(u)) - __SEGGER_RTL_UMULL_X(Q, __SEGGER_RTL_U64_L(v));
  if (u & __SEGGER_RTL_U64_C(0x8000000000000000)) {
    Q -= 1;
    u += v;
  }
  S = (__SEGGER_RTL_U64)Q << (10+32);





  u <<= 10;
  __SEGGER_RTL_DIVMOD_U32(Q, R, __SEGGER_RTL_U64_H(u), __SEGGER_RTL_U64_H(v));
  u = __SEGGER_RTL_U64_MK(R, __SEGGER_RTL_U64_L(u)) - __SEGGER_RTL_UMULL_X(Q, __SEGGER_RTL_U64_L(v));
  if (u & __SEGGER_RTL_U64_C(0x8000000000000000)) {
    Q -= 1;
    u += v;
  }
  S |= (__SEGGER_RTL_U64)Q << 32;

  u <<= 11;
  __SEGGER_RTL_DIVMOD_U32(Q, R, __SEGGER_RTL_U64_H(u), __SEGGER_RTL_U64_H(v));
  u = __SEGGER_RTL_U64_MK(R, __SEGGER_RTL_U64_L(u)) - __SEGGER_RTL_UMULL_X(Q, __SEGGER_RTL_U64_L(v));
  if (u & __SEGGER_RTL_U64_C(0x8000000000000000)) {
    Q -= 1;
    u += v;
  }
  S |= Q << 21;

  u <<= 11;
  __SEGGER_RTL_DIVMOD_U32(Q, R, __SEGGER_RTL_U64_H(u), __SEGGER_RTL_U64_H(v));
  u = __SEGGER_RTL_U64_MK(R, __SEGGER_RTL_U64_L(u)) - __SEGGER_RTL_UMULL_X(Q, __SEGGER_RTL_U64_L(v));
  if (u & __SEGGER_RTL_U64_C(0x8000000000000000)) {
    Q -= 1;
    u += v;
  }
  S |= Q << 10;

  u <<= 11;
  __SEGGER_RTL_DIVMOD_U32(Q, R, __SEGGER_RTL_U64_H(u), __SEGGER_RTL_U64_H(v));
  u = __SEGGER_RTL_U64_MK(R, __SEGGER_RTL_U64_L(u)) - __SEGGER_RTL_UMULL_X(Q, __SEGGER_RTL_U64_L(v));
  if (u & __SEGGER_RTL_U64_C(0x8000000000000000)) {
    Q -= 1;
  }

  return (S << 1) | Q;
}
# 4719 "./floatops.c"
static __SEGGER_RTL_INLINE __SEGGER_RTL_U64 __SEGGER_RTL_float64_div_soft(__SEGGER_RTL_U64 x, __SEGGER_RTL_U64 y) {
  __SEGGER_RTL_U64 sign;
  __SEGGER_RTL_U64 a;
  unsigned xx;
  unsigned yx;
  int ax;



  xx = FLOAT64_EXPONENT(x);
  yx = FLOAT64_EXPONENT(y);
  sign = (x ^ y) >> 63 << 63;

  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_isspecial_soft(x) || __SEGGER_RTL_float64_isspecial_soft(y))) {
    if (__SEGGER_RTL_float64_isnan_soft(x)) {
      return K_NAN_U64;
    } else if (__SEGGER_RTL_float64_isnan_soft(y)) {
      return K_NAN_U64;
    } else if (yx == 0) {
      if (xx == 0) {
        return K_NAN_U64;
      } else {
        return K_INF_U64 | sign;
      }
    } else if (xx == 0) {
      return sign;
    } else if (__SEGGER_RTL_float64_isinf_soft(x)) {
      if (__SEGGER_RTL_float64_isinf_soft(y)) {
        return K_NAN_U64;
      } else {
        return x ^ (y & __SEGGER_RTL_U64_C(0x8000000000000000));
      }
    } else if (__SEGGER_RTL_float64_isinf_soft(y)) {
      return sign;
    }
  }



  x &= FLOAT64_SIGNIFICAND_MASK;
  x |= FLOAT64_HIDDEN_MASK;
  y &= FLOAT64_SIGNIFICAND_MASK;
  y |= FLOAT64_HIDDEN_MASK;

  ax = xx - yx + 0x3FD;
  a = 0;



  if (sizeof(long) <= 4) {

#if (defined(__SEGGER_RTL_CORE_HAS_DIV) && __SEGGER_RTL_CORE_HAS_DIV) || (defined(__SEGGER_RTL_CORE_HAS_IDIV) && __SEGGER_RTL_CORE_HAS_IDIV)



    a = __SEGGER_RTL_Div53by53(x, y, &ax);

#else



    int i;

    for (i = 0; i < 55; ++i) {
      a <<= 1;
      if (x >= y) {
        x -= y;
        a |= 1;
      }
      x <<= 1;
    }

#endif

  } else {



    a = __SEGGER_RTL_Div128by64(x, y << 10);
  }



  if (a & __SEGGER_RTL_U64_C(0x0040000000000000)) {
    a >>= 1;
    ++ax;
  }



  if (a & 1) {
    ++a;
    if (a & __SEGGER_RTL_U64_C(0x0040000000000000)) {
      a >>= 1;
      ++ax;
    }
  }



  if (__SEGGER_RTL_UNLIKELY(ax < 0)) {



    return sign;

  } else if (__SEGGER_RTL_UNLIKELY(ax >= 0x7FE)) {



    return K_INF_U64 | sign;

  } else {



    return ((__SEGGER_RTL_I64)ax << FLOAT64_SIGNIFICAND_BITS) + (a>>1) + sign;
  }
}
# 4853 "./floatops.c"
static __SEGGER_RTL_INLINE double __SEGGER_RTL_float64_div(double x, double y) {
#if __SEGGER_RTL_FP_HW >= 2 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return x / y;
#else
  return __SEGGER_RTL_BitcastToF64(
           __SEGGER_RTL_float64_div_soft(
             __SEGGER_RTL_BitcastToU64(x),
             __SEGGER_RTL_BitcastToU64(y)));
#endif
}
# 4879 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE float __SEGGER_RTL_float32_fma_inline(float x, float y, float z) {
#if defined(__SEGGER_RTL_FLOAT32_FMA)
  return __SEGGER_RTL_FLOAT32_FMA(x, y, z);
#else
  return SEGGER_ADDF(SEGGER_MULF(x, y), z);
#endif
}
# 4902 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE double __SEGGER_RTL_float64_fma_inline(double x, double y, double z) {
#if defined(__SEGGER_RTL_FLOAT64_FMA)
  return __SEGGER_RTL_FLOAT64_FMA(x, y, z);
#else
  return SEGGER_ADD(SEGGER_MUL(x, y), z);
#endif
}
# 4923 "./floatops.c"
static __SEGGER_RTL_INLINE __SEGGER_RTL_I32 __SEGGER_RTL_float_to_int32_soft(__SEGGER_RTL_U32 x) {
  unsigned bs;
  unsigned bx;



  bs = (unsigned)(x >> 23);
  bx = bs & 0xFF;



  if (bx < 0x7F) {
    return 0;
  } else if (bx >= 0x7F+31) {
    if ((x << 1) > __SEGGER_RTL_U32_C(0xFF000000)) {
      return __SEGGER_RTL_I32_C(0x7FFFFFFF);
    } else if (bs >= 0x100) {
      return __SEGGER_RTL_I32_C(0x80000000);
    } else {
      return __SEGGER_RTL_I32_C(0x7FFFFFFF);
    }
  }



  x &= __SEGGER_RTL_U32_C(0x7FFFFF);
  x |= __SEGGER_RTL_U32_C(0x800000);



  if (bx <= 0x7F+23) {
    x >>= (0x7F+23) - bx;
  } else {
    x <<= (bx-(0x7F+23));
  }



  if (bs >= 0x100) {
    x = 0u - x;
  }

  return x;
}
# 4981 "./floatops.c"
static __SEGGER_RTL_INLINE __SEGGER_RTL_I32 __SEGGER_RTL_float_to_int32(float x) {
#if __SEGGER_RTL_FP_HW >= 1 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return (__SEGGER_RTL_I32)x;
#else
  return __SEGGER_RTL_float_to_int32_soft(__SEGGER_RTL_BitcastToU32(x));
#endif
}
# 5002 "./floatops.c"
static __SEGGER_RTL_INLINE __SEGGER_RTL_I32 __SEGGER_RTL_double_to_int32_soft(__SEGGER_RTL_U64 x) {
  unsigned xs;
  unsigned xx;



  xs = (unsigned)(x >> FLOAT64_SIGNIFICAND_BITS);
  xx = xs & 0x7FF;



  if (xx < 0x3FF) {
    return 0;
  } else if (xx >= 0x3FF+31) {
    if ((x << 1) > __SEGGER_RTL_U64_C(0xFFE0000000000000)) {
      return (__SEGGER_RTL_I32)0x7FFFFFFF;
    } else if (xs >= 0x800) {
      return (__SEGGER_RTL_I32)0x80000000;
    } else {
      return (__SEGGER_RTL_I32)0x7FFFFFFF;
    }
  }



  x &= FLOAT64_SIGNIFICAND_MASK;
  x |= FLOAT64_HIDDEN_MASK;



  x >>= (0x3FF + FLOAT64_SIGNIFICAND_BITS) - xx;


  if (xs >= 0x800) {
    x = 0u - x;
  }

  return (__SEGGER_RTL_I32)x;
}
# 5055 "./floatops.c"
static __SEGGER_RTL_INLINE __SEGGER_RTL_I32 __SEGGER_RTL_double_to_int32(double x) {
#if __SEGGER_RTL_FP_HW >= 2 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return (__SEGGER_RTL_I32)x;
#else
  return __SEGGER_RTL_double_to_int32_soft(__SEGGER_RTL_BitcastToU64(x));
#endif
}
# 5076 "./floatops.c"
static __SEGGER_RTL_INLINE __SEGGER_RTL_U32 __SEGGER_RTL_float_to_uint32_soft(__SEGGER_RTL_U32 x) {
  unsigned xs;
  unsigned xx;



  xs = (unsigned)(x >> 23);
  xx = xs & 0xFF;



  if (xx < 0x7F || x >= __SEGGER_RTL_U32_C(0x80000000)) {
    return 0;
  } else if (xx >= 0x7F+32) {
    return __SEGGER_RTL_U32_C(0xFFFFFFFF);
  }



  x &= __SEGGER_RTL_U32_C(0x7FFFFF);
  x |= __SEGGER_RTL_U32_C(0x800000);



  if (xx <= 0x7F+23) {
    x >>= (0x7F+23) - xx;
  } else {
    x <<= xx - (0x7F+23);
  }



  return (__SEGGER_RTL_U32)x;
}
# 5124 "./floatops.c"
static __SEGGER_RTL_INLINE __SEGGER_RTL_U32 __SEGGER_RTL_float_to_uint32(float x) {
#if __SEGGER_RTL_FP_HW >= 1 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return (__SEGGER_RTL_U32)x;
#else
  return __SEGGER_RTL_float_to_uint32_soft(__SEGGER_RTL_BitcastToU32(x));
#endif
}
# 5145 "./floatops.c"
static __SEGGER_RTL_INLINE __SEGGER_RTL_U32 __SEGGER_RTL_double_to_uint32_soft(__SEGGER_RTL_U64 x) {
  unsigned xs;
  unsigned xx;



  xs = (unsigned)(x >> FLOAT64_SIGNIFICAND_BITS);
  xx = xs & 0x7FF;



  if (xx < 0x3FF) {
    return 0;
  } else if (xx >= 0x3FF+32) {
    if (xs >= 0x800) {
      return 0;
    } else {
      return __SEGGER_RTL_U32_C(0xFFFFFFFF);
    }
  } else if (xs >= 0x800) {
    return 0;
  }



  x &= FLOAT64_SIGNIFICAND_MASK;
  x |= FLOAT64_HIDDEN_MASK;



  x >>= (0x3FF + FLOAT64_SIGNIFICAND_BITS) - xx;


  if (xs >= 0x800) {
    return __SEGGER_RTL_U32_C(0) - (__SEGGER_RTL_U32)x;
  } else {
    return (__SEGGER_RTL_U32)x;
  }
}
# 5198 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE __SEGGER_RTL_U32 __SEGGER_RTL_double_to_uint32(double x) {
#if __SEGGER_RTL_FP_HW >= 1 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return (__SEGGER_RTL_U32)x;
#else
  return __SEGGER_RTL_double_to_uint32_soft(__SEGGER_RTL_BitcastToU64(x));
#endif
}
# 5223 "./floatops.c"
static __SEGGER_RTL_INLINE __SEGGER_RTL_I64 __SEGGER_RTL_float_to_int64_soft(__SEGGER_RTL_U32 x) {
  unsigned xx;
  __SEGGER_RTL_U64 xl;



  xx = (x >> 23) & 0xFF;



  if (xx < 0x7F) {
    return 0;
  } else if (xx >= 0x7F+63) {
    if ((x << 1) > __SEGGER_RTL_U32_C(0xFF000000)) {
      return __SEGGER_RTL_I64_C(0x7FFFFFFFFFFFFFFF);
    } else if (x & __SEGGER_RTL_U32_C(0x80000000)) {
      return __SEGGER_RTL_I64_C(0x8000000000000000);
    } else {
      return __SEGGER_RTL_I64_C(0x7FFFFFFFFFFFFFFF);
    }
  }



  xl = x & FLOAT32_SIGNIFICAND_MASK;
  xl |= FLOAT32_HIDDEN_MASK;



  if (xx <= 0x7F+23) {
    xl >>= (0x7F+23) - xx;
  } else {
    xl <<= xx - (0x7F+23);
  }



  if (x & __SEGGER_RTL_U32_C(0x80000000)) {
    xl = 0u - xl;
  }

  return (__SEGGER_RTL_I64)xl;
}
# 5284 "./floatops.c"
static __SEGGER_RTL_INLINE __SEGGER_RTL_I64 __SEGGER_RTL_float_to_int64(float x) {
#if __SEGGER_RTL_FP_HW >= 1 && (__SEGGER_RTL_SIZEOF_INT == 8) && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return (__SEGGER_RTL_I64)x;
#else
  return __SEGGER_RTL_float_to_int64_soft(__SEGGER_RTL_BitcastToU32(x));
#endif
}
# 5305 "./floatops.c"
static __SEGGER_RTL_U64 __SEGGER_RTL_float_to_uint64_soft(__SEGGER_RTL_U32 x) {
  unsigned xx;
  __SEGGER_RTL_U64 xl;



  xx = (unsigned)(x >> 23) & 0xFF;



  if (xx < 0x7F || x >= __SEGGER_RTL_U32_C(0x80000000)) {
    return 0;
  } else if (xx >= 0x7F+64) {
    return ~__SEGGER_RTL_U64_C(0);
  }



  xl = x & FLOAT32_SIGNIFICAND_MASK;
  xl |= FLOAT32_HIDDEN_MASK;



  if (xx <= 0x7F+23) {
    xl >>= (0x7F+23) - xx;
  } else {
    xl <<= (xx-(0x7F+23));
  }

  return (__SEGGER_RTL_U64)xl;
}
# 5350 "./floatops.c"
static __SEGGER_RTL_INLINE __SEGGER_RTL_U64 __SEGGER_RTL_float_to_uint64(float x) {
#if __SEGGER_RTL_FP_HW >= 1 && (__SEGGER_RTL_SIZEOF_INT == 8) && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return (__SEGGER_RTL_U64)x;
#else
  return __SEGGER_RTL_float_to_uint64_soft(__SEGGER_RTL_BitcastToU32(x));
#endif
}
# 5374 "./floatops.c"
static __SEGGER_RTL_INLINE __SEGGER_RTL_I64 __SEGGER_RTL_double_to_int64_soft(__SEGGER_RTL_U64 x) {
  unsigned xs;
  unsigned xx;



  xs = (unsigned)(x >> FLOAT64_SIGNIFICAND_BITS);
  xx = xs & 0x7FF;


  if (xx < 0x3FF) {
    return 0;
  } else if (xx >= 0x3FF+63) {
    if ((x << 1) > __SEGGER_RTL_U64_C(0xFFE0000000000000)) {
      return __SEGGER_RTL_I64_C(0x7FFFFFFFFFFFFFFF);
    } else if (x & __SEGGER_RTL_U64_C(0x8000000000000000)) {
      return __SEGGER_RTL_I64_C(0x8000000000000000);
    } else {
      return __SEGGER_RTL_I64_C(0x7FFFFFFFFFFFFFFF);
    }
  }



  x &= FLOAT64_SIGNIFICAND_MASK;
  x |= FLOAT64_HIDDEN_MASK;


  if (xx <= 0x3FF + FLOAT64_SIGNIFICAND_BITS) {
    x >>= (0x3FF + FLOAT64_SIGNIFICAND_BITS) - xx;
  } else {
    x <<= xx - (0x3FF + FLOAT64_SIGNIFICAND_BITS);
  }



  if (xs >= 0x800) {
    x = 0u - x;
  }

  return x;
}
# 5433 "./floatops.c"
static __SEGGER_RTL_INLINE __SEGGER_RTL_I64 __SEGGER_RTL_double_to_int64(double x) {
#if __SEGGER_RTL_FP_HW >= 2 && (__SEGGER_RTL_SIZEOF_INT == 8) && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return (__SEGGER_RTL_I64)x;
#else
  return __SEGGER_RTL_double_to_int64_soft(__SEGGER_RTL_BitcastToU64(x));
#endif
}
# 5454 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE __SEGGER_RTL_U64 __SEGGER_RTL_double_to_uint64_soft(__SEGGER_RTL_U64 x) {
  unsigned xs;
  unsigned xx;



  xs = (unsigned)(x >> FLOAT64_SIGNIFICAND_BITS);
  xx = xs & 0x7FF;



  if (xx < 0x3FF) {
    return 0;
  } else if (xx > 0x3FF+63) {
    if (xs >= 0x800) {
      return 0;
    } else {
      return __SEGGER_RTL_U64_C(0xFFFFFFFFFFFFFFFF);
    }
  } else if (xs >= 0x800) {
    return 0;
  }



  x &= FLOAT64_SIGNIFICAND_MASK;
  x |= FLOAT64_HIDDEN_MASK;


  if (xx <= 0x3FF + FLOAT64_SIGNIFICAND_BITS) {
    x >>= (0x3FF + FLOAT64_SIGNIFICAND_BITS) - xx;
  } else {
    x <<= xx - (0x3FF + FLOAT64_SIGNIFICAND_BITS);
  }

  return x;
}
# 5508 "./floatops.c"
static __SEGGER_RTL_INLINE __SEGGER_RTL_U64 __SEGGER_RTL_double_to_uint64(double x) {
#if __SEGGER_RTL_FP_HW >= 2 && (__SEGGER_RTL_SIZEOF_INT == 8) && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return (__SEGGER_RTL_U64)x;
#else
  return __SEGGER_RTL_double_to_uint64_soft(__SEGGER_RTL_BitcastToU64(x));
#endif
}
# 5529 "./floatops.c"
static __SEGGER_RTL_INLINE __SEGGER_RTL_U32 __SEGGER_RTL_int32_to_float_soft(__SEGGER_RTL_U32 x) {
  __SEGGER_RTL_UINT_LEAST8_T sign;
  __SEGGER_RTL_UINT_LEAST16_T exp;
  __SEGGER_RTL_U32 frac;



  if (x == 0) {
    return 0;
  }



  if (x & FLOAT32_SIGN_MASK) {
    x = 0u - x;
    sign = 1;
  } else {
    sign = 0;
  }



  if (x < 0x1000000) {



    exp = __SEGGER_RTL_CLZ_U32(x) - 8;
    x <<= exp;
    exp = 0x7F + 23 - 1 - exp;
  } else {



    exp = __SEGGER_RTL_CLZ_U32(x);
    x <<= exp;



    exp = 0x7F + 31 - 1 - exp;
    frac = x & 0xFF;
    x >>= 8;
    if (frac >= 0x80) {
      ++x;
      if (frac == 0x80) {
        x &= ~__SEGGER_RTL_U32_C(1);
      }
      if (x > __SEGGER_RTL_U32_C(0xFFFFFF)) {
        x >>= 1;
        ++exp;
      }
    }
  }



  if (sign) {
    x |= __SEGGER_RTL_U32_C(0x80000000);
  }



  return x + ((__SEGGER_RTL_U32)exp << 23);
}
# 5606 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_int32_to_float(__SEGGER_RTL_I32 x) {
#if __SEGGER_RTL_FP_HW >= 1 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return (float)x;
#else
  return __SEGGER_RTL_BitcastToF32(__SEGGER_RTL_int32_to_float_soft(x));
#endif
}
# 5627 "./floatops.c"
static __SEGGER_RTL_INLINE __SEGGER_RTL_U32 __SEGGER_RTL_uint32_to_float_soft(__SEGGER_RTL_U32 x) {
  __SEGGER_RTL_UINT_LEAST16_T exp;
  __SEGGER_RTL_UINT_LEAST8_T frac;



  if (x == 0) {
    return x;
  }



  if (x < 0x1000000) {



    exp = __SEGGER_RTL_CLZ_U32(x) - 8;
    x <<= exp;
    exp = 0x7F + 23 - 1 - exp;

  } else {



    exp = __SEGGER_RTL_CLZ_U32(x);
    x <<= exp;



    frac = x & 0xFF;
    exp = 0x7F + 31 - 1 - exp;
    x >>= 8;
    if (frac >= 0x80) {
      ++x;
      if (frac == 0x80) {
        x &= ~__SEGGER_RTL_U32_C(1);
      }
    }
  }



  return x + ((__SEGGER_RTL_U32)exp << 23);
}
# 5685 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_uint32_to_float(__SEGGER_RTL_U32 x) {
#if __SEGGER_RTL_FP_HW >= 1 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return (float)x;
#else
  return __SEGGER_RTL_BitcastToF32(__SEGGER_RTL_uint32_to_float_soft(x));
#endif
}
# 5706 "./floatops.c"
static __SEGGER_RTL_INLINE __SEGGER_RTL_U64 __SEGGER_RTL_int32_to_double_soft(__SEGGER_RTL_U32 x) {
  __SEGGER_RTL_UINT_LEAST8_T sign;
  __SEGGER_RTL_U64 f;
  int exp;



  if (x == 0) {
    return 0;
  }



  if (x & FLOAT32_SIGN_MASK) {
    f = ((__SEGGER_RTL_U64)(0u - x)) << 21;
    sign = 1;
  } else {
    f = ((__SEGGER_RTL_U64)x) << 21;
    sign = 0;
  }



  exp = __SEGGER_RTL_float64_normalize(&f, 0x3FF + 31);



  f &= ~FLOAT64_HIDDEN_MASK;



  if (sign) {
    f |= FLOAT64_SIGN_MASK;
  }



  return f | (((__SEGGER_RTL_U64)exp) << FLOAT64_SIGNIFICAND_BITS);
}
# 5759 "./floatops.c"
static __SEGGER_RTL_INLINE double __SEGGER_RTL_int32_to_double(__SEGGER_RTL_I32 x) {
#if __SEGGER_RTL_FP_HW >= 2 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return (double)x;
#else
  return __SEGGER_RTL_BitcastToF64(__SEGGER_RTL_int32_to_double_soft(x));
#endif
}
# 5780 "./floatops.c"
static __SEGGER_RTL_INLINE __SEGGER_RTL_U64 __SEGGER_RTL_uint32_to_double_soft(__SEGGER_RTL_U32 x) {
  __SEGGER_RTL_UINT_LEAST16_T exp;
  __SEGGER_RTL_U64 f;



  if (__SEGGER_RTL_UNLIKELY(x == 0)) {
    return 0;
  }



  f = (__SEGGER_RTL_U64)x << 21;
  exp = __SEGGER_RTL_float64_normalize(&f, 0x3FF + 31 - 1);



  return f + ((__SEGGER_RTL_U64)exp << FLOAT64_SIGNIFICAND_BITS);
}
# 5813 "./floatops.c"
static __SEGGER_RTL_INLINE double __SEGGER_RTL_uint32_to_double(__SEGGER_RTL_U32 x) {
#if __SEGGER_RTL_FP_HW >= 2 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return (double)x;
#else
  return __SEGGER_RTL_BitcastToF64(__SEGGER_RTL_uint32_to_double_soft(x));
#endif
}
# 5834 "./floatops.c"
static __SEGGER_RTL_INLINE __SEGGER_RTL_U32 __SEGGER_RTL_int64_to_float_soft(__SEGGER_RTL_U64 x) {
  __SEGGER_RTL_UINT_LEAST8_T sign;
  __SEGGER_RTL_UINT_LEAST16_T exp;
  __SEGGER_RTL_U64 frac;



  if (x == 0) {
    return 0;
  }



  if (x & __SEGGER_RTL_U64_C(0x8000000000000000)) {
    x = 0u - x;
    sign = 1;
  } else {
    sign = 0;
  }



  if (x < __SEGGER_RTL_U64_C(0x1000000)) {



    exp = __SEGGER_RTL_CLZ_U32(__SEGGER_RTL_U64_L(x)) - 8;
    x <<= exp;
    exp = 0x7F + 23 - 1 - exp;

  } else {



    exp = __SEGGER_RTL_CLZ_U64(x);
    x <<= exp;



    frac = x << 23;
    if (frac & (0x8000000000000000)) {
      frac <<= 1;
      frac |= 1;
    } else {
      frac <<= 1;
    }
    exp = 0x7F + 63 - 1 - exp;
    x >>= 40;



    if (frac >= 0x8000000000000000) {
      ++x;
      if (frac == __SEGGER_RTL_U64_C(0x8000000000000000)) {
        x &= ~__SEGGER_RTL_U64_C(1);
      }
    }
  }



  if (sign) {
    x |= FLOAT32_SIGN_MASK;
  }



  return (__SEGGER_RTL_U32)x + (((__SEGGER_RTL_U32)exp)<<23);
}
# 5917 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_int64_to_float(__SEGGER_RTL_I64 x) {
#if __SEGGER_RTL_FP_HW >= 1 && (__SEGGER_RTL_SIZEOF_INT == 8) && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return (double)x;
#else
  return __SEGGER_RTL_BitcastToF32(__SEGGER_RTL_int64_to_float_soft(x));
#endif
}
# 5938 "./floatops.c"
static __SEGGER_RTL_INLINE __SEGGER_RTL_U64 __SEGGER_RTL_int64_to_double_soft(__SEGGER_RTL_U64 x) {
  __SEGGER_RTL_UINT_LEAST16_T exp;
  __SEGGER_RTL_UINT_LEAST8_T sign;
  __SEGGER_RTL_U32 frac;



  if (x == 0) {
    return 0;
  }



  if (x & FLOAT64_SIGN_MASK) {
    x = 0u - x;
    sign = 1;
  } else {
    sign = 0;
  }



  if (x < __SEGGER_RTL_U64_C(0x20000000000000)) {



    exp = __SEGGER_RTL_CLZ_U64(x) - 11;
    x <<= exp;
    exp = 0x3FF - 1 + FLOAT64_SIGNIFICAND_BITS - exp;

  } else {



    exp = __SEGGER_RTL_CLZ_U64(x);
    x <<= exp;



    frac = (__SEGGER_RTL_U32)x << (FLOAT64_SIGNIFICAND_BITS - 32);
    if (frac & __SEGGER_RTL_U32_C(0x80000000)) {
      frac <<= 1;
      frac |= 1;
    } else {
      frac <<= 1;
    }
    exp = 0x3FF + 63 - 1 - exp;
    x >>= 11;



    if (frac >= __SEGGER_RTL_U32_C(0x80000000)) {
      ++x;
      if (frac == __SEGGER_RTL_U32_C(0x80000000)) {
        x &= ~__SEGGER_RTL_U64_C(1);
      }
    }
  }



  if (sign) {
    x |= FLOAT64_SIGN_MASK;
  }



  return x + ((__SEGGER_RTL_U64)exp << FLOAT64_SIGNIFICAND_BITS);
}
# 6021 "./floatops.c"
static __SEGGER_RTL_INLINE double __SEGGER_RTL_int64_to_double(__SEGGER_RTL_I64 x) {
#if __SEGGER_RTL_FP_HW >= 2 && (__SEGGER_RTL_SIZEOF_INT == 8) && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return (double)x;
#else
  return __SEGGER_RTL_BitcastToF64(__SEGGER_RTL_int64_to_double_soft(x));
#endif
}
# 6042 "./floatops.c"
static __SEGGER_RTL_INLINE __SEGGER_RTL_U32 __SEGGER_RTL_uint64_to_float_soft(__SEGGER_RTL_U64 x) {
  __SEGGER_RTL_UINT_LEAST16_T exp;
  __SEGGER_RTL_U64 frac;



  if (x == 0) {
    return 0;
  }



  if (x < __SEGGER_RTL_U64_C(0x1000000)) {



    exp = __SEGGER_RTL_CLZ_U32(__SEGGER_RTL_U64_L(x)) - 8;
    x <<= exp;
    exp = 0x7F + 23 - 1 - exp;

  } else {



    exp = __SEGGER_RTL_CLZ_U64(x);
    x <<= exp;



    frac = x << 23;
    if (frac & __SEGGER_RTL_U64_C(0x8000000000000000)) {
      frac <<= 1;
      frac |= 1;
    } else {
      frac <<= 1;
    }
    exp = 0x7F + 63 - 1 - exp;
    x >>= 40;



    if (frac >= __SEGGER_RTL_U64_C(0x8000000000000000)) {
      ++x;
      if (frac == __SEGGER_RTL_U64_C(0x8000000000000000)) {
        x &= ~__SEGGER_RTL_U64_C(1);
      }
    }
  }



  return (__SEGGER_RTL_U32)x + ((__SEGGER_RTL_U32)exp << 23);
}
# 6109 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_uint64_to_float(__SEGGER_RTL_U64 x) {
#if __SEGGER_RTL_FP_HW >= 2 && (__SEGGER_RTL_SIZEOF_INT == 8) && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return (float)x;
#else
  return __SEGGER_RTL_BitcastToF32(__SEGGER_RTL_uint64_to_float_soft(x));
#endif
}
# 6130 "./floatops.c"
static __SEGGER_RTL_INLINE __SEGGER_RTL_U64 __SEGGER_RTL_uint64_to_double_soft(__SEGGER_RTL_U64 x) {
  __SEGGER_RTL_UINT_LEAST16_T exp;
  __SEGGER_RTL_U32 frac;



  if (x == 0) {
    return 0;
  }



  if (x < __SEGGER_RTL_U64_C(0x20000000000000)) {



    exp = __SEGGER_RTL_CLZ_U64(x) - 11;
    x <<= exp;
    exp = 0x3FF - 1 + FLOAT64_SIGNIFICAND_BITS - exp;
  } else {



    exp = __SEGGER_RTL_CLZ_U64(x);
    x <<= exp;



    frac = (__SEGGER_RTL_U32)x << (FLOAT64_SIGNIFICAND_BITS - 32);
    if (frac & __SEGGER_RTL_U32_C(0x80000000)) {
      frac <<= 1;
      frac |= 1;
    } else {
      frac <<= 1;
    }
    exp = 0x3FF + 63 - 1 - exp;
    x >>= 11;



    if (frac >= __SEGGER_RTL_U32_C(0x80000000)) {
      ++x;
      if (frac == __SEGGER_RTL_U32_C(0x80000000)) {
        x &= ~__SEGGER_RTL_U64_C(1);
      }
    }
  }



  return x + ((__SEGGER_RTL_U64)exp << FLOAT64_SIGNIFICAND_BITS);
}
# 6196 "./floatops.c"
static __SEGGER_RTL_INLINE double __SEGGER_RTL_uint64_to_double(__SEGGER_RTL_U64 x) {
#if __SEGGER_RTL_FP_HW >= 2 && (__SEGGER_RTL_SIZEOF_INT == 8) && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return (double)x;
#else
  return __SEGGER_RTL_BitcastToF64(__SEGGER_RTL_uint64_to_double_soft(x));
#endif
}
# 6217 "./floatops.c"
static __SEGGER_RTL_U64 __SEGGER_RTL_float_to_double_soft(__SEGGER_RTL_U32 x) {
  __SEGGER_RTL_U32 xs;
  __SEGGER_RTL_U64 v;
  unsigned xx;



  xs = x & FLOAT32_SIGN_MASK;
  xx = (x >> 23) & 0xFF;



  if (xx == 0) {
    return (__SEGGER_RTL_U64)xs << 32;
  } else if (xx == 0xFF) {



    v = (__SEGGER_RTL_U64_C(0x7000000000000000) + ((__SEGGER_RTL_U64)x << 33 >> 4)) | ((__SEGGER_RTL_U64)xs << 32);
    if (x << 9) {
      v |= __SEGGER_RTL_U64_C(0x0008000000000000);
    }
    return v;
  }



  if (xs) {
    xx |= __SEGGER_RTL_U32_C(0x800);
  }



  return ((__SEGGER_RTL_U64)(xx + (0x3FF - 0x7F)) << FLOAT64_SIGNIFICAND_BITS) |
         (__SEGGER_RTL_U64)(x & __SEGGER_RTL_U32_C(0x7FFFFF)) << (FLOAT64_SIGNIFICAND_BITS-FLOAT32_SIGNIFICAND_BITS);
}
# 6267 "./floatops.c"
static double __SEGGER_RTL_float_to_double(float x) {
#if __SEGGER_RTL_FP_HW >= 2 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return (double)x;
#else
  return __SEGGER_RTL_BitcastToF64(__SEGGER_RTL_float_to_double_soft(__SEGGER_RTL_BitcastToU32(x)));
#endif
}
# 6288 "./floatops.c"
static __SEGGER_RTL_INLINE __SEGGER_RTL_U32 __SEGGER_RTL_double_to_float_soft(__SEGGER_RTL_U64 x) {
  __SEGGER_RTL_U32 frac;
  unsigned xs;
  int xx;
  __SEGGER_RTL_U32 r;



  xs = (unsigned)(x >> FLOAT64_SIGNIFICAND_BITS);
  xx = xs & 0x7FF;



  xx -= (0x3FF - 0x7F);



  if (xx <= 0) {
    return (__SEGGER_RTL_U32)(x >> 32) & __SEGGER_RTL_U32_C(0x80000000);
  } else if (xx >= 0xFF) {
    if (__SEGGER_RTL_float64_isnan_soft(x)) {
      r = (__SEGGER_RTL_U32)(x << 4 >> 33);
      r |= __SEGGER_RTL_U32_C(0x00400000);
      if (xs >= 0x800) {
        r |= FLOAT32_SIGN_MASK;
      }
    } else {
      r = K_INF_U32 | (__SEGGER_RTL_U64_H(x) & FLOAT32_SIGN_MASK);
    }
    return r;
  }



  r = (__SEGGER_RTL_U32)(x >> 29) & __SEGGER_RTL_I32_C(0x7FFFFF);
  frac = (__SEGGER_RTL_U32)x << 3;
  if (frac >= __SEGGER_RTL_U32_C(0x80000000)) {
    ++r;
    if (frac == __SEGGER_RTL_U32_C(0x80000000)) {
      r &= ~__SEGGER_RTL_U32_C(1);
    }
  }



  if (xs >= 0x800) {
    xx |= 0x100;
  }



  return r + ((__SEGGER_RTL_U32)xx << 23);
}
# 6355 "./floatops.c"
static __SEGGER_RTL_INLINE long double __SEGGER_RTL_double_to_ldouble(double x) {

  if (sizeof(double) == sizeof(long double)) {
    return x;
  } else {
    SEGGER_RTL_float128_t v;
    __SEGGER_RTL_U64 u;
    int exponent;

    u = __SEGGER_RTL_BitcastToU64(x);
    exponent = FLOAT64_EXPONENT(u);



    if (exponent == 0) {
      v.part.hi = u & FLOAT64_SIGN_MASK;
      v.part.lo = 0;
    } else {



      if (exponent == FLOAT64_EXPONENT_INF) {
        exponent = FLOAT128_EXPONENT_INF;
      } else {
        exponent -= FLOAT64_EXPONENT_BIAS;
        exponent += FLOAT128_EXPONENT_BIAS;
      }

      v.part.hi = u & FLOAT64_SIGN_MASK;
      v.part.hi |= (__SEGGER_RTL_U64)exponent << (FLOAT128_SIGNIFICAND_BITS - 64);
      v.part.hi |= (u & FLOAT64_SIGNIFICAND_MASK) >> (FLOAT64_SIGNIFICAND_BITS - (FLOAT128_SIGNIFICAND_BITS - 64));
      v.part.lo = (u & FLOAT64_SIGNIFICAND_MASK) << (64 - (FLOAT64_SIGNIFICAND_BITS - (FLOAT128_SIGNIFICAND_BITS - 64)));
    }

    return v.f;
  }
}
# 6406 "./floatops.c"
static __SEGGER_RTL_INLINE double __SEGGER_RTL_ldouble_to_double(long double x) {

  if (sizeof(double) == sizeof(long double)) {
    return x;
  } else {
    SEGGER_RTL_float128_t v;
    __SEGGER_RTL_U64 u;
    int exponent;

    v.f = x;
    exponent = FLOAT128_EXPONENT_HI(v.part.hi);
    exponent -= FLOAT128_EXPONENT_BIAS;
    exponent += FLOAT64_EXPONENT_BIAS;

    if (exponent <= 0) {



      u = v.part.hi;
      u &= FLOAT128_SIGN_HI_MASK;
    } else {
      if (exponent == FLOAT128_EXPONENT_INF - FLOAT128_EXPONENT_BIAS + FLOAT64_EXPONENT_BIAS) {



        exponent = FLOAT64_EXPONENT_INF;

      } else if (exponent > FLOAT64_EXPONENT_INF) {



        exponent = FLOAT64_EXPONENT_INF;
        v.part.hi = 0;
        v.part.lo = 0;
      }

      u = v.part.hi;
      u &= FLOAT128_SIGN_HI_MASK;
      u |= (__SEGGER_RTL_U64)exponent << FLOAT64_SIGNIFICAND_BITS;
      u |= (v.part.hi & FLOAT128_SIGNIFICAND_HI_MASK) << (FLOAT64_SIGNIFICAND_BITS - (FLOAT128_SIGNIFICAND_BITS - 64));
      u |= v.part.lo >> (FLOAT128_SIGNIFICAND_BITS - FLOAT64_SIGNIFICAND_BITS);
    }

    return __SEGGER_RTL_BitcastToF64(u);
  }
}
# 6466 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE __SEGGER_RTL_U16 __SEGGER_RTL_float_to_half_ieee_soft(__SEGGER_RTL_U32 x) {
  __SEGGER_RTL_UINT_LEAST16_T half;
  __SEGGER_RTL_U32 sign;
  int shift;



  sign = x & FLOAT32_SIGN_MASK;
  x = x & ~FLOAT32_SIGN_MASK;

  if (x >= K_INF_U32) {



    half = FLOAT16_EXPONENT_INF << FLOAT16_SIGNIFICAND_BITS;
    if (x > K_INF_U32) {
      half |= (x & FLOAT32_SIGNIFICAND_MASK) >> (FLOAT32_SIGNIFICAND_BITS - FLOAT16_SIGNIFICAND_BITS);
    }
  } else if (x - FLOAT32_MK(FLOAT32_EXPONENT_BIAS - FLOAT16_EXPONENT_BIAS + 1, 0, 0) < x - FLOAT32_MK(FLOAT32_EXPONENT_BIAS - FLOAT16_EXPONENT_BIAS + FLOAT16_EXPONENT_INF, 0, 0)) {



    half = x >> (FLOAT32_SIGNIFICAND_BITS - FLOAT16_SIGNIFICAND_BITS);
    half -= (__SEGGER_RTL_UINT_LEAST16_T)((FLOAT32_EXPONENT_BIAS - FLOAT16_EXPONENT_BIAS) << FLOAT16_SIGNIFICAND_BITS);



    x <<= (FLOAT32_TOTAL_BITS - FLOAT32_SIGNIFICAND_BITS + FLOAT16_SIGNIFICAND_BITS);
    if (x >= __SEGGER_RTL_U32_C(0x80000000)) {
      half += 1;
      if (x == __SEGGER_RTL_U32_C(0x80000000)) {
        half &= ~1;
      }
    }
  } else {



    shift = FLOAT32_EXPONENT_BIAS - FLOAT16_EXPONENT_BIAS - FLOAT32_EXPONENT(x) + 1;
    if (shift > FLOAT32_SIGNIFICAND_BITS) {



      half = 0;
    } else {



      x &= FLOAT32_SIGNIFICAND_MASK;
      x |= FLOAT32_HIDDEN_MASK;
      x = (x >> shift) | ((x << (FLOAT32_TOTAL_BITS - shift)) != 0);
      half = x >> (FLOAT32_SIGNIFICAND_BITS - FLOAT16_SIGNIFICAND_BITS);



      x <<= (FLOAT32_TOTAL_BITS - FLOAT32_SIGNIFICAND_BITS + FLOAT16_SIGNIFICAND_BITS);
      if (x >= __SEGGER_RTL_U32_C(0x80000000)) {
        half += 1;
        if (x == __SEGGER_RTL_U32_C(0x80000000)) {
          half &= ~1;
        }
      }
    }
  }



  return half | (sign >> (FLOAT32_TOTAL_BITS - FLOAT16_TOTAL_BITS));
}
# 6549 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE __SEGGER_RTL_U16 __SEGGER_RTL_float_to_half_ieee(float x) {
  return __SEGGER_RTL_float_to_half_ieee_soft(__SEGGER_RTL_BitcastToU32(x));
}
# 6566 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE __SEGGER_RTL_U16 __SEGGER_RTL_double_to_half_ieee_soft(__SEGGER_RTL_U64 x) {
  __SEGGER_RTL_UINT_LEAST16_T half;
  __SEGGER_RTL_U64 sign;
  int shift;



  sign = x & FLOAT64_SIGN_MASK;
  x = x & ~FLOAT64_SIGN_MASK;

  if (x >= K_INF_U64) {



    half = FLOAT16_EXPONENT_INF << FLOAT16_SIGNIFICAND_BITS;
    if (x > K_INF_U64) {
      half |= (x & FLOAT64_SIGNIFICAND_MASK) >> (FLOAT64_SIGNIFICAND_BITS - FLOAT16_SIGNIFICAND_BITS);
    }
  } else if (x - FLOAT64_MK(FLOAT64_EXPONENT_BIAS - FLOAT16_EXPONENT_BIAS + 1, 0, 0) < x - FLOAT64_MK(FLOAT64_EXPONENT_BIAS - FLOAT16_EXPONENT_BIAS + FLOAT16_EXPONENT_INF, 0, 0)) {



    half = (__SEGGER_RTL_UINT_LEAST16_T)(x >> (FLOAT64_SIGNIFICAND_BITS - FLOAT16_SIGNIFICAND_BITS));
    half -= (__SEGGER_RTL_UINT_LEAST16_T)((FLOAT64_EXPONENT_BIAS - FLOAT16_EXPONENT_BIAS) << FLOAT16_SIGNIFICAND_BITS);



    x <<= (FLOAT64_TOTAL_BITS - FLOAT64_SIGNIFICAND_BITS + FLOAT16_SIGNIFICAND_BITS);
    if (x >= __SEGGER_RTL_U64_C(0x8000000000000000)) {
      half += 1;
      if (x == __SEGGER_RTL_U64_C(0x8000000000000000)) {
        half &= ~1;
      }
    }
  } else {



    shift = FLOAT64_EXPONENT_BIAS - FLOAT16_EXPONENT_BIAS - FLOAT64_EXPONENT(x) + 1;
    if (shift > FLOAT64_SIGNIFICAND_BITS) {



      half = 0;
    } else {



      x &= FLOAT64_SIGNIFICAND_MASK;
      x |= FLOAT64_HIDDEN_MASK;
      x = (x >> shift) | ((x << (FLOAT64_TOTAL_BITS - shift)) != 0);
      half = (__SEGGER_RTL_UINT_LEAST16_T)(x >> (FLOAT64_SIGNIFICAND_BITS - FLOAT16_SIGNIFICAND_BITS));



      x <<= (FLOAT64_TOTAL_BITS - FLOAT64_SIGNIFICAND_BITS + FLOAT16_SIGNIFICAND_BITS);
      if (x >= __SEGGER_RTL_U64_C(0x8000000000000000)) {
        half += 1;
        if (x == __SEGGER_RTL_U64_C(0x8000000000000000)) {
          half &= ~1;
        }
      }
    }
  }



  return half | (__SEGGER_RTL_U16)(sign >> (FLOAT64_TOTAL_BITS - FLOAT16_TOTAL_BITS));
}
# 6649 "./floatops.c"
static __SEGGER_RTL_INLINE __SEGGER_RTL_U16 __SEGGER_RTL_double_to_half_ieee(double x) {
  return __SEGGER_RTL_double_to_half_ieee_soft(__SEGGER_RTL_BitcastToU64(x));
}
# 6666 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_double_to_float(double x) {
#if __SEGGER_RTL_FP_HW >= 2 && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return (float)x;
#else
  return __SEGGER_RTL_BitcastToF32(__SEGGER_RTL_double_to_float_soft(__SEGGER_RTL_BitcastToU64(x)));
#endif
}
# 6687 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE float __SEGGER_RTL_half_to_float_ieee_soft(__SEGGER_RTL_U16 x) {
  __SEGGER_RTL_U32 exp;
  __SEGGER_RTL_U32 significand;
  __SEGGER_RTL_U32 sign;
  int q0;



  exp = (x >> 10) & 0x1F;
  significand = (x & __SEGGER_RTL_U32_C(0x03FF)) << (23-10);
  sign = (x & __SEGGER_RTL_U32_C(0x8000)) << 16;

  if (__SEGGER_RTL_UNLIKELY(exp == 0x7C00)) {



    if (significand == 0) {
      return __SEGGER_RTL_BitcastToF32(K_INF_U32 | sign);
    } else {
      return __SEGGER_RTL_BitcastToF32(K_NAN_U32 | sign);
    }
  } else if (exp == 0) {



    q0 = __SEGGER_RTL_CLZ_U32(significand) - 8;
    exp -= q0;
    significand <<= q0;
  }

  return __SEGGER_RTL_BitcastToF32(((exp + 0x7F-15) << 23) + significand + sign);
}
# 6733 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE double __SEGGER_RTL_half_to_double_ieee_soft(__SEGGER_RTL_U16 x) {
  __SEGGER_RTL_U32 exp;
  __SEGGER_RTL_U32 significand;
  __SEGGER_RTL_U32 sign;
  int q0;



  exp = (x >> 10) & 0x1F;
  significand = (x & __SEGGER_RTL_U32_C(0x03FF)) << (52-32-10);
  sign = (x & __SEGGER_RTL_U32_C(0x8000)) << 16;

  if (__SEGGER_RTL_UNLIKELY(exp == 0x7C00)) {



    if (significand == 0) {
      return __SEGGER_RTL_BitcastToF64(K_INF_U64 | sign);
    } else {
      return __SEGGER_RTL_BitcastToF64(K_NAN_U64 | sign);
    }
  } else if (exp == 0) {



    q0 = __SEGGER_RTL_CLZ_U32(significand) - 11;
    exp -= q0;
    significand <<= q0;
  }

  return __SEGGER_RTL_BitcastToF64((__SEGGER_RTL_U64)(((exp + 0x3FF-15) << (52-32)) + significand + sign) << 32);
}
# 6776 "./floatops.c"
static float __SEGGER_RTL_NEVER_INLINE __SEGGER_RTL_float32_PolyEvalP(const float *k, float g, int n) {
  float w;

  n -= 2;
  k += n;
  w = SEGGER_FMAF(k[1], g, k[0]);
  while (--n >= 0) {
    w = SEGGER_FMAF(w, g, *--k);
  }
  return SEGGER_MULF(w, g);
}






static __SEGGER_RTL_ALWAYS_INLINE float __SEGGER_RTL_float32_PolyEvalP_3(float g, const float *pCoeff, float P1, float P2, float P3) {
#if (__SEGGER_RTL_FP_HW == 0) || (__SEGGER_RTL_OPTIMIZE <= 0)

  __SEGGER_RTL_USE_PARA(P1);
  __SEGGER_RTL_USE_PARA(P2);
  __SEGGER_RTL_USE_PARA(P3);

  return __SEGGER_RTL_float32_PolyEvalP(pCoeff, g, 3);
#else
  float w;

  __SEGGER_RTL_USE_PARA(pCoeff);

  w = SEGGER_FMAF(P3, g, P2);
  w = SEGGER_FMAF(w, g, P1);
  w = SEGGER_MULF(w, g);

  return w;
#endif
}






static __SEGGER_RTL_ALWAYS_INLINE float __SEGGER_RTL_float32_PolyEvalP_4(float g, const float *pCoeff, float P1, float P2, float P3, float P4) {
#if (__SEGGER_RTL_FP_HW == 0) || (__SEGGER_RTL_OPTIMIZE <= 0)

  __SEGGER_RTL_USE_PARA(P1);
  __SEGGER_RTL_USE_PARA(P2);
  __SEGGER_RTL_USE_PARA(P3);
  __SEGGER_RTL_USE_PARA(P4);

  return __SEGGER_RTL_float32_PolyEvalP(pCoeff, g, 4);
#else
  float w;

  __SEGGER_RTL_USE_PARA(pCoeff);

  w = SEGGER_FMAF(P4, g, P3);
  w = SEGGER_FMAF(w, g, P2);
  w = SEGGER_FMAF(w, g, P1);
  w = SEGGER_MULF(w, g);

  return w;
#endif
}






static __SEGGER_RTL_ALWAYS_INLINE float __SEGGER_RTL_float32_PolyEvalP_5(float g, const float *pCoeff, float P1, float P2, float P3, float P4, float P5) {
#if (__SEGGER_RTL_FP_HW == 0) || (__SEGGER_RTL_OPTIMIZE <= 0)

  __SEGGER_RTL_USE_PARA(P1);
  __SEGGER_RTL_USE_PARA(P2);
  __SEGGER_RTL_USE_PARA(P3);
  __SEGGER_RTL_USE_PARA(P4);
  __SEGGER_RTL_USE_PARA(P5);

  return __SEGGER_RTL_float32_PolyEvalP(pCoeff, g, 5);
#else
  float w;

  __SEGGER_RTL_USE_PARA(pCoeff);

  w = SEGGER_FMAF(P5, g, P4);
  w = SEGGER_FMAF(w, g, P3);
  w = SEGGER_FMAF(w, g, P2);
  w = SEGGER_FMAF(w, g, P1);
  w = SEGGER_MULF(w, g);

  return w;
#endif
}






static double __SEGGER_RTL_NEVER_INLINE __SEGGER_RTL_float64_PolyEvalP(const double *k, int n, double g) {
  double w;

  n -= 2;
  k += n;
  w = SEGGER_FMA(k[1], g, k[0]);
  while (--n >= 0) {
    w = SEGGER_FMA(w, g, *--k);
  }
  return SEGGER_MUL(w, g);
}






static __SEGGER_RTL_ALWAYS_INLINE double __SEGGER_RTL_float64_PolyEvalP_2(double g, const double *pCoeff, double P1, double P2) {
#if (__SEGGER_RTL_FP_HW == 0) || (__SEGGER_RTL_OPTIMIZE <= 0)

  __SEGGER_RTL_USE_PARA(P1);
  __SEGGER_RTL_USE_PARA(P2);

  return __SEGGER_RTL_float64_PolyEvalP(pCoeff, 2, g);
#else
  double w;

  __SEGGER_RTL_USE_PARA(pCoeff);

  w = SEGGER_FMA(P2, g, P1);
  w = SEGGER_MUL(w, g);

  return w;
#endif
}






static __SEGGER_RTL_ALWAYS_INLINE double __SEGGER_RTL_float64_PolyEvalP_3(double g, const double *pCoeff, double P1, double P2, double P3) {
#if (__SEGGER_RTL_FP_HW == 0) || (__SEGGER_RTL_OPTIMIZE <= 0)

  __SEGGER_RTL_USE_PARA(P1);
  __SEGGER_RTL_USE_PARA(P2);
  __SEGGER_RTL_USE_PARA(P3);

  return __SEGGER_RTL_float64_PolyEvalP(pCoeff, 3, g);
#else
  double w;

  __SEGGER_RTL_USE_PARA(pCoeff);

  w = SEGGER_FMA(P3, g, P2);
  w = SEGGER_FMA(w, g, P1);
  w = SEGGER_MUL(w, g);

  return w;
#endif
}






static __SEGGER_RTL_ALWAYS_INLINE double __SEGGER_RTL_float64_PolyEvalP_4(double g, const double *pCoeff, double P1, double P2, double P3, double P4) {
#if (__SEGGER_RTL_FP_HW == 0) || (__SEGGER_RTL_OPTIMIZE <= 0)

  __SEGGER_RTL_USE_PARA(P1);
  __SEGGER_RTL_USE_PARA(P2);
  __SEGGER_RTL_USE_PARA(P3);
  __SEGGER_RTL_USE_PARA(P4);

  return __SEGGER_RTL_float64_PolyEvalP(pCoeff, 4, g);
#else
  double w;

  __SEGGER_RTL_USE_PARA(pCoeff);

  w = SEGGER_FMA(P4, g, P3);
  w = SEGGER_FMA(w, g, P2);
  w = SEGGER_FMA(w, g, P1);
  w = SEGGER_MUL(w, g);

  return w;
#endif
}






static __SEGGER_RTL_ALWAYS_INLINE double __SEGGER_RTL_float64_PolyEvalP_5(double g, const double *pCoeff, double P1, double P2, double P3, double P4, double P5) {
#if (__SEGGER_RTL_FP_HW == 0) || (__SEGGER_RTL_OPTIMIZE <= 0)

  __SEGGER_RTL_USE_PARA(P1);
  __SEGGER_RTL_USE_PARA(P2);
  __SEGGER_RTL_USE_PARA(P3);
  __SEGGER_RTL_USE_PARA(P4);
  __SEGGER_RTL_USE_PARA(P5);

  return __SEGGER_RTL_float64_PolyEvalP(pCoeff, 5, g);
#else
  double w;

  __SEGGER_RTL_USE_PARA(pCoeff);

  w = SEGGER_FMA(P5, g, P4);
  w = SEGGER_FMA(w, g, P3);
  w = SEGGER_FMA(w, g, P2);
  w = SEGGER_FMA(w, g, P1);
  w = SEGGER_MUL(w, g);

  return w;
#endif
}






static __SEGGER_RTL_ALWAYS_INLINE double __SEGGER_RTL_float64_PolyEvalP_8(double g, const double *pCoeff, double P1, double P2, double P3, double P4, double P5, double P6, double P7, double P8) {
#if (__SEGGER_RTL_FP_HW == 0) || (__SEGGER_RTL_OPTIMIZE <= 0)

  __SEGGER_RTL_USE_PARA(P1);
  __SEGGER_RTL_USE_PARA(P2);
  __SEGGER_RTL_USE_PARA(P3);
  __SEGGER_RTL_USE_PARA(P4);
  __SEGGER_RTL_USE_PARA(P5);
  __SEGGER_RTL_USE_PARA(P6);
  __SEGGER_RTL_USE_PARA(P7);
  __SEGGER_RTL_USE_PARA(P8);

  return __SEGGER_RTL_float64_PolyEvalP(pCoeff, 8, g);
#else
  double w;

  __SEGGER_RTL_USE_PARA(pCoeff);

  w = SEGGER_FMA(P8, g, P7);
  w = SEGGER_FMA(w, g, P6);
  w = SEGGER_FMA(w, g, P5);
  w = SEGGER_FMA(w, g, P4);
  w = SEGGER_FMA(w, g, P3);
  w = SEGGER_FMA(w, g, P2);
  w = SEGGER_FMA(w, g, P1);
  w = SEGGER_MUL(w, g);

  return w;
#endif
}
# 7043 "./floatops.c"
static float __SEGGER_RTL_NEVER_INLINE __SEGGER_RTL_float32_PolyEvalQ(const float *k, float g, int n) {
  float w;

  n -= 1;
  w = SEGGER_ADDF(g, k[n]);
  while (--n >= 0) {
    w = SEGGER_FMAF(w, g, k[n]);
  }
  return w;
}






static __SEGGER_RTL_ALWAYS_INLINE float __SEGGER_RTL_float32_PolyEvalQ_3(float g, const float *pCoeff, float P1, float P2, float P3) {
#if __SEGGER_RTL_FP_HW == 0 || __SEGGER_RTL_OPTIMIZE <= 0

  __SEGGER_RTL_USE_PARA(P1);
  __SEGGER_RTL_USE_PARA(P2);
  __SEGGER_RTL_USE_PARA(P3);

  return __SEGGER_RTL_float32_PolyEvalQ(pCoeff, g, 3);
#else
  float w;

  __SEGGER_RTL_USE_PARA(pCoeff);

  w = SEGGER_ADDF(g, P3);
  w = SEGGER_FMAF(w, g, P2);
  w = SEGGER_FMAF(w, g, P1);

  return w;
#endif
}






static __SEGGER_RTL_ALWAYS_INLINE float __SEGGER_RTL_float32_PolyEvalQ_4(float g, const float *pCoeff, float P1, float P2, float P3, float P4) {
#if (__SEGGER_RTL_FP_HW == 0) || (__SEGGER_RTL_OPTIMIZE <= 0)

  __SEGGER_RTL_USE_PARA(P1);
  __SEGGER_RTL_USE_PARA(P2);
  __SEGGER_RTL_USE_PARA(P3);
  __SEGGER_RTL_USE_PARA(P4);

  return __SEGGER_RTL_float32_PolyEvalQ(pCoeff, g, 4);
#else
  float w;

  __SEGGER_RTL_USE_PARA(pCoeff);

  w = SEGGER_ADDF(g, P4);
  w = SEGGER_FMAF(w, g, P3);
  w = SEGGER_FMAF(w, g, P2);
  w = SEGGER_FMAF(w, g, P1);

  return w;
#endif
}






static __SEGGER_RTL_ALWAYS_INLINE float __SEGGER_RTL_float32_PolyEvalQ_5(float g, const float *pCoeff, float P1, float P2, float P3, float P4, float P5) {
#if (__SEGGER_RTL_FP_HW == 0) || (__SEGGER_RTL_OPTIMIZE <= 0)

  __SEGGER_RTL_USE_PARA(P1);
  __SEGGER_RTL_USE_PARA(P2);
  __SEGGER_RTL_USE_PARA(P3);
  __SEGGER_RTL_USE_PARA(P4);
  __SEGGER_RTL_USE_PARA(P5);

  return __SEGGER_RTL_float32_PolyEvalQ(pCoeff, g, 5);
#else
  float w;

  __SEGGER_RTL_USE_PARA(pCoeff);

  w = SEGGER_ADDF(g, P5);
  w = SEGGER_FMAF(w, g, P4);
  w = SEGGER_FMAF(w, g, P3);
  w = SEGGER_FMAF(w, g, P2);
  w = SEGGER_FMAF(w, g, P1);

  return w;
#endif
}






static double __SEGGER_RTL_NEVER_INLINE __SEGGER_RTL_float64_PolyEvalQ(const double *k, int n, double g) {
  double w;

  k += n;
  w = g;
  while (--n > 0) {
    w = SEGGER_MUL(SEGGER_ADD(w, *--k), g);
  }
  return SEGGER_ADD(w, k[-1]);
}






static __SEGGER_RTL_ALWAYS_INLINE double __SEGGER_RTL_float64_PolyEvalQ_3(double g, const double *pCoeff, double P1, double P2, double P3) {
#if (__SEGGER_RTL_FP_HW == 0) || (__SEGGER_RTL_OPTIMIZE <= 0)

  __SEGGER_RTL_USE_PARA(P1);
  __SEGGER_RTL_USE_PARA(P2);
  __SEGGER_RTL_USE_PARA(P3);

  return __SEGGER_RTL_float64_PolyEvalQ(pCoeff, 3, g);
#else
  double w;

  __SEGGER_RTL_USE_PARA(pCoeff);

  w = SEGGER_ADD(g, P3);
  w = SEGGER_FMA(w, g, P2);
  w = SEGGER_FMA(w, g, P1);

  return w;
#endif
}






static __SEGGER_RTL_ALWAYS_INLINE double __SEGGER_RTL_float64_PolyEvalQ_4(double g, const double *pCoeff, double P1, double P2, double P3, double P4) {
#if (__SEGGER_RTL_FP_HW == 0) || (__SEGGER_RTL_OPTIMIZE <= 0)

  __SEGGER_RTL_USE_PARA(P1);
  __SEGGER_RTL_USE_PARA(P2);
  __SEGGER_RTL_USE_PARA(P3);
  __SEGGER_RTL_USE_PARA(P4);

  return __SEGGER_RTL_float64_PolyEvalQ(pCoeff, 4, g);
#else
  double w;

  __SEGGER_RTL_USE_PARA(pCoeff);

  w = SEGGER_ADD(g, P4);
  w = SEGGER_FMA(w, g, P3);
  w = SEGGER_FMA(w, g, P2);
  w = SEGGER_FMA(w, g, P1);

  return w;
#endif
}






static __SEGGER_RTL_ALWAYS_INLINE double __SEGGER_RTL_float64_PolyEvalQ_5(double g, const double *pCoeff, double P1, double P2, double P3, double P4, double P5) {
#if (__SEGGER_RTL_FP_HW == 0) || (__SEGGER_RTL_OPTIMIZE <= 0)

  __SEGGER_RTL_USE_PARA(P1);
  __SEGGER_RTL_USE_PARA(P2);
  __SEGGER_RTL_USE_PARA(P3);
  __SEGGER_RTL_USE_PARA(P4);
  __SEGGER_RTL_USE_PARA(P5);

  return __SEGGER_RTL_float64_PolyEvalQ(pCoeff, 5, g);
#else
  double w;

  __SEGGER_RTL_USE_PARA(pCoeff);

  w = SEGGER_ADD(g, P5);
  w = SEGGER_FMA(w, g, P4);
  w = SEGGER_FMA(w, g, P3);
  w = SEGGER_FMA(w, g, P2);
  w = SEGGER_FMA(w, g, P1);

  return w;
#endif
}
# 7252 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE __SEGGER_RTL_U32 __SEGGER_RTL_float32_abs_soft(__SEGGER_RTL_U32 x) {
  return x & ~FLOAT32_SIGN_MASK;
}
# 7270 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE float __SEGGER_RTL_float32_abs_inline(float x) {

#if defined(__SEGGER_RTL_FLOAT32_ABS)

  return __SEGGER_RTL_FLOAT32_ABS(x);

#else






  return __SEGGER_RTL_BitcastToF32(
           __SEGGER_RTL_float32_abs_soft(
             __SEGGER_RTL_BitcastToU32(x)));

#endif
}
# 7304 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE __SEGGER_RTL_U64 __SEGGER_RTL_float64_abs_soft(__SEGGER_RTL_U64 x) {
  return x & ~FLOAT64_SIGN_MASK;
}
# 7322 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE double __SEGGER_RTL_float64_abs_inline(double x) {

#if defined(__SEGGER_RTL_FLOAT64_ABS) && !__SEGGER_RTL_FORCE_SOFT_FLOAT
  return __SEGGER_RTL_FLOAT64_ABS(x);
#else






  return __SEGGER_RTL_BitcastToF64(
           __SEGGER_RTL_float64_abs_soft(
             __SEGGER_RTL_BitcastToU64(x)));
#endif
}
# 7363 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE double __SEGGER_RTL_float64_ldexp_inline(double x, int n) {
  __SEGGER_RTL_U64 u;
  int exp;

  u = __SEGGER_RTL_BitcastToU64(x);
  exp = FLOAT64_EXPONENT(u);

  if (__SEGGER_RTL_UNLIKELY(exp == 0x7FF || exp == 0x000)) {
    return x;
  }

  exp += n;
  if (exp >= 0x7FF) {
    u = K_INF_U64 | (u & FLOAT64_SIGN_MASK);
  } else if (exp <= 0) {
    u &= FLOAT64_SIGN_MASK;
  } else {
    u = (u & ~FLOAT64_EXPONENT_MASK) | ((__SEGGER_RTL_U64)exp << FLOAT64_SIGNIFICAND_BITS);
  }

  return __SEGGER_RTL_BitcastToF64(u);
}
# 7410 "./floatops.c"
static double __SEGGER_RTL_NEVER_INLINE __SEGGER_RTL_float64_ldexp_outline(double x, int n) {
  return __SEGGER_RTL_float64_ldexp_inline(x, n);
}
# 7438 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE float __SEGGER_RTL_float32_ldexp_inline(float x, int n) {
  __SEGGER_RTL_U32 x0;
  int exp;

  x0 = __SEGGER_RTL_BitcastToU32(x);
  exp = FLOAT32_EXPONENT(x0);

  if (__SEGGER_RTL_UNLIKELY((unsigned)exp-1 >= 0xFE)) {
    return x;
  }

  n += exp;
  if ((unsigned)n-1u < 0xFE) {



    x0 &= ~FLOAT32_EXPONENT_MASK;
    x0 |= (__SEGGER_RTL_U32)n << FLOAT32_SIGNIFICAND_BITS;
  } else if (__SEGGER_RTL_UNLIKELY(n <= 0)) {



    x0 &= FLOAT32_SIGN_MASK;
  } else {



    x0 = K_INF_U32 | (x0 & FLOAT32_SIGN_MASK);
  }

  return __SEGGER_RTL_BitcastToF32(x0);
}
# 7495 "./floatops.c"
static __SEGGER_RTL_NEVER_INLINE float __SEGGER_RTL_float32_ldexp_outline(float x, int n) {
  return __SEGGER_RTL_float32_ldexp_inline(x, n);
}
# 7520 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_frexp_inline(float x, int *exp) {
  __SEGGER_RTL_U32 x0;
  unsigned q0;



  x0 = __SEGGER_RTL_BitcastToU32(x);
  q0 = FLOAT32_EXPONENT(x0);



  if (__SEGGER_RTL_UNLIKELY(q0 == 0 || q0 == 0xFF)) {
    *exp = 0;
    return x;
  } else {

    *exp = q0 - 0x7E;
    x0 &= ~__SEGGER_RTL_U32_C(0x7F800000);
    x0 |= __SEGGER_RTL_U32_C(0x3F000000);

    return __SEGGER_RTL_BitcastToF32(x0);
  }
}
# 7565 "./floatops.c"
static __SEGGER_RTL_NEVER_INLINE float __SEGGER_RTL_float32_frexp_outline(float x, int *exp) {
  return __SEGGER_RTL_float32_frexp_inline(x, exp);
}
# 7590 "./floatops.c"
static __SEGGER_RTL_INLINE double __SEGGER_RTL_float64_frexp_inline(double x, int *exp) {
  __SEGGER_RTL_U64 x0;
  unsigned q0;

  x0 = __SEGGER_RTL_BitcastToU64(x);
  q0 = FLOAT64_EXPONENT(x0);



  if (q0 == 0 || q0 == 0x7FF) {
    *exp = 0;
    return x;
  } else {

    *exp = q0 - 0x3FE;
    x0 &= ~__SEGGER_RTL_U32_C(0x7FF0000000000000);
    x0 |= __SEGGER_RTL_U32_C(0x3FE0000000000000);

    return __SEGGER_RTL_BitcastToF64(x0);
  }
}
# 7633 "./floatops.c"
static __SEGGER_RTL_NEVER_INLINE double __SEGGER_RTL_float64_frexp_outline(double x, int *exp) {
  return __SEGGER_RTL_float64_frexp_inline(x, exp);
}
# 7657 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_logb_inline(float x) {
  int q0;

  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_isspecial(x))) {
    if (__SEGGER_RTL_float32_isinf_inline(x)) {
      return K_INF_F32;
    } else if (__SEGGER_RTL_float32_isnan_inline(x)) {
      return K_NAN_F32;
    } else {
      return __SEGGER_RTL_BitcastToF32(K_INF_U32 | FLOAT32_SIGN_MASK);
    }
  }

  q0 = FLOAT32_EXPONENT(__SEGGER_RTL_BitcastToU32(x));

  return SEGGER_I2F(q0 - FLOAT32_EXPONENT_BIAS);
}
# 7695 "./floatops.c"
static __SEGGER_RTL_INLINE double __SEGGER_RTL_float64_logb_inline(double x) {
  int q0;

  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_isspecial(x))) {
    if (__SEGGER_RTL_float64_isinf_inline(x)) {
      return K_INF_F64;
    } else if (__SEGGER_RTL_float64_isnan_inline(x)) {
      return K_NAN_F64;
    } else {
      return __SEGGER_RTL_BitcastToF64(K_INF_U64 | FLOAT64_SIGN_MASK);
    }
  }

  q0 = FLOAT64_EXPONENT(__SEGGER_RTL_BitcastToU64(x));

  return SEGGER_I2D(q0 - FLOAT64_EXPONENT_BIAS);
}
# 7729 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float32_ilogb_inline(float x) {
  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_putative_iszero(x))) {
    return K_FP_ILOGB0;
  } else if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_isnan_inline(x))) {
    return K_FP_ILOGBNAN;
  } else if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_isinf_inline(x))) {
    return K_INT_MAX;
  } else {
    return FLOAT32_EXPONENT(__SEGGER_RTL_BitcastToU32(x)) - FLOAT32_EXPONENT_BIAS;
  }
}
# 7757 "./floatops.c"
static __SEGGER_RTL_NEVER_INLINE int __SEGGER_RTL_float32_ilogb_outline(float x) {
  return __SEGGER_RTL_float32_ilogb_inline(x);
}
# 7777 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE int __SEGGER_RTL_float64_ilogb_inline(double x) {
  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_putative_iszero(x))) {
    return K_FP_ILOGB0;
  } else if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_isnan_inline(x))) {
    return K_FP_ILOGBNAN;
  } else if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_isinf_inline(x))) {
    return K_INT_MAX;
  } else {
    return FLOAT64_EXPONENT(__SEGGER_RTL_BitcastToU64(x)) - FLOAT64_EXPONENT_BIAS;
  }
}
# 7805 "./floatops.c"
static __SEGGER_RTL_NEVER_INLINE int __SEGGER_RTL_float64_ilogb_outline(double x) {
  return __SEGGER_RTL_float64_ilogb_inline(x);
}
# 7825 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_ceil_inline(float x) {
  __SEGGER_RTL_U32 mask;
  __SEGGER_RTL_U32 exact;
  __SEGGER_RTL_U32 x0;
  int exponent;



  x0 = __SEGGER_RTL_BitcastToU32(x);
  exponent = FLOAT32_EXPONENT(x0);

  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_isspecial(x))) {
    if (exponent == 0) {
      x0 &= FLOAT32_SIGN_MASK;
    }
    return __SEGGER_RTL_BitcastToF32(x0);
  }

  exponent -= 0x7F;
  if (exponent < 0) {



    if (FLOAT32_SIGN(x0)) {
      return -0.0f;
    } else {
      return 1.0f;
    }
  } else if (exponent >= 23) {




    return x;
  }



  mask = FLOAT32_SIGNIFICAND_MASK >> exponent;



  exact = x0 & mask;



  x0 &= ~mask;



  if (exact && FLOAT32_SIGN(x0) == 0) {
    x0 += __SEGGER_RTL_U32_C(1) << 23 >> exponent;
  }

  return __SEGGER_RTL_BitcastToF32(x0);
}
# 7898 "./floatops.c"
static __SEGGER_RTL_INLINE double __SEGGER_RTL_float64_ceil_inline(double x) {
  __SEGGER_RTL_U64 x0;
  __SEGGER_RTL_U64 mask;
  __SEGGER_RTL_U64 exact;
  int exponent;



  x0 = __SEGGER_RTL_BitcastToU64(x);
  exponent = FLOAT64_EXPONENT(x0);

  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_isspecial(x))) {
    if (exponent == 0) {
      x0 &= FLOAT64_SIGN_MASK;
    }
    return __SEGGER_RTL_BitcastToF64(x0);
  }

  exponent -= 0x3FF;
  if (exponent < 0) {



    if (FLOAT64_SIGN(x0)) {
      return 0.0;
    } else {
      return 1.0;
    }
  } else if (exponent >= 52) {




    return __SEGGER_RTL_BitcastToF64(x0);
  }



  mask = FLOAT64_SIGNIFICAND_MASK >> exponent;



  exact = x0 & mask;
  x0 &= ~mask;

  if (exact && FLOAT64_SIGN(x0) == 0) {
    x0 += __SEGGER_RTL_U64_C(1) << 52 >> exponent;
  }
  return __SEGGER_RTL_BitcastToF64(x0);
}
# 7965 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_floor_inline(float x) {
  __SEGGER_RTL_U32 x0;
  __SEGGER_RTL_U32 mask;
  __SEGGER_RTL_U32 exact;
  int exponent;

  x0 = __SEGGER_RTL_BitcastToU32(x);
  exponent = FLOAT32_EXPONENT(x0);

  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_isspecial(x))) {
    if (exponent == 0) {
      x0 &= FLOAT32_SIGN_MASK;
    }
    return __SEGGER_RTL_BitcastToF32(x0);
  }

  exponent -= 0x7F;
  if (exponent < 0) {



    if (FLOAT32_SIGN(x0)) {
      return -1.0f;
    } else {
      return 0.0f;
    }
  } else if (exponent >= 23) {




    return x;
  }



  mask = FLOAT32_SIGNIFICAND_MASK >> exponent;



  exact = x0 & mask;



  x0 &= ~mask;



  if (exact && FLOAT32_SIGN(x0)) {
    x0 += __SEGGER_RTL_U32_C(1) << 23 >> exponent;
  }

  return __SEGGER_RTL_BitcastToF32(x0);
}
# 8036 "./floatops.c"
static __SEGGER_RTL_INLINE double __SEGGER_RTL_float64_floor_inline(double x) {
  __SEGGER_RTL_U64 mask;
  __SEGGER_RTL_U64 exact;
  __SEGGER_RTL_U64 x0;
  int exponent;

  x0 = __SEGGER_RTL_BitcastToU64(x);
  exponent = FLOAT64_EXPONENT(x0);

  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_isspecial(x))) {
    if (exponent == 0) {
      x0 &= FLOAT64_SIGN_MASK;
    }
    return __SEGGER_RTL_BitcastToF64(x0);
  }

  exponent -= 0x3FF;
  if (exponent < 0) {



    if (FLOAT64_SIGN(x0)) {
      return -1.0;
    } else {
      return 0.0;
    }
  } else if (exponent >= 52) {




    return __SEGGER_RTL_BitcastToF64(x0);
  }



  mask = FLOAT64_SIGNIFICAND_MASK >> exponent;



  exact = x0 & mask;



  x0 &= ~mask;



  if (exact && FLOAT64_SIGN(x0)) {
    x0 += __SEGGER_RTL_U64_C(1) << 52 >> exponent;
  }
  return __SEGGER_RTL_BitcastToF64(x0);
}
# 8106 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_trunc_inline(float x) {
  __SEGGER_RTL_U32 x0;
  __SEGGER_RTL_U32 mask;
  int exponent;

  x0 = __SEGGER_RTL_BitcastToU32(x);
  exponent = FLOAT32_EXPONENT(x0);

  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_isspecial(x))) {
    if (exponent == 0) {
      x0 &= FLOAT32_SIGN_MASK;
    }
    return __SEGGER_RTL_BitcastToF32(x0);
  }

  exponent -= 0x7F;
  if (exponent < 0) {



    return __SEGGER_RTL_BitcastToF32(FLOAT32_SIGN(x0));

  } else if (exponent >= 23) {




    return x;
  }



  mask = FLOAT32_SIGNIFICAND_MASK >> exponent;



  x0 &= ~mask;

  return __SEGGER_RTL_BitcastToF32(x0);
}
# 8163 "./floatops.c"
static __SEGGER_RTL_INLINE double __SEGGER_RTL_float64_trunc_inline(double x) {
  __SEGGER_RTL_U64 mask;
  __SEGGER_RTL_U64 x0;
  int exponent;

  x0 = __SEGGER_RTL_BitcastToU64(x);
  exponent = FLOAT64_EXPONENT(x0);

  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_isspecial(x))) {
    if (exponent == 0) {
      x0 &= FLOAT64_SIGN_MASK;
    }
    return __SEGGER_RTL_BitcastToF64(x0);
  }

  exponent -= 0x3FF;
  if (exponent < 0) {



    return __SEGGER_RTL_BitcastToF64(FLOAT64_SIGN(x0));

  } else if (exponent >= 52) {




    return __SEGGER_RTL_BitcastToF64(x0);
  }



  mask = FLOAT64_SIGNIFICAND_MASK >> exponent;



  x0 &= ~mask;

  return __SEGGER_RTL_BitcastToF64(x0);
}
# 8219 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE float __SEGGER_RTL_float32_rint_inline(float x) {
  __SEGGER_RTL_U32 x0;
  __SEGGER_RTL_U32 Mask;
  __SEGGER_RTL_U32 Fraction;
  unsigned Exponent;
  unsigned Shift;

  x0 = __SEGGER_RTL_BitcastToU32(x);

  Exponent = FLOAT32_EXPONENT(x0) - FLOAT32_EXPONENT_BIAS;



  if (Exponent < FLOAT32_SIGNIFICAND_BITS) {



    Shift = FLOAT32_SIGNIFICAND_BITS - Exponent;
    Mask = ~__SEGGER_RTL_U32_C(0) << Shift;



    Fraction = (x0 | FLOAT32_HIDDEN_MASK) & ~(Mask << 1);
    Fraction = ((Fraction >> Shift) | (Fraction << Exponent << 1));
    Fraction &= FLOAT32_SIGNIFICAND_X_MASK;



    x0 &= Mask;
    if (Fraction > FLOAT32_HIDDEN_MASK) {
      x0 += __SEGGER_RTL_U32_C(1) << Shift;
    }

  } else if (Exponent > FLOAT32_EXPONENT_INF - FLOAT32_EXPONENT_BIAS) {



    x0 = (((__SEGGER_RTL_I32)(__SEGGER_RTL_U32_C(0x7E000000) - (x0 << 1)) >> 31) & __SEGGER_RTL_U32_C(0x3F800000)) | (x0 & FLOAT32_SIGN_MASK);
  }

  return __SEGGER_RTL_BitcastToF32(x0);
}
# 8277 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE double __SEGGER_RTL_float64_rint_inline(double x) {
  __SEGGER_RTL_U64 x0;
  __SEGGER_RTL_U64 Mask;
  __SEGGER_RTL_U64 Fraction;
  unsigned Exponent;
  unsigned Shift;

  x0 = __SEGGER_RTL_BitcastToU64(x);

  Exponent = FLOAT64_EXPONENT(x0) - FLOAT64_EXPONENT_BIAS;



  if (Exponent < FLOAT64_SIGNIFICAND_BITS) {



    Shift = FLOAT64_SIGNIFICAND_BITS - Exponent;
    Mask = ~__SEGGER_RTL_U64_C(0) << Shift;



    Fraction = (x0 | FLOAT64_HIDDEN_MASK) & ~(Mask << 1);
    Fraction = ((Fraction >> Shift) | (Fraction << Exponent << 1));
    Fraction &= FLOAT64_SIGNIFICAND_X_MASK;



    x0 &= Mask;
    if (Fraction > FLOAT64_HIDDEN_MASK) {
      x0 += __SEGGER_RTL_U64_C(1) << Shift;
    }

  } else if (Exponent > FLOAT64_EXPONENT_INF - FLOAT64_EXPONENT_BIAS) {



    x0 = (((__SEGGER_RTL_I64)(__SEGGER_RTL_U64_C(0x7FC0000000000000) - (x0 << 1)) >> 63) & __SEGGER_RTL_U64_C(0x3FF0000000000000)) | (x0 & FLOAT64_SIGN_MASK);
  }

  return __SEGGER_RTL_BitcastToF64(x0);
}
# 8335 "./floatops.c"
static __SEGGER_RTL_INLINE long __SEGGER_RTL_float32_lrint_inline(float x) {
  return SEGGER_F2L(__SEGGER_RTL_float32_rint_inline(x));
}
# 8354 "./floatops.c"
static __SEGGER_RTL_INLINE long __SEGGER_RTL_float64_lrint_inline(double x) {
  return SEGGER_D2L(__SEGGER_RTL_float64_rint_inline(x));
}
# 8373 "./floatops.c"
static __SEGGER_RTL_INLINE long long __SEGGER_RTL_float32_llrint_inline(float x) {
  return SEGGER_F2LL(__SEGGER_RTL_float32_rint_inline(x));
}
# 8392 "./floatops.c"
static __SEGGER_RTL_INLINE long __SEGGER_RTL_float64_llrint_inline(double x) {
  return SEGGER_D2L(__SEGGER_RTL_float64_rint_inline(x));
}
# 8411 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE float __SEGGER_RTL_float32_round_inline(float x) {
  __SEGGER_RTL_U32 x0;
  __SEGGER_RTL_U32 Mask;
  int Exponent;

  x0 = __SEGGER_RTL_BitcastToU32(x);

  Exponent = FLOAT32_EXPONENT(x0) - FLOAT32_EXPONENT_BIAS + 1;



  if (Exponent > 0) {



    if (Exponent <= FLOAT32_SIGNIFICAND_BITS) {
      Mask = FLOAT32_SIGNIFICAND_X_MASK >> Exponent;
      x0 &= ~(Mask >> 1);
      x0 += Mask;
      x0 &= ~Mask;
    }
  } else {



    x0 &= FLOAT32_SIGN_MASK;
    if (Exponent == 0) {
      x0 |= K_one_U32;
    }
  }

  return __SEGGER_RTL_BitcastToF32(x0);
}
# 8460 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE double __SEGGER_RTL_float64_round_inline(double x) {
  __SEGGER_RTL_U64 x0;
  __SEGGER_RTL_U64 Mask;
  int Exponent;

  x0 = __SEGGER_RTL_BitcastToU64(x);

  Exponent = FLOAT64_EXPONENT(x0) - FLOAT64_EXPONENT_BIAS + 1;



  if (Exponent > 0) {



    if (Exponent <= FLOAT64_SIGNIFICAND_BITS) {
      Mask = FLOAT64_SIGNIFICAND_X_MASK >> Exponent;
      x0 &= ~(Mask >> 1);
      x0 += Mask;
      x0 &= ~Mask;
    }
  } else {



    x0 &= FLOAT64_SIGN_MASK;
    if (Exponent == 0) {
      x0 |= K_one_U64;
    }
  }

  return __SEGGER_RTL_BitcastToF64(x0);
}
# 8509 "./floatops.c"
static __SEGGER_RTL_INLINE long __SEGGER_RTL_float32_lround_inline(float x) {
  return SEGGER_F2L(__SEGGER_RTL_float32_round_inline(x));
}
# 8528 "./floatops.c"
static __SEGGER_RTL_INLINE long __SEGGER_RTL_float64_lround_inline(double x) {
  return SEGGER_D2L(__SEGGER_RTL_float64_round_inline(x));
}
# 8547 "./floatops.c"
static __SEGGER_RTL_INLINE long long __SEGGER_RTL_float32_llround_inline(float x) {
  return SEGGER_F2LL(__SEGGER_RTL_float32_round_inline(x));
}
# 8566 "./floatops.c"
static __SEGGER_RTL_INLINE long __SEGGER_RTL_float64_llround_inline(double x) {
  return SEGGER_D2L(__SEGGER_RTL_float64_round_inline(x));
}
# 8584 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE float __SEGGER_RTL_float32_nextafter_inline(float x, float y) {
  __SEGGER_RTL_U32 ix;

  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_isnan_inline(x))) {
    return x;
  } else if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_isnan_inline(y))) {
    return y;
  }

  ix = __SEGGER_RTL_BitcastToU32(x);




  if (__SEGGER_RTL_float32_exact_iszero(x)) {
    ix = __SEGGER_RTL_BitcastToU32(y) & FLOAT32_SIGN_MASK;
    if (!__SEGGER_RTL_float32_exact_iszero(y)) {
      ++ix;
    }
  } else if (__SEGGER_RTL_float32_opposite_signs(x, y)) {
    --ix;
  } else if (__SEGGER_RTL_float32_eq_bitwise(x, y)) {

  } else if (__SEGGER_RTL_float32_lt_bitwise_unsigned(x, y)) {
    ++ix;
  } else {
    --ix;
  }

  return __SEGGER_RTL_BitcastToF32(ix);
}
# 8630 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE double __SEGGER_RTL_float64_nextafter_inline(double x, double y) {
  __SEGGER_RTL_U64 ix;

  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_isnan_inline(x))) {
    return x;
  } else if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_isnan_inline(y))) {
    return y;
  }

  ix = __SEGGER_RTL_BitcastToU64(x);




  if (__SEGGER_RTL_float64_exact_iszero(x)) {
    ix = __SEGGER_RTL_BitcastToU64(y) & FLOAT64_SIGN_MASK;
    if (!__SEGGER_RTL_float64_exact_iszero(y)) {
      ++ix;
    }
  } else if (__SEGGER_RTL_float64_opposite_signs(x, y)) {
    --ix;
  } else if (__SEGGER_RTL_float64_eq_bitwise(x, y)) {

  } else if (__SEGGER_RTL_float64_lt_bitwise_unsigned(x, y)) {
    ++ix;
  } else {
    --ix;
  }

  return __SEGGER_RTL_BitcastToF64(ix);
}
# 8675 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_nan_inline(const char *sText) {
  __SEGGER_RTL_U32 x;

  if (sText[0] == '0' && (sText[1] == 'x' || sText[1] == 'X')) {
    sText += 2;
  }

  x = 0;
  for (;;) {
    if ('0' <= *sText && *sText <= '9') {
      x = x * 0x10u + (*sText - '0');
    } else if ('a' <= *sText && *sText <= 'f') {
      x = x * 0x10u + (*sText - 'a') + 10u;
    } else if ('A' <= *sText && *sText <= 'F') {
      x = x * 0x10u + (*sText - 'A') + 10u;
    } else {
      break;
    }
  }

  x &= FLOAT32_SIGNIFICAND_MASK;
  x |= K_NAN_U32;

  return __SEGGER_RTL_BitcastToF32(x);
}
# 8714 "./floatops.c"
static __SEGGER_RTL_INLINE double __SEGGER_RTL_float64_nan_inline(const char *sText) {
  __SEGGER_RTL_U64 x;

  if (sText[0] == '0' && (sText[1] == 'x' || sText[1] == 'X')) {
    sText += 2;
  }

  x = 0;
  for (;;) {
    if ('0' <= *sText && *sText <= '9') {
      x = x * 0x10u + (*sText - '0');
    } else if ('a' <= *sText && *sText <= 'f') {
      x = x * 0x10u + (*sText - 'a') + 10u;
    } else if ('A' <= *sText && *sText <= 'F') {
      x = x * 0x10u + (*sText - 'A') + 10u;
    } else {
      break;
    }
    ++sText;
  }

  x &= FLOAT64_SIGNIFICAND_MASK;
  x |= K_NAN_U64;

  return __SEGGER_RTL_BitcastToF64(x);
}
# 8768 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_sqrt_scaled_integer(float x) {
  __SEGGER_RTL_U32 i0, i1, i2;
  __SEGGER_RTL_U64 d0;
  unsigned q0;
#if !__SEGGER_RTL_SUBNORMALS_READ_AS_ZERO
  unsigned q1;
#endif



  i0 = __SEGGER_RTL_BitcastToU32(x);
  q0 = (unsigned)(i0 >> 23) - 1;

  if (__SEGGER_RTL_UNLIKELY(q0 >= 0xFE)) {



    q0 += 1;
    if (q0 >= 0xFF) {



      i1 = i0 << 1;
      if (i1 == 0x00000000) {
        return x;
      } else if (i1 > __SEGGER_RTL_U32_C(0xFF000000)) {
        return __SEGGER_RTL_BitcastToF32(i0 | __SEGGER_RTL_U32_C(0x400000));
      } else if (i0 & __SEGGER_RTL_U32_C(0x80000000)) {
        return K_NAN_F32;
      } else {
        return x;
      }
    } else {



#if __SEGGER_RTL_SUBNORMALS_READ_AS_ZERO
      return 0;
#else
      if (i0 == 0) {
        return x;
      }



      q1 = __SEGGER_RTL_CLZ_U32(i0) - 8;
      q0 -= q1;
      i0 <<= q1;
      if (q0 & 1) {
        i0 &= ~__SEGGER_RTL_U32_C(0x800000);
      }
#endif
    }
  }



  i0 <<= 8;
  i1 = __SEGGER_RTL_aSqrtData[i0 >> 24];
  i2 = __SEGGER_RTL_aSqrtData[0x100 + (i0 >> 25)];



  i0 |= __SEGGER_RTL_U32_C(0x80000000);



  i0 >>= (~q0 & 1);




  i1 = (i1 << (32-12)) + (__SEGGER_RTL_U32)(__SEGGER_RTL_UMULL_X(i0 - ((i1 * i1) << 16), i2) >> 12);
  d0 = ((__SEGGER_RTL_U64)i0 << 24) - __SEGGER_RTL_UMULL_X(i1, i1);
  i1 += (__SEGGER_RTL_UMULL_HI(__SEGGER_RTL_U64_L(d0), i2) + __SEGGER_RTL_U64_H(d0) * i2) >> 4;
  d0 = ((__SEGGER_RTL_U64)i0 << 24) - __SEGGER_RTL_UMULL_X(i1, i1);
  i1 += (__SEGGER_RTL_UMULL_HI(__SEGGER_RTL_U64_L(d0), i2) + __SEGGER_RTL_U64_H(d0) * i2) >> 4;



  i1 = (i1 & ~0x07) | 0x08;



  return __SEGGER_RTL_BitcastToF32( ((__SEGGER_RTL_U32)((q0 & ~1u) + 0x7E) << 22)
                                   + (i1 >> 4)
                                   + (((__SEGGER_RTL_U64)i0 << 24) >= __SEGGER_RTL_UMULL_X(i1, i1)));
}
# 8879 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE float __SEGGER_RTL_float32_sqrt_newton_fpu(float x) {
  float y0;
  int n;

  if (__SEGGER_RTL_OPTIMIZE <= -2 || __SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_isspecial_or_negative(x))) {
    if (__SEGGER_RTL_float32_putative_iszero(x)) {
      return __SEGGER_RTL_float32_subnormal_flush(x);
    } else if (__SEGGER_RTL_float32_lt_rhs_positive(x, 0)) {
      return K_NAN_F32;
    } else if (__SEGGER_RTL_OPTIMIZE > -2 || !__SEGGER_RTL_float32_isfinite_inline(x)) {
      return x;
    }
  }



  SEGGER_FREXPF(x, &n);



  x = SEGGER_LDEXPF(x, -n);
# 8909 "./floatops.c"
  y0 = SEGGER_ADDF(__SEGGER_RTL_FLT_SELECT(0x1.ab52bp-2f, 0.4173076152801513671875f),
                   SEGGER_MULF(__SEGGER_RTL_FLT_SELECT(0x1.2e29b8p-1f, 0.5901620388031005859375f), x));



  y0 = SEGGER_DIV2F(SEGGER_ADDF(y0, SEGGER_DIVF(x, y0)));
  y0 = SEGGER_DIV2F(SEGGER_ADDF(y0, SEGGER_DIVF(x, y0)));
  if (n & 1) {
    y0 = SEGGER_MULF(y0, (float)M_SQRT_1_2);
    ++n;
  }



  return SEGGER_LDEXPF(y0, n >> 1);
}
# 8953 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_sqrt_markstein_fpu(float x) {
  float g;
  float y;
  int n;
  unsigned x0;

  if (__SEGGER_RTL_OPTIMIZE <= -2 || __SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_isspecial_or_negative(x))) {
    if (__SEGGER_RTL_float32_putative_iszero(x)) {
      return __SEGGER_RTL_float32_subnormal_flush(x);
    } else if (__SEGGER_RTL_float32_lt_rhs_positive(x, 0)) {
      return K_NAN_F32;
    } else if (__SEGGER_RTL_OPTIMIZE > -2 || !__SEGGER_RTL_float32_isfinite_inline(x)) {
      return x;
    }
  }




  x0 = (__SEGGER_RTL_BitcastToU32(x) << 8 >> 24);
  g = __SEGGER_RTL_BitcastToF32(__SEGGER_RTL_U32_C(0x3E800000) + ((__SEGGER_RTL_U32)__SEGGER_RTL_aSqrtData[x0] << 16));
  y = __SEGGER_RTL_BitcastToF32(__SEGGER_RTL_U32_C(0x3E800000) + ((__SEGGER_RTL_U32)__SEGGER_RTL_aSqrtData[(x0>>1) + 0x100] << 16));



  x = SEGGER_FREXPF(x, &n);
  if (n & 1) {
    x = SEGGER_DIV2F(x);
    ++n;
  }



  g = SEGGER_ADDF(g, SEGGER_MULF(SEGGER_SUBF(x, SEGGER_MULF(g, g)), y));
  g = SEGGER_ADDF(g, SEGGER_MULF(SEGGER_SUBF(x, SEGGER_MULF(g, g)), y));
  g = SEGGER_ADDF(g, SEGGER_MULF(SEGGER_SUBF(x, SEGGER_MULF(g, g)), y));

  return SEGGER_LDEXPF(g, n / 2);
}
# 9015 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_sqrt_inline(float x) {
#if defined(__SEGGER_RTL_FLOAT32_SQRT)
  return __SEGGER_RTL_FLOAT32_SQRT(x);
#elif __SEGGER_RTL_SCALED_INTEGER >= 1
  return __SEGGER_RTL_float32_sqrt_scaled_integer(x);
#else
  return __SEGGER_RTL_float32_sqrt_markstein_fpu(x);
#endif
}
# 9047 "./floatops.c"
static float __SEGGER_RTL_NEVER_INLINE __SEGGER_RTL_float32_sqrt_outline(float x) {
  return __SEGGER_RTL_float32_sqrt_inline(x);
}
# 9069 "./floatops.c"
static __SEGGER_RTL_INLINE double __SEGGER_RTL_float64_sqrt_newton_fpu(double x) {
  double y0;
  int n;
  int memn;

  if (__SEGGER_RTL_OPTIMIZE <= -2 || __SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_isspecial_or_negative(x))) {
    if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_putative_iszero(x))) {
      return __SEGGER_RTL_float64_subnormal_flush(x);
    } else if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_lt_rhs_positive(x, 0))) {
      return K_NAN_F64;
    } else if (__SEGGER_RTL_UNLIKELY(!__SEGGER_RTL_float64_isfinite_inline(x))) {
      return x;
    }
  }



  x = SEGGER_FREXP(x, &memn);
  n = memn;



  y0 = SEGGER_ADD(0.41731, SEGGER_MUL(0.59016, x));



  y0 = SEGGER_DIV2(SEGGER_ADD(y0, SEGGER_DIV(x, y0)));
  y0 = SEGGER_DIV2(SEGGER_ADD(y0, SEGGER_DIV(x, y0)));
  y0 = SEGGER_SUB(y0, SEGGER_DIV2(SEGGER_SUB(y0, SEGGER_DIV(x, y0))));
  if (n & 1) {
    y0 = SEGGER_MUL(y0, M_SQRT_1_2);
    ++n;
  }

  return SEGGER_LDEXP(y0, n / 2);
}
# 9119 "./floatops.c"
static __SEGGER_RTL_INLINE double __SEGGER_RTL_float64_sqrt_kahan_fpu(double x) {
  SEGGER_RTL_float64_t xx;
  SEGGER_RTL_float64_t yy;
  __SEGGER_RTL_U32 k;
  double z;

  if (__SEGGER_RTL_OPTIMIZE <= -2 || __SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_isspecial_or_negative(x))) {
    if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_putative_iszero(x))) {
      return __SEGGER_RTL_float64_subnormal_flush(x);
    } else if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_lt_rhs_positive(x, 0))) {
      return K_NAN_F64;
    } else if (__SEGGER_RTL_UNLIKELY(!__SEGGER_RTL_float64_isfinite_inline(x))) {
      return x;
    }
  }

  xx.l = __SEGGER_RTL_BitcastToU64(x);
  k = __SEGGER_RTL_U32_C(0x5FE80000) - (xx.part.hi >> 1);
  yy.part.hi = k - __SEGGER_RTL_kahan_aT2[(k>>14) & 0x3F];
  yy.part.lo = 0;







  z = SEGGER_MUL(x, SEGGER_MUL(yy.f, yy.f));
  yy.f = SEGGER_MUL(yy.f, SEGGER_SUB(1.5, SEGGER_DIV2(z)));
  z = SEGGER_MUL(x, SEGGER_MUL(yy.f, yy.f));
  yy.f = SEGGER_MUL(yy.f, SEGGER_SUB(__SEGGER_RTL_FLT_SELECT(0x1.7ffffffcp0, 1.499999999068677425384521484375), SEGGER_DIV2(z)));



  z = SEGGER_MUL(x, yy.f);
  z = SEGGER_ADD(z, SEGGER_DIV2(SEGGER_MUL(z, (SEGGER_SUB(1, SEGGER_MUL(z, yy.f))))));

  return z;
}
# 9182 "./floatops.c"
static __SEGGER_RTL_INLINE double __SEGGER_RTL_float64_sqrt_markstein_standard(double x) {
  double g;
  double y;
  int n;
  unsigned x0;

  if (__SEGGER_RTL_OPTIMIZE <= -2 || __SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_isspecial_or_negative(x))) {
    if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_putative_iszero(x))) {
      return __SEGGER_RTL_float64_subnormal_flush(x);
    } else if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_lt_rhs_positive(x, 0))) {
      return K_NAN_F64;
    } else if (__SEGGER_RTL_UNLIKELY(!__SEGGER_RTL_float64_isfinite_inline(x))) {
      return x;
    }
  }




  x0 = (__SEGGER_RTL_BitcastToU64(x) << 11 >> (24 + 32));
  g = __SEGGER_RTL_BitcastToF64(__SEGGER_RTL_U64_C(0x3FD0000000000000) + ((__SEGGER_RTL_U64)__SEGGER_RTL_aSqrtData[x0] << 45));
  y = __SEGGER_RTL_BitcastToF64(__SEGGER_RTL_U32_C(0x3FD0000000000000) + ((__SEGGER_RTL_U64)__SEGGER_RTL_aSqrtData[(x0>>1) + 0x100] << 45));



  x = SEGGER_FREXP(x, &n);
  if (n & 1) {
    x = SEGGER_DIV2(x);
    ++n;
  }



  g = SEGGER_FMA(SEGGER_FMA(SEGGER_NEG(g), g, x), y, g);
  y = SEGGER_FMA(SEGGER_FMA(SEGGER_NEG(y), g, 0.5), SEGGER_MUL2(y), y);
  g = SEGGER_FMA(SEGGER_FMA(SEGGER_NEG(g), g, x), y, g);
  y = SEGGER_FMA(SEGGER_FMA(SEGGER_NEG(y), g, 0.5), SEGGER_MUL2(y), y);
  g = SEGGER_FMA(SEGGER_FMA(SEGGER_NEG(g), g, x), y, g);

  return SEGGER_LDEXP(g, n / 2);
}
# 9246 "./floatops.c"
static __SEGGER_RTL_INLINE double __SEGGER_RTL_float64_sqrt_markstein_modified(double x) {
  double g;
  double y;
  int n;
  unsigned x0;

  if (__SEGGER_RTL_OPTIMIZE <= -2 || __SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_isspecial_or_negative(x))) {
    if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_putative_iszero(x))) {
      return __SEGGER_RTL_float64_subnormal_flush(x);
    } else if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_lt_rhs_positive(x, 0))) {
      return K_NAN_F64;
    } else if (__SEGGER_RTL_UNLIKELY(!__SEGGER_RTL_float64_isfinite_inline(x))) {
      return x;
    }
  }




  x0 = (__SEGGER_RTL_BitcastToU64(x) << 11 >> (24 + 32));
  g = __SEGGER_RTL_BitcastToF64(__SEGGER_RTL_U64_C(0x3FD0000000000000) + ((__SEGGER_RTL_U64)__SEGGER_RTL_aSqrtData[x0] << 45));
  y = __SEGGER_RTL_BitcastToF64(__SEGGER_RTL_U64_C(0x3FD0000000000000) + ((__SEGGER_RTL_U64)__SEGGER_RTL_aSqrtData[(x0>>1) + 0x100] << 45));



  x = SEGGER_FREXP(x, &n);
  if (n & 1) {
    x = SEGGER_DIV2(x);
    ++n;
  }




  g = SEGGER_FMA(SEGGER_FMA(SEGGER_NEG(g), g, x), y, g);
  g = SEGGER_FMA(SEGGER_FMA(SEGGER_NEG(g), g, x), y, g);
  g = SEGGER_FMA(SEGGER_FMA(SEGGER_NEG(g), g, x), y, g);
  g = SEGGER_FMA(SEGGER_FMA(SEGGER_NEG(g), g, x), y, g);
  g = SEGGER_FMA(SEGGER_FMA(SEGGER_NEG(g), g, x), y, g);
  g = SEGGER_FMA(SEGGER_FMA(SEGGER_NEG(g), g, x), y, g);
  g = SEGGER_FMA(SEGGER_FMA(SEGGER_NEG(g), g, x), y, g);

  return SEGGER_LDEXP(g, n / 2);
}
# 9310 "./floatops.c"
static __SEGGER_RTL_INLINE double __SEGGER_RTL_float64_sqrt_scaled_integer(double x) {
  __SEGGER_RTL_U64 g;
  __SEGGER_RTL_U64 i0;
  __SEGGER_RTL_U32 y;
  __SEGGER_RTL_U32 g0;
  unsigned q0;
  unsigned q1;

  i0 = __SEGGER_RTL_BitcastToU64(x);
  q0 = (unsigned)(i0 >> 52) - 1;

  if (__SEGGER_RTL_UNLIKELY(q0 >= 0x7FE)) {



    q0 += 1;
    if (q0 >= 0x7FF) {



      if ((i0 << 1) == 0) {
        return x;
      } else if (__SEGGER_RTL_float64_isnan_soft(i0)) {
        return __SEGGER_RTL_BitcastToF64(i0);
      } else if (i0 & 0x8000000000000000) {
        return K_NAN_F64;
      } else {
        return x;
      }
#if 0

    } else if (__SEGGER_RTL_float64_putative_iszero(x)) {
      return __SEGGER_RTL_float64_subnormal_flush(x);
#else

    } else {



      if (i0 == 0) {
        return x;
      }



      q0 = __SEGGER_RTL_float64_normalize(&i0, q0);
      if (q0 & 1) {
        i0 &= ~__SEGGER_RTL_U64_C(0x0010000000000000);
      }
#endif
    }
  }




  i0 <<= 11;
  q1 = (unsigned)(i0 >> 56);
  g0 = __SEGGER_RTL_aSqrtData[q1];
  y = __SEGGER_RTL_aSqrtData[(q1>>1) + 0x100];

  i0 |= __SEGGER_RTL_U64_C(0x8000000000000000);
  if ((q0 & 1) == 0) {
    i0 >>= 1;
  }




  g = ((__SEGGER_RTL_U64)g0 << (64-8)) + ((i0 - ((__SEGGER_RTL_U64)(g0 * g0) << (64-16))) >> 8) * y;
  g += ((i0 - __SEGGER_RTL_SquareHi_U64(g)) >> 8) * y;
  g += ((i0 - __SEGGER_RTL_SquareHi_U64(g)) >> 8) * y;
  g += ((i0 - __SEGGER_RTL_SquareHi_U64(g)) >> 8) * y;
  g += ((i0 - __SEGGER_RTL_SquareHi_U64(g)) >> 8) * y;
  g += ((i0 - __SEGGER_RTL_SquareHi_U64(g)) >> 8) * y;
  g += ((i0 - __SEGGER_RTL_SquareHi_U64(g)) >> 8) * y;
  g += ((i0 - __SEGGER_RTL_SquareHi_U64(g)) >> 8) * y;

  g &= ~__SEGGER_RTL_U64_C(0x3FF);
  g |= 0x400u;

  return __SEGGER_RTL_BitcastToF64(((__SEGGER_RTL_U64)((q0 & ~1) + 0x3FE) << 51) +
                                   (g >> 11) +
                                   (i0 > __SEGGER_RTL_SquareHi_U64(g)));
}
# 9418 "./floatops.c"
static __SEGGER_RTL_INLINE double __SEGGER_RTL_float64_sqrt_inline(double x) {
#if defined(__SEGGER_RTL_FLOAT64_SQRT)
  return __SEGGER_RTL_FLOAT64_SQRT(x);
#elif __SEGGER_RTL_FP_HW < 2 || __SEGGER_RTL_SCALED_INTEGER >= 2
  return __SEGGER_RTL_float64_sqrt_scaled_integer(x);
#else
  return __SEGGER_RTL_float64_sqrt_kahan_fpu(x);
#endif
}
# 9450 "./floatops.c"
static double __SEGGER_RTL_NEVER_INLINE __SEGGER_RTL_float64_sqrt_outline(double x) {
  return __SEGGER_RTL_float64_sqrt_inline(x);
}
# 9470 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE float __SEGGER_RTL_float32_cbrt_scaled_integer(float x) {
  __SEGGER_RTL_U32 i0, x0, sign, xx;
  __SEGGER_RTL_I32 i1;
  unsigned q0, q1, q2, LeadingBits;



  xx = __SEGGER_RTL_BitcastToU32(x);



  sign = xx & FLOAT32_SIGN_MASK;



  x0 = xx << 1;
  q0 = x0 >> 24;
  i0 = xx & FLOAT32_SIGNIFICAND_MASK;



  if (__SEGGER_RTL_UNLIKELY(x0 - __SEGGER_RTL_X2(0x00800000) >= __SEGGER_RTL_X2(__SEGGER_RTL_U32_C(0x7F800000) - __SEGGER_RTL_U32_C(0x00800000)))) {




    if (x0 >= __SEGGER_RTL_U32_C(0xFF000000)) {
      return x;
    }
    if (x0 == 0) {
      return x;
    }



    q0 = __SEGGER_RTL_CLZ_U32(i0) - 8;
    i0 <<= q0;
    q0 = 0x95 + q0;
  } else {



    i0 = i0 | FLOAT32_HIDDEN_MASK;
    q0 = 0x95 - q0 + 1;
  }




  q2 = 23 - q0;
  q1 = (unsigned)(((__SEGGER_RTL_I32)(int)q2 * 0x556) >> 12);
  q2 -= 3*q1;
  if (q2 == 3) {
    ++q1;
    q2 = 0;
  }




  LeadingBits = (i0 >> 18) - 32;
  i0 *= __SEGGER_RTL_cbrt_paras.aInitialApprox[LeadingBits] << 4;



  i1 = __SEGGER_RTL_SMULL_HI(i0, __SEGGER_RTL_I32_C(0xF5770B97));
  i1 = __SEGGER_RTL_SMULL_HI(i0, __SEGGER_RTL_I32_C(0x0FCD6E9E) + (i1 >> 3));
  i1 = __SEGGER_RTL_SMULL_HI(i0, __SEGGER_RTL_I32_C(0xE38E38E4) + (i1 >> 3));
  i1 = __SEGGER_RTL_SMULL_HI(i0, __SEGGER_RTL_I32_C(0x55555555) + (i1 >> 3));



  i0 = __SEGGER_RTL_SMULL_HI(__SEGGER_RTL_cbrt_paras.aMidRoot[LeadingBits],
                              __SEGGER_RTL_cbrt_paras.aMult[q2]) << 2;
  i0 += __SEGGER_RTL_SMULL_HI(i1, i0) >> 3;




  q2 = __SEGGER_RTL_CLZ_U32(i0) - 1;
  i0 <<= q2;
  q1 -= q2;

  return __SEGGER_RTL_BitcastToF32(sign + ((__SEGGER_RTL_U32)(0x9D - 31 + q1) << 23) + ((i0 + 64) >> 7));
}
# 9572 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE float __SEGGER_RTL_float32_cbrt_fpu(float x) {
  float fr;
  float r;
  float sign;
  int ex;
  int shx;

  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_isspecial(x))) {
    return x;
  }

  sign = x;
  x = SEGGER_FABSF(x);



  fr = SEGGER_FREXPF(x, &ex);
  shx = ex % 3;
  if (shx > 0) {
    shx -= 3;
  }



  ex = (ex-shx) / 3;
  fr = SEGGER_LDEXPF(fr, shx);






  fr = SEGGER_FMAF(SEGGER_FMAF(-0.46946116f, fr, 1.072302f), fr, 0.3812513f);
  r = SEGGER_LDEXPF(fr, ex);



  for (shx = 0; shx < 3; ++shx) {
    r = SEGGER_FMAF(2.0f/3.0f, r, SEGGER_DIVF(SEGGER_MULF(1.0f/3.0f, x), SEGGER_MULF(r, r)));
  }

  return __SEGGER_RTL_float32_signbit_xor(r, sign);
}
# 9632 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_cbrt(float x) {
#if __SEGGER_RTL_SCALED_INTEGER >= 1
  return __SEGGER_RTL_float32_cbrt_scaled_integer(x);
#else
  return __SEGGER_RTL_float32_cbrt_fpu(x);
#endif
}
# 9656 "./floatops.c"
static __SEGGER_RTL_INLINE double __SEGGER_RTL_float64_cbrt(double x) {
  double fr, r, sign;
  int ex, shx;

  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_isspecial(x))) {
    return x;
  }

  sign = x;
  x = SEGGER_FABS(x);



  fr = SEGGER_FREXP(x, &ex);
  shx = ex % 3;
  if (shx > 0) {
    shx -= 3;
  }



  ex = (ex-shx) / 3;
  fr = SEGGER_LDEXP(fr, shx);






  fr = SEGGER_FMA(SEGGER_FMA(-0.46946116, fr, 1.072302), fr, 0.3812513);
  r = SEGGER_LDEXP(fr, ex);



  for (shx = 0; shx < 4; ++shx) {
    r = SEGGER_FMA(2.0/3.0, r, SEGGER_DIV(SEGGER_MUL(1.0/3.0, x), SEGGER_MUL(r, r)));
  }

  return __SEGGER_RTL_float64_signbit_xor(r, sign);
}
# 9714 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE float __SEGGER_RTL_float32_rsqrt_inline(float x) {
#if defined(__SEGGER_RTL_FLOAT32_SQRT)

  return 1.0f / __SEGGER_RTL_FLOAT32_SQRT(x);

#else

  float xhalf;
  __SEGGER_RTL_U32 ix;

  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_isspecial_or_negative(x))) {
    if (__SEGGER_RTL_float32_putative_iszero(x)) {
      return __SEGGER_RTL_float32_signbit_copy(K_INF_F32, x);
    } else if (__SEGGER_RTL_float32_lt_rhs_positive(x, 0)) {
      return K_NAN_F32;
    } else if (__SEGGER_RTL_float32_isinf_inline(x)) {
      return 0;
    } else {
      return x;
    }
  }

  xhalf = SEGGER_NEGF(SEGGER_DIV2F(x));

  ix = __SEGGER_RTL_BitcastToU32(x);
  ix = __SEGGER_RTL_U32_C(0x5F375A86) - (ix >> 1);
  x = __SEGGER_RTL_BitcastToF32(ix);



  x = SEGGER_MULF(x, SEGGER_FMAF(xhalf, SEGGER_MULF(x, x), 1.5f));
  x = SEGGER_MULF(x, SEGGER_FMAF(xhalf, SEGGER_MULF(x, x), 1.5f));
  x = SEGGER_MULF(x, SEGGER_FMAF(xhalf, SEGGER_MULF(x, x), 1.5f));

  return x;

#endif
}
# 9770 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE double __SEGGER_RTL_float64_rsqrt_inline(double x) {
#if defined(__SEGGER_RTL_FLOAT64_SQRT)

  return 1.0 / __SEGGER_RTL_FLOAT64_SQRT(x);

#else

  double xhalf;
  __SEGGER_RTL_U64 ix;

  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_isspecial_or_negative(x))) {
    if (__SEGGER_RTL_float64_putative_iszero(x)) {
      return __SEGGER_RTL_float64_signbit_copy(K_INF_F64, x);
    } else if (__SEGGER_RTL_float64_lt_rhs_positive(x, 0)) {
      return K_NAN_F64;
    } else if (__SEGGER_RTL_float64_isinf_inline(x)) {
      return 0;
    } else {
      return x;
    }
  }

  xhalf = SEGGER_NEG(SEGGER_DIV2(x));

  ix = __SEGGER_RTL_BitcastToU64(x);
  ix = __SEGGER_RTL_U64_C(0x5FE6EC85E7DE30DA) - (ix >> 1);
  x = __SEGGER_RTL_BitcastToF64(ix);



  x = SEGGER_MUL(x, SEGGER_FMA(xhalf, SEGGER_MUL(x, x), 1.5));
  x = SEGGER_MUL(x, SEGGER_FMA(xhalf, SEGGER_MUL(x, x), 1.5));
  x = SEGGER_MUL(x, SEGGER_FMA(xhalf, SEGGER_MUL(x, x), 1.5));
  x = SEGGER_MUL(x, SEGGER_FMA(xhalf, SEGGER_MUL(x, x), 1.5));

  return x;

#endif
}
# 9826 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE float __SEGGER_RTL_float32_exp_fpu(float x) {
  int n;
  float g;

  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_isnan_inline(x))) {
    return x;
  } else if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_gt_rhs_positive(x, M_LN_HUGEF))) {
    return K_INF_F32;
  } else if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_lt_one_negative(x, -87.336544751f))) {
    return 0;
  } else if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_lt_rhs_positive(SEGGER_FABSF(x), 1.e-20f))) {
    return 1;
  }

  n = SEGGER_F2I(SEGGER_FMAF(1.44266950408889634074f, x, __SEGGER_RTL_float32_signbit_xor(0.5f, x)));
  g = SEGGER_I2F(n);
  g = SEGGER_FMAF(2.1219444005469058277e-4f, g, SEGGER_FMAF(-0.693359375f, g, x));
  x = SEGGER_MULF(g, g);
  g = SEGGER_MULF(SEGGER_FMAF(SEGGER_FMAF(0.165203300268279130e-4f, x, 0.694360001511792852e-2f), x, 0.249999999999999993e+0f), g);
  x = SEGGER_ADDF(0.5f, SEGGER_DIVF(g, SEGGER_FMAF(SEGGER_FMAF(0.495862884905441294e-3f, x, 0.555538666969001188e-1f), x, SEGGER_SUBF(0.5f, g))));

  return SEGGER_LDEXPF(x, n+1);
}
# 9869 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE float __SEGGER_RTL_float32_exp_scaled_integer(float x) {
  __SEGGER_RTL_U32 x0;
  __SEGGER_RTL_U32 t;
  __SEGGER_RTL_U32 i0, i1, i2;
  unsigned q0, q1;



  x0 = __SEGGER_RTL_BitcastToU32(x);
  q0 = x0 << 1 >> 24;



  if (__SEGGER_RTL_UNLIKELY(q0 == 0)) {
    return 1;
  }



  i0 = x0 & 0x7FFFFFu;



  if (__SEGGER_RTL_UNLIKELY(q0 == 0xFF && i0 != 0)) {
    return x;
  }



  if ((x0 & __SEGGER_RTL_U32_C(0x80000000)) == 0) {



    if (x0 > K_log_HUGE_U32) {
      return K_INF_F32;
    }
  } else {



    if (x0 > K_log_SMALL_U32) {
      return 0;
    }
  }




  i0 |= 0x800000;



  if (x0 & 0x80000000) {
    i0 = 0u - i0;
  }

  if (q0 <= 0x76) {



    q0 = 0x76 - q0;
    if (q0 >= 32) {
      return 1.0f;
    }



    i0 = (__SEGGER_RTL_I32)i0 >> q0;
    i0 += (__SEGGER_RTL_I32)__SEGGER_RTL_SMULL_HI(i0, i0) >> 1;
    i0 = (__SEGGER_RTL_I32)(i0 + (1<<1)) >> 2;
    i0 += __SEGGER_RTL_U32_C(0x40000000);
    q0 = 0;

  } else {



    q0 = q0 - 0x71;
    q1 = 32 - q0;





    __SEGGER_RTL_SMULL(i1, i2, __SEGGER_RTL_U32_C(0x5C551D95), i0);



    t = (__SEGGER_RTL_I32)i2 << q0 >> q0;
    i1 = (t << (q0-1)) + (((i1 >> q1) + 1) >> 1);



    i2 = (__SEGGER_RTL_I32)(i2 - t) >> q1;



    i1 -= (__SEGGER_RTL_I32)(i0 * 0x52) >> (8+1) >> q1;
# 9979 "./floatops.c"
    i0 = __SEGGER_RTL_SMULL_HI(i1, __SEGGER_RTL_I32_C(0x002BB100));
    i0 = __SEGGER_RTL_SMULL_HI(i1, __SEGGER_RTL_I32_C(0x013B2AB7) + ((__SEGGER_RTL_I32)i0 >> 2));
    i0 = __SEGGER_RTL_SMULL_HI(i1, __SEGGER_RTL_I32_C(0x071AC236) + ((__SEGGER_RTL_I32)i0 >> 2));
    i0 = __SEGGER_RTL_SMULL_HI(i1, __SEGGER_RTL_I32_C(0x1EBFBE00) + ((__SEGGER_RTL_I32)i0 >> 2));
    i0 = __SEGGER_RTL_SMULL_HI(i1, __SEGGER_RTL_I32_C(0x58B90BFC) + ((__SEGGER_RTL_I32)i0 >> 2));
    i0 = (__SEGGER_RTL_I32)i0 >> 1;




    q0 = i2 & 7;
    i1 = __SEGGER_RTL_float32_Exp_rot_twojby8[q0];
    i0 = i1 + __SEGGER_RTL_SMULL_HI(i0, i1);



    q0 = ((unsigned)i2 + q0) >> 3;
  }



  q0 += 0x7E;
  if (i0 < __SEGGER_RTL_U32_C(0x40000000)) {
    i0 <<= 1;
    --q0;
  }



  return __SEGGER_RTL_BitcastToF32(__SEGGER_RTL_PACK(q0, i0, 0));
}
# 10027 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE float __SEGGER_RTL_float32_exp_inline(float x) {
#if __SEGGER_RTL_SCALED_INTEGER >= 1
  return __SEGGER_RTL_float32_exp_scaled_integer(x);
#else
  return __SEGGER_RTL_float32_exp_fpu(x);
#endif
}
# 10051 "./floatops.c"
static __SEGGER_RTL_NEVER_INLINE float __SEGGER_RTL_float32_exp_outline(float x) {
  return __SEGGER_RTL_float32_exp_inline(x);
}
# 10068 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE double __SEGGER_RTL_float64_exp_fpu(double x) {
  int n;
  double g;
  double h;

  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_isspecial(x))) {
    if (__SEGGER_RTL_float64_isnan_inline(x)) {
      return x;
    } else if (__SEGGER_RTL_float64_isinf_inline(x)) {
      return __SEGGER_RTL_float64_lt_rhs_positive(x, 0) ? 0 : x;
    }
  } else if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_gt_rhs_positive(x, M_LN_HUGE))) {
    return K_INF_F64;
  } else if (__SEGGER_RTL_float64_lt_one_negative(x, -708.39641853226408)) {
    return 0;
  } else if (__SEGGER_RTL_float64_lt_rhs_positive(SEGGER_FABS(x), 1.e-20)) {
    return 1;
  }

  n = SEGGER_D2I(SEGGER_FMA(1.44266950408889634074, x, __SEGGER_RTL_float64_signbit_xor(0.5, x)));
  g = SEGGER_I2D(n);
  g = SEGGER_FMA(2.1219444005469058277e-4, g, SEGGER_FMA(-0.693359375, g, x));
  x = SEGGER_MUL(g, g);
  g = SEGGER_MUL(SEGGER_FMA(SEGGER_FMA(0.165203300268279130e-4, x, 0.694360001511792852e-2), x, 0.249999999999999993e+0), g);
  h = SEGGER_FMA(SEGGER_FMA(0.495862884905441294e-3, x, 0.555538666969001188e-1), x, SEGGER_SUB(0.5, g));
  x = SEGGER_ADD(0.5, SEGGER_DIV(g, h));

  return SEGGER_LDEXP(x, n+1);
}
# 10116 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE double __SEGGER_RTL_float64_exp_scaled_integer(double x) {
  __SEGGER_RTL_U64 i0, i1, i2, i3, i4;
  __SEGGER_RTL_U32 h0, h1, h2, h3;
  unsigned q0, q1;



  i0 = __SEGGER_RTL_BitcastToU64(x);
  i1 = i0 & __SEGGER_RTL_U64_C(0x7FFFFFFFFFFFFFFF);




  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_U32_C(0x03F6232A) < __SEGGER_RTL_U64_H(i1)-__SEGGER_RTL_U32_C(0x3C900000))) {



    if (i1 < __SEGGER_RTL_U64_C(0x3C90000000000000)) {



      return 1.0;

    } else if (i1 >= K_INF_U64) {



      if (i0 == K_MINUS_INF_U64) {



        return 0;

      } else if (i1 == K_INF_U64) {



        return __SEGGER_RTL_BitcastToF64(i0);

      } else {



        return __SEGGER_RTL_BitcastToF64(i0 | __SEGGER_RTL_U64_C(0x0008000000000000));
      }
    } else if (i0 & __SEGGER_RTL_U64_C(0x8000000000000000)) {



      if (i1 >= __SEGGER_RTL_U64_C(0x40874910D52D3052)) {
        return 0;
      }
    } else {



      if (i1 > __SEGGER_RTL_U64_C(0x40862E42FEFA39EF)) {
        return K_INF_F64;
      }
    }
  }



  q0 = 0x433 - ((i1 >> 52) & 0x7FF);
  i1 &= __SEGGER_RTL_U64_C(0x000FFFFFFFFFFFFF);
  i1 |= __SEGGER_RTL_U64_C(0x0010000000000000);



  if (i0 & __SEGGER_RTL_U64_C(0x8000000000000000)) {
    i1 = 0 - i1;
  }

  h0 = __SEGGER_RTL_U64_ROUND(i1);



  i2 = __SEGGER_RTL_SMULL_X(__SEGGER_RTL_U64_L(i1), K_LOG2_E_H);
  i4 = __SEGGER_RTL_SMULL_X(h0, K_LOG2_E_H);
  i3 = __SEGGER_RTL_SMULL_X(h0, K_LOG2_E_M);
  i4 += (__SEGGER_RTL_I64)i3 >> 32;
  i4 += (__SEGGER_RTL_I64)i2 >> 32;

  i2 = i2 & __SEGGER_RTL_U64_C(0xFFFFFFFF);
  i2 += i3 & __SEGGER_RTL_U64_C(0xFFFFFFFF);
  i2 += __SEGGER_RTL_SMULL_HI(__SEGGER_RTL_U64_L(i1), K_LOG2_E_M);
  i2 += __SEGGER_RTL_SMULL_HI(h0, K_LOG2_E_L);

  i4 += (__SEGGER_RTL_I64)i2 >> 32;

  h2 = i4 >> 32;
  h1 = i4 & __SEGGER_RTL_U32_C(0xFFFFFFFF);

  h3 = __SEGGER_RTL_SAFE_ASR_I32(h2, q0-42);
  h3 = ((__SEGGER_RTL_I32)h3 >> 1) + (h3 & 1);
  h2 = h2 - __SEGGER_RTL_SAFE_LSL_U32(h3, q0-41);



  q1 = __SEGGER_RTL_CLZ_U32(__SEGGER_RTL_ABS_I32(h2)) - 2;
  i4 = ((__SEGGER_RTL_U64)h2 << 32) + h1;
  i4 = (i4 << q1) + ((__SEGGER_RTL_U32)i2 >> (32-q1));
  q0 = q0 + q1;
  h1 = __SEGGER_RTL_U64_ROUND(i4);

  q0 -= 64 + 3;
  h2 = q0 + 3;
  if (h2 >= 31) {
    h2 = 31;
  }
  h0 = __SEGGER_RTL_U32_C(0x5761FF94) + (__SEGGER_RTL_SMULL_HI(__SEGGER_RTL_U32_C(0x50C244BE), h1) >> h2);
  h0 = __SEGGER_RTL_U32_C(0x4ECAADBE) + (__SEGGER_RTL_SMULL_HI(h0, h1) >> h2);

  h2 = q0 + 2;
  i0 = __SEGGER_RTL_SMULL_X(h0, h1);

  i0 = __SEGGER_RTL_U64_C(0x71AC235C1282FE2D) + ((__SEGGER_RTL_I64)i0 >> h2);
  i0 = __SEGGER_RTL_SMULL_X(__SEGGER_RTL_U64_ROUND(i0), h1) + __SEGGER_RTL_SMULL_HI(__SEGGER_RTL_U64_L(i0), h1);

  i0 = __SEGGER_RTL_U64_C(0x7AFEF7FE0B163AA2) + ((__SEGGER_RTL_I64)i0 >> h2);
  i0 = __SEGGER_RTL_SMULL_X(__SEGGER_RTL_U64_ROUND(i0), h1) + __SEGGER_RTL_SMULL_HI(__SEGGER_RTL_U64_L(i0), h1);

  i0 = __SEGGER_RTL_U64_C(0x58B90BFBE8E7BCD6) + ((__SEGGER_RTL_I64)i0 >> h2);
  i0 = __SEGGER_RTL_SMULL_X(__SEGGER_RTL_U64_ROUND(i0), h1) + __SEGGER_RTL_SMULL_HI(__SEGGER_RTL_U64_L(i0), h1);

  q0 = q0 - 1;
  h0 = __SEGGER_RTL_SMULL_HI(__SEGGER_RTL_I32_C(0x58B90BFC), __SEGGER_RTL_U64_L(i4));
  i0 += __SEGGER_RTL_SMULL_HI(h0, __SEGGER_RTL_U64_H(i0)) >> q0;
  i0 += (__SEGGER_RTL_I32)h0;



  i1 = __SEGGER_RTL_float64_aExpCoeff[h3 & 63];
  h1 = __SEGGER_RTL_U64_ROUND(i0);
  h0 = __SEGGER_RTL_U64_ROUND(i1);
  i0 = __SEGGER_RTL_SMULL_X (h1, h0)
     + __SEGGER_RTL_SMULL_HI(__SEGGER_RTL_U64_L(i0), h0)
     + __SEGGER_RTL_SMULL_HI(__SEGGER_RTL_U64_L(i1), h1);
  i0 = i1 + ((__SEGGER_RTL_I64)i0 >> q0);







  h3 = (__SEGGER_RTL_I32)h3 >> 6;
  q1 = __SEGGER_RTL_CLZ_U32(__SEGGER_RTL_U64_H(i0));
  if (q1 == 2) {
    i0 <<= 1;
    h3 -= 1;
  }



  h3 += 0x3FE;
  if (h3 & __SEGGER_RTL_U32_C(0x80000000)) {
    i0 >>= 0u - h3;
    h3 = 0;
  }



  return __SEGGER_RTL_BitcastToF64((((i0 >> 9) + 1) >> 1) +
                                   ((__SEGGER_RTL_U64)h3 << 52) +
                                   0);
}
# 10301 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE double __SEGGER_RTL_float64_exp_inline(double x) {
#if __SEGGER_RTL_SCALED_INTEGER >= 2
  return __SEGGER_RTL_float64_exp_scaled_integer(x);
#else
  return __SEGGER_RTL_float64_exp_fpu(x);
#endif
}
# 10325 "./floatops.c"
static double __SEGGER_RTL_NEVER_INLINE __SEGGER_RTL_float64_exp_outline(double x) {
  return __SEGGER_RTL_float64_exp_inline(x);
}
# 10346 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_expm1_scaled_integer(float x) {
  __SEGGER_RTL_U32 x0, x1;
  __SEGGER_RTL_U32 i0, i1, i2, i3;
  unsigned q0, q1, q2, q3;

  x0 = __SEGGER_RTL_BitcastToU32(x);



  x1 = x0 << 1;



  i0 = x0 & __SEGGER_RTL_U32_C(0xFFFFFF);
  q0 = 150 - (x1 >> 24);



  i0 |= __SEGGER_RTL_U32_C(0x800000);



  if (x0 & FLOAT32_SIGN_MASK) {
    i0 = 0u - i0;
  }



  if (__SEGGER_RTL_UNLIKELY((int)q0 <= 16 || (__SEGGER_RTL_I32)x0 >= __SEGGER_RTL_I32_C(0x42B17218) )) {



    if (x1 > __SEGGER_RTL_U32_C(0xFF000000)) {



      x0 |= __SEGGER_RTL_U32_C(0x400000);

    } else if ((__SEGGER_RTL_I32)i0 <= 0) {



      x0 = FLOAT32_SIGN_MASK | __SEGGER_RTL_U32_C(0x3F800000);

    } else {



      x0 = K_INF_U32;
    }

    return __SEGGER_RTL_BitcastToF32(x0);

  } else if (q0 >= 53) {





    return x;

  } else {
    if (q0 > 23) {




      q1 = q0 - 4;
      if (q1 > 30) {
        q1 = 30;
      }

      x0 = (((__SEGGER_RTL_I32)i0 >> q1) + 1) >> 1;
      i0 -= x0 << (q1+1);



#if defined(__SEGGER_RTL_CLZ_U32) && !defined(__SEGGER_RTL_CLZ_U32_SYNTHESIZED)

      q1 = __SEGGER_RTL_CLZ_U32(i0 ^ ((__SEGGER_RTL_I32)i0 >> 31)) - 2;

#else

      q1 = 0;
      i1 = i0 ^ ((__SEGGER_RTL_I32)i0 >> 31);
      while ((i1 & __SEGGER_RTL_U32_C(0x20000000)) == 0) {
        i1 <<= 1;
        q1 += 1;
      }

#endif

      q0 += q1;
      i0 <<= q1;



      q1 = q0 - 32;
      i1 = __SEGGER_RTL_SMULL_HI(i0, __SEGGER_RTL_I32_C(0x01111BE7));
      i1 = __SEGGER_RTL_SMULL_HI(i0, __SEGGER_RTL_I32_C(0x05558DF6) + ((__SEGGER_RTL_I32)i1 >> q1));
      i1 = __SEGGER_RTL_SMULL_HI(i0, __SEGGER_RTL_I32_C(0x15555551) + ((__SEGGER_RTL_I32)i1 >> q1));
      i1 = __SEGGER_RTL_SMULL_HI(i0, __SEGGER_RTL_I32_C(0x3FFFFFF2) + ((__SEGGER_RTL_I32)i1 >> q1));
      i0 += __SEGGER_RTL_SMULL_HI(i0, i1) >> (q1 - 1);

      x0 += 8;
      i3 = __SEGGER_RTL_float32_Expfm1_exp_j_by_8.Value[x0];
      if (i3 == 0) {
        q2 = q0;
      } else {
        q2 = __SEGGER_RTL_float32_Expfm1_exp_j_by_8.Scale[x0];
        i1 = __SEGGER_RTL_SMULL_HI(i0, i3);
        q3 = q2 - 32;
        if ((int)q3 < 0) {
          i0 = (__SEGGER_RTL_I32)(i1 + ((__SEGGER_RTL_I32)i0 >> (0u-q3))) >> q1;
        } else {
          i0 = (__SEGGER_RTL_I32)(i0 + ((__SEGGER_RTL_I32)i1 >> (0u+q3))) >> (q0 - q2);
        }
        i0 += i3;
      }
    } else {



      q1 = q0 - 4;
      q2 = q0 - 5;





      __SEGGER_RTL_SMULL(i2, i1, __SEGGER_RTL_I32_C(0x5C551D95), i0);



      i3 = __SEGGER_RTL_SIGN_EXTEND(i1, q2);
      i2 = (i3 << (32 - q1)) + ((__SEGGER_RTL_I32)((i2 >> q2) + 1) >> 1);



      i2 -= (__SEGGER_RTL_I32)(((__SEGGER_RTL_I32)i0 >> 4) * 0x52) >> q0;



      q1 = (int)(i1 - i3) >> q2;

      i1 = __SEGGER_RTL_SMULL_HI(i2, __SEGGER_RTL_I32_C(0x002BDEDC));
      i1 = __SEGGER_RTL_SMULL_HI(i2, __SEGGER_RTL_I32_C(0x013B3101) + ((__SEGGER_RTL_I32)i1 >> 2));
      i1 = __SEGGER_RTL_SMULL_HI(i2, __SEGGER_RTL_I32_C(0x071AC1F1) + ((__SEGGER_RTL_I32)i1 >> 2));
      i1 = __SEGGER_RTL_SMULL_HI(i2, __SEGGER_RTL_I32_C(0x1EBFBDFE) + ((__SEGGER_RTL_I32)i1 >> 2));
      i1 = __SEGGER_RTL_SMULL_HI(i2, __SEGGER_RTL_I32_C(0x58B90BFC) + ((__SEGGER_RTL_I32)i1 >> 2));

      q3 = __SEGGER_RTL_SIGN_EXTEND(q1, 3);
      q2 = (int)(q1 - q3) >> 3;

      i0 = __SEGGER_RTL_float32_Exp_std_2tojby8[q3 + 4];
      i0 += __SEGGER_RTL_SMULL_HI((__SEGGER_RTL_I32)i1 >> 1, i0);

      if ((int)q2 <= 0) {
        q2 = 0u - q2;
        if (q2 > 31) {
          i0 = __SEGGER_RTL_U32_C(0xC0000001);
        } else {
          i0 = __SEGGER_RTL_U32_C(0xC0000000) + ((__SEGGER_RTL_I32)i0 >> q2);
        }
        q2 = 30;
      } else {
        if (q2 < 30) {
          i0 += __SEGGER_RTL_I32_C(0xC0000000) >> q2;
        } else {
          i0 += __SEGGER_RTL_I32_C(0xC0000000) >> 30;
        }
        q2 = 30 - q2;
      }
    }



    i1 = __SEGGER_RTL_ABS_I32(i0);



#if defined(__SEGGER_RTL_CLZ_U32) && !defined(__SEGGER_RTL_CLZ_U32_SYNTHESIZED)



    q1 = __SEGGER_RTL_CLZ_U32(i1);
    i1 <<= q1 - 1;
    q1 = 157 - q2 - q1;

#else
# 10544 "./floatops.c"
    if ((i1 & __SEGGER_RTL_U32_C(0x40000000)) != 0) {
      q1 = 157 - q2 - 1;
    } else if ((i1 & __SEGGER_RTL_U32_C(0x20000000)) != 0) {
      i1 <<= 1;
      q1 = 157 - q2 - 2;
    } else {
      i1 <<= 2;
      q1 = 157 - q2 - 3;
    }

#endif



    return __SEGGER_RTL_BitcastToF32(__SEGGER_RTL_PACK(q1, i1, i0));
  }
}
# 10578 "./floatops.c"
static __SEGGER_RTL_INLINE double __SEGGER_RTL_float64_exp2_inline(double x) {
  return SEGGER_EXP(SEGGER_MUL(M_LN2_DBL, x));
}
# 10598 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_exp2_inline(float x) {
  return SEGGER_EXPF(SEGGER_MULF(M_LN2_FLT, x));
}
# 10621 "./floatops.c"
static __SEGGER_RTL_INLINE double __SEGGER_RTL_float64_exp10_inline(double x) {
  return SEGGER_EXP(SEGGER_MUL(M_LN10_DBL, x));
}
# 10644 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_exp10_inline(float x) {
  return SEGGER_EXPF(SEGGER_MULF(M_LN10_FLT, x));
}
# 10665 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_log_scaled_integer(float x) {
  __SEGGER_RTL_U32 x0, x1, x2, x3;
  unsigned q0, q1, q2;
  unsigned j;

  x1 = x0 = __SEGGER_RTL_BitcastToU32(x);



  x0 <<= 1;



  if (__SEGGER_RTL_UNLIKELY(x0 == 0)) {
    return __SEGGER_RTL_BitcastToF32(K_MINUS_INF_U32);
  }



  q0 = x0 >> 24;
  if (__SEGGER_RTL_UNLIKELY(q0 == 0xff)) {
    if (__SEGGER_RTL_U32_C(0x7F800000) >= x1) {



      return x;

    } else {



      return __SEGGER_RTL_BitcastToF32(x1 | __SEGGER_RTL_U32_C(0x400000));
    }
  }



  if (__SEGGER_RTL_UNLIKELY(x1 & __SEGGER_RTL_U32_C(0x80000000))) {



    return K_NAN_F32;
  }



  x0 = x1 & __SEGGER_RTL_U32_C(0xFFFFFF);



  if (q0) {



    x0 = x0 | __SEGGER_RTL_U32_C(0x800000);
    --q0;
  }







  q1 = __SEGGER_RTL_CLZ_U32(x0);
  x0 = x0 << q1 >> 1;






  x3 = 31 - 0x95 - q1 + q0;
# 10748 "./floatops.c"
  j = (__SEGGER_RTL_I32)((x0 & __SEGGER_RTL_U32_C(0x3F000000)) + __SEGGER_RTL_U32_C(0x02000000)) >> 26;
  if (j > 7) {
    ++x3;
  }




  x0 = ((x0 >> 7) * __SEGGER_RTL_logf_1_over_1_plus_j_by_16[j]) << 3;
  q0 = __SEGGER_RTL_CLZ_U32(__SEGGER_RTL_ABSX_I32(x0));
  x0 <<= q0-1;



  if (q0 < 31) {





    q2 = q0 + 1;
    x1 = __SEGGER_RTL_SMULL_HI(x0, __SEGGER_RTL_U32_C(0xEAA2199C));
    x1 = __SEGGER_RTL_SMULL_HI(x0, ((__SEGGER_RTL_I32)x1 >> q2) + __SEGGER_RTL_I32_C(0x19A1A9AA));
    x1 = __SEGGER_RTL_SMULL_HI(x0, ((__SEGGER_RTL_I32)x1 >> q2) - __SEGGER_RTL_I32_C(0x1FFFFEE4));
    x1 = __SEGGER_RTL_SMULL_HI(x0, ((__SEGGER_RTL_I32)x1 >> q2) + __SEGGER_RTL_I32_C(0x2AAAA9E1));
    x1 = __SEGGER_RTL_SMULL_HI(x0, ((__SEGGER_RTL_I32)x1 >> q2) - __SEGGER_RTL_I32_C(0x40000000));
    x1 = __SEGGER_RTL_SMULL_HI(x0, x1);



    if (j & 0xF) {
      x1 = ((__SEGGER_RTL_I32)x1 >> q0);
      q0 = __SEGGER_RTL_logf_log_1_plus_j_by_16.Scale[j];
      q2 = q0 - q2;
      x1 += (x0 & (~0u >> q2));
      q2 = 32 - q2;
      x0 = __SEGGER_RTL_logf_log_1_plus_j_by_16.Value[j] + ((__SEGGER_RTL_I32)x0 >> q2) + ((__SEGGER_RTL_I32)x1 >> q2);
    } else {

      x0 = ((__SEGGER_RTL_I32)x0 >> 1) + ((__SEGGER_RTL_I32)x1 >> q2);
      q0 += 32;
    }
  } else {



    if (x3 == 0) {
      return 0;
    }
    q0 += 32;
  }

  if (x3) {




    q2 = __SEGGER_RTL_CLZ_U32(__SEGGER_RTL_ABS_I32(x3));
    __SEGGER_RTL_SMULL(x1, x2, __SEGGER_RTL_U32_C(0x58B90BFC), x3 << (q2 - 2));



    q2 -= 3;
    x3 *= ((__SEGGER_RTL_I32)(-0x172)>>1);
    x3 += x1 >> (q2-2 - 8);



    if (q0 < q2+32) {



      q1 = q0 - q2;
      x2 += (__SEGGER_RTL_I32)x0 >> q1;



      x0 &= ~__SEGGER_RTL_U32_C(0) >> (32-q1);



      if (q0 < 32+10) {
        x3 += x0 << (32+10 - q0);
      } else {
        x3 += (__SEGGER_RTL_I32)x0 >> (q0 - 32 - 10);
      }
    } else {
      x3 += (__SEGGER_RTL_I32)x0 >> (q0 - 32 - 10);
    }



    x0 = x2 + ((__SEGGER_RTL_I32)x3 >> (32 + 10 - q2));
    q0 = q2;
  }




  x0 = x0 + (x0 >> 31);





  x1 = __SEGGER_RTL_ABS_I32(x0);
  q1 = __SEGGER_RTL_CLZ_U32(x1);
  x1 = x1 << q1 >> 1;



  q0 = 0x9D - q0 - q1;
  return __SEGGER_RTL_BitcastToF32(__SEGGER_RTL_PACK(q0, x1, x0));
}
# 10884 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_log_fpu(float x) {
  float r;
  int memn;
  int n;

  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_isspecial_or_negative(x))) {
    if (__SEGGER_RTL_float32_isnan_inline(x)) {
      return x;
    } else if (__SEGGER_RTL_float32_putative_iszero(x)) {
      return __SEGGER_RTL_BitcastToF32(K_MINUS_INF_U32);
    } else if (__SEGGER_RTL_float32_lt_rhs_positive(x, 0)) {
      return K_NAN_F32;
    } else {
      return x;
    }
  }



  x = SEGGER_FREXPF(x, &memn);
  n = memn;

  if (__SEGGER_RTL_float32_gt_rhs_positive(x, M_SQRT_HALF_FLT)) {
#if __SEGGER_RTL_FP_HW > 0
    x = SEGGER_DIVF(SEGGER_SUBF(x, 1), SEGGER_FMAF(0.5f, x, 0.5f));
#else
    x = SEGGER_DIVF(SEGGER_SUBF(x, 1), SEGGER_ADDF(SEGGER_DIV2F(x), 0.5f));
#endif
  } else {
    n -= 1;
    x = SEGGER_SUBF(x, 0.5f);
    x = SEGGER_DIVF(x, SEGGER_FMAF(0.5f, x, 0.5f));
  }

  r = SEGGER_MULF(x, x);
  x = SEGGER_FMAF(x,
                  SEGGER_DIVF(SEGGER_MULF(r, -0.5527074855E+0f),
                              SEGGER_ADDF(r, -0.6632718214E+1f)),
                  x);
  r = SEGGER_I2F(n);

  return SEGGER_FMAF(r, 355.0f/512.0f, SEGGER_FMAF(r, -2.121944400546905827679e-4f, x));
}
# 10945 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_log_inline(float x) {
#if __SEGGER_RTL_SCALED_INTEGER >= 1
  return __SEGGER_RTL_float32_log_scaled_integer(x);
#else
  return __SEGGER_RTL_float32_log_fpu(x);
#endif
}
# 10970 "./floatops.c"
static float __SEGGER_RTL_NEVER_INLINE __SEGGER_RTL_float32_log_outline(float x) {
  return __SEGGER_RTL_float32_log_inline(x);
}
# 10991 "./floatops.c"
static __SEGGER_RTL_INLINE double __SEGGER_RTL_float64_log_inline(double x) {
  double r;
  int memn;
  int n;

  if (__SEGGER_RTL_float64_isspecial_or_negative(x)) {
    if (__SEGGER_RTL_float64_isnan_inline(x)) {
      return x;
    } else if (__SEGGER_RTL_float64_putative_iszero(x)) {
      return __SEGGER_RTL_BitcastToF64(FLOAT64_SIGN_MASK | K_INF_U64);
    } else if (__SEGGER_RTL_float64_lt_rhs_positive(x, 0)) {
      return K_NAN_F64;
    } else {
      return x;
    }
  }

  x = SEGGER_FREXP(x, &memn);
  n = memn;

  if (__SEGGER_RTL_float64_gt_rhs_positive(x, M_SQRT_HALF_DBL)) {
    x = SEGGER_DIV(SEGGER_ADD(x, -1), SEGGER_ADD(SEGGER_DIV2(x), 0.5));
  } else {
    n -= 1;
    x = SEGGER_SUB(x, 0.5);
    x = SEGGER_DIV(x, SEGGER_ADD(SEGGER_DIV2(x), 0.5));
  }

  r = SEGGER_MUL(x, x);
  r = SEGGER_MUL(r,
                 SEGGER_DIV(SEGGER_ADD(__SEGGER_RTL_float64_PolyEvalP_2(r, __SEGGER_RTL_float64_Log.Poly.P, K_LOG_P_DBL), -0.64124943423745581147e2),
                            __SEGGER_RTL_float64_PolyEvalQ_3(r, __SEGGER_RTL_float64_Log.Poly.Q, K_LOG_Q_DBL)));
  x = SEGGER_FMA(x, r, x);
  r = SEGGER_I2D(n);

  return SEGGER_FMA(r, 355.0/512.0, SEGGER_FMA(r, -2.121944400546905827679e-4, x));
}
# 11046 "./floatops.c"
static double __SEGGER_RTL_NEVER_INLINE __SEGGER_RTL_float64_log_outline(double x) {
  return __SEGGER_RTL_float64_log_inline(x);
}
# 11071 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_log1p_inline(float x) {
  float w;

  w = SEGGER_ADDF(1, x);
  if (__SEGGER_RTL_float32_eq_bitwise(w, 1)) {
    return x;
  } else {
    return SEGGER_MULF(SEGGER_LOGF(w), SEGGER_DIVF(x, SEGGER_SUBF(w, 1)));
  }
}
# 11103 "./floatops.c"
static float __SEGGER_RTL_NEVER_INLINE __SEGGER_RTL_float32_log1p_outline(float x) {
  return __SEGGER_RTL_float32_log1p_inline(x);
}
# 11128 "./floatops.c"
static __SEGGER_RTL_INLINE double __SEGGER_RTL_float64_log1p_inline(double x) {
  double w;

  w = SEGGER_ADD(1, x);
  if (__SEGGER_RTL_float64_eq_finite(w, 1)) {
    return x;
  } else {
    return SEGGER_MUL(SEGGER_LOG(w), SEGGER_DIV(x, SEGGER_SUB(w, 1)));
  }
}
# 11160 "./floatops.c"
static double __SEGGER_RTL_NEVER_INLINE __SEGGER_RTL_float64_log1p_outline(double x) {
  return __SEGGER_RTL_float64_log1p_inline(x);
}
# 11181 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_log10_inline(float x) {
  return SEGGER_MULF(SEGGER_LOGF(x), M_INV_LN10_FLT);
}
# 11202 "./floatops.c"
static __SEGGER_RTL_INLINE double __SEGGER_RTL_float64_log10_inline(double x) {
  return SEGGER_DIV(SEGGER_LOG(x), M_LN10_DBL);
}
# 11223 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_log2(float x) {
  return SEGGER_MULF(SEGGER_LOGF(x), M_INV_LN2_FLT);
}
# 11244 "./floatops.c"
static __SEGGER_RTL_INLINE double __SEGGER_RTL_float64_log2(double x) {
  return SEGGER_DIV(SEGGER_LOG(x), M_LN2_DBL);
}
# 11264 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_sincos_fpu(float x, float y, float sign, int coscase) {
  float xn;
  float f;
  float g;
  int n;



  n = SEGGER_F2I(SEGGER_DIVF(SEGGER_ADDF(y, (float)M_PI_2), (float)M_PI));
  xn = SEGGER_I2F(n);
  if ((n & 1) != 0) {
    sign = -sign;
  }
  if (coscase) {
    xn = SEGGER_SUBF(xn, 0.5f);
  }

  f = SEGGER_ADDF(SEGGER_ADDF(x, SEGGER_MULF(xn, -3.1416015625f)),
                  SEGGER_MULF(xn, 8.908910206761537356617e-6f));

  if (__SEGGER_RTL_float32_ge_finite(SEGGER_FABSF(f), 1.e-10f)) {

    g = SEGGER_MULF(f, f);
    f = SEGGER_FMAF(__SEGGER_RTL_float32_PolyEvalP_5(g,
                                                     __SEGGER_RTL_float32_SinCos.Poly.P,
                                                     K_SINCOS_P_FLT),
                    f,
                    f);
  }

  return __SEGGER_RTL_float32_signbit_xor(f, sign);
}
# 11307 "./floatops.c"
static __SEGGER_RTL_INLINE unsigned __SEGGER_RTL_float32_SinReduce(__SEGGER_RTL_U32 *pI, unsigned *pQ) {
  __SEGGER_RTL_U32 d3, d2, d1, d0;
  __SEGGER_RTL_U32 i0;
  __SEGGER_RTL_U32 x0, x1;
  unsigned q0, q1;
  const __SEGGER_RTL_U16 * pPi;

  i0 = *pI;
  q0 = *pQ;





  if ((int)q0 >= 16) {






    x0 = 0;
    __SEGGER_RTL_SMULL(d2, d1, __SEGGER_RTL_U32_C(0x27220A95), i0);
    __SEGGER_RTL_SMLAL(d1, x0, __SEGGER_RTL_U32_C(0x517CC1B7), i0);




    q1 = 32 - (q0 - 4);
    d0 = (__SEGGER_RTL_I32)x0 << q1 >> q1;
    x0 = (__SEGGER_RTL_I32)(x0 - d0) >> (q0 - 4);

    if ((d0 ^ ((__SEGGER_RTL_I32)d0 >> 31)) == 0) {






      d0 = (d0 << 30) | d1 >> 2;
      d1 = (d1 << 30) | d2 >> 2;
      q0 += 30;
    }



    q1 = __SEGGER_RTL_CLZ_U32(__SEGGER_RTL_ABS_I32(d0)) - 1;
    i0 = __SEGGER_RTL_LSL_U64_HI(d0, d1, q1);
    q0 = q0 + q1 - 2;



  } else {





    if ((int)q0 <= 0) {
      x0 = (int)(~q0) >> 4;
    } else {
      x0 = 0;
    }



    d1 = d0 = 0;
    pPi = &__SEGGER_RTL_inv_pi[x0+1];
    __SEGGER_RTL_UMULL(d3, d2, i0, pPi[5] | ((__SEGGER_RTL_U32)(pPi[4]) << 16));
    __SEGGER_RTL_UMLAL(d2, d1, i0, pPi[3] | ((__SEGGER_RTL_U32)(pPi[2]) << 16));
    __SEGGER_RTL_UMLAL(d1, d0, i0, pPi[1] | ((__SEGGER_RTL_U32)(pPi[0]) << 16));

    x0 <<= 4;
    x0 = 35 - x0 - q0;
    x1 = (__SEGGER_RTL_I32)x0 >> 5;
    q0 = x0 - (x1 << 5);






    q1 = 31 - q0;
    if ((int)q0 < 5) {
      i0 = d1;
      x0 = (d0 << q0 << 1) | (i0 >> q1);
      d1 = d2; d2 = d3;
    } else {
      if (x1 != 0) {
        d0 = d1; d1 = d2; d2 = d3;
      }
      i0 = d0;
      x0 = i0 >> q1;
    }
    i0 = (i0 << q0 << 1) | (d1 >> q1);
    d1 = (d1 << q0 << 1) | (d2 >> q1);
    x0 -= (__SEGGER_RTL_I32)i0 >> 31;
    q0 = __SEGGER_RTL_CLZ_U32(__SEGGER_RTL_ABS_I32(i0));
    i0 = i0 << (q0 - 1) | (d1 >> (32 - q0) >> 1);
    q0 = q0 + 33;
    x0 = x0 & 31;
  }

  *pI = i0;
  *pQ = q0;

  return x0;
}
# 11431 "./floatops.c"
static __SEGGER_RTL_INLINE void __SEGGER_RTL_float32_SinKernel(__SEGGER_RTL_U32 x0,
                                                               __SEGGER_RTL_U32 i0,
                                                               __SEGGER_RTL_U32 q0,
                                                               __SEGGER_RTL_U32 * pI,
                                                               unsigned * pQ,
                                                               __SEGGER_RTL_U32 * pSign) {
  __SEGGER_RTL_U32 i1, i2, i3;
  __SEGGER_RTL_U32 q1, q2;
  __SEGGER_RTL_U32 Pr, Qr;
  __SEGGER_RTL_U32 Sj_i, Cj_i;
  __SEGGER_RTL_U32 Sj_q, Cj_q;
  const SEGGER_RTL_SIN_COS_PARA *pPara;
# 11459 "./floatops.c"
  __SEGGER_RTL_SMULL(i1, i0, i0, __SEGGER_RTL_U32_C(0x6487ED51));
  i0 = (i0<<1) + (((i1 >> 30) + 1) >> 1);

  q2 = q0 - 32;
  i1 = (int)i0 >> q2;






  i1 = __SEGGER_RTL_SMULL_HI(i1, i1);
  Pr = __SEGGER_RTL_SMULL_HI(i1, __SEGGER_RTL_U32_C(0x0443E8E7));
  Pr = __SEGGER_RTL_SMULL_HI(i0, Pr - __SEGGER_RTL_U32_C(0x5555550E));

  if ((x0 & 15) == 0) {







    __SEGGER_RTL_SMULL(i2, i1, i0, i0);
    i1 = (i1 << 1) + ((__SEGGER_RTL_I32)((i2 >> 30) + 1) >> 1);
    i1 = __SEGGER_RTL_SMULL_HI(Pr, i1);
    q1 = (q0 << 1) - 62;
    i0 = i0 + __SEGGER_RTL_SAFE_ASR_I32(i1, q1);

  } else {



    Qr = __SEGGER_RTL_SMULL_HI(i1, __SEGGER_RTL_U32_C(0x0AA96B54)) - __SEGGER_RTL_U32_C(0x7FFFFF07);



    pPara = &__SEGGER_RTL_float32_SinCosParas[x0 & 15];
    Sj_i = pPara->S_value;
    Sj_q = pPara->S_scale;
    Cj_i = pPara->C_value;
    Cj_q = pPara->C_scale + q0;



    i1 = __SEGGER_RTL_SMULL_HI(Pr, Cj_i);
    i3 = __SEGGER_RTL_SMULL_HI(Qr, Sj_i);
    i3 = i3 + ((__SEGGER_RTL_I32)i1 >> (Cj_q - Sj_q + 1));
    i2 = __SEGGER_RTL_SMULL_HI(i0, i0);
    i3 = __SEGGER_RTL_SMULL_HI(i3, i2);
    q1 = Sj_q + (q2 << 1);
    i2 = __SEGGER_RTL_SMULL_HI(i0, Cj_i);
    if (i2 == 0) {
      Cj_q = q1;
    }
    i2 = i2 + ((__SEGGER_RTL_I32)i3 >> (q1 - Cj_q));
    i0 = Sj_i + __SEGGER_RTL_SAFE_ASR_I32(i2, Cj_q - Sj_q);
    q0 = Sj_q;
  }

  i1 = __SEGGER_RTL_ABS_I32(i0);



  *pI = i1;
  *pQ = (unsigned)q0;
  *pSign = (x0 << (31-4)) ^ i0;
}
# 11548 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_sin_scaled_integer(float x) {
  __SEGGER_RTL_U32 x0;
  __SEGGER_RTL_U32 i0, i1, i2;
  unsigned q0, q1;
  __SEGGER_RTL_U32 sign;
  __SEGGER_RTL_U32 sin_sign;

  x0 = __SEGGER_RTL_BitcastToU32(x);



  q0 = FLOAT32_EXPONENT(x0);





  if (q0 <= 114) {
    return x;
  }




  sign = x0;
  i0 = (x0 & FLOAT32_SIGNIFICAND_MASK) | FLOAT32_HIDDEN_MASK;
  q0 = 150 - q0;



  if (__SEGGER_RTL_UNLIKELY(q0 == 150u - 255u)) {




    return __SEGGER_RTL_BitcastToF32(x0 | __SEGGER_RTL_U32_C(0x400000));

  } else if ((int)q0 >= 25) {





    i0 <<= 7;
    q0 += 7;



    i1 = (__SEGGER_RTL_I32)i0 >> (q0 - 32);
    i1 = __SEGGER_RTL_SMULL_HI(i1, i1);
    i2 = __SEGGER_RTL_SMULL_HI(i1, -__SEGGER_RTL_I32_C(0x0019D562));
    i2 = __SEGGER_RTL_SMULL_HI(i1, +__SEGGER_RTL_I32_C(0x04443DDE) + i2);
    i2 = __SEGGER_RTL_SMULL_HI(i1, -__SEGGER_RTL_I32_C(0x55555512) + i2);
    i2 = __SEGGER_RTL_SMULL_HI(i0, i2);
    i0 = i0 + ((__SEGGER_RTL_I32)(i2+1) >> 1);



    q1 = __SEGGER_RTL_CLZ_U32(i0);
    i0 <<= (q1-1);
    q0 += q1;

    return __SEGGER_RTL_BitcastToF32(__SEGGER_RTL_PACK(157 - q0, i0, sign));

  } else {





    x0 = __SEGGER_RTL_float32_SinReduce(&i0, &q0);
    __SEGGER_RTL_float32_SinKernel(x0, i0, q0, &i1, &q1, &sin_sign);
    q0 = __SEGGER_RTL_CLZ_U32(i1);






    return __SEGGER_RTL_BitcastToF32(__SEGGER_RTL_PACK(157 - (q0+q1), i1 << (q0-1), sign ^ sin_sign));
  }
}
# 11646 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE float __SEGGER_RTL_float32_sin_inline(float x) {
#if __SEGGER_RTL_SCALED_INTEGER >= 1
  return __SEGGER_RTL_float32_sin_scaled_integer(x);
#else
  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_isspecial(x))) {
    if (!__SEGGER_RTL_float32_isfinite_inline(x)) {
      return K_NAN_F32;
    } else {
      return x;
    }
  }
  if (__SEGGER_RTL_float32_lt_rhs_positive(x, 0)) {
    return __SEGGER_RTL_float32_sincos_fpu(-x, -x, -0.0f, 0);
  } else {
    return __SEGGER_RTL_float32_sincos_fpu(x, x, 0.0f, 0);
  }
#endif
}
# 11680 "./floatops.c"
static __SEGGER_RTL_NEVER_INLINE float __SEGGER_RTL_float32_sin_outline(float x) {
  return __SEGGER_RTL_float32_sin_inline(x);
}
# 11699 "./floatops.c"
static __SEGGER_RTL_INLINE double __SEGGER_RTL_float64_sin_inline(double x) {
  int n;
  double sign;
  double g;

  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_isspecial(x))) {
    if (!__SEGGER_RTL_float64_isfinite_inline(x)) {
      return K_NAN_F64;
    } else {
      return x;
    }
  }

  sign = x;
  x = SEGGER_FABS(x);



  n = SEGGER_D2I(SEGGER_FMA(x, M_INV_PI, 0.5));
  if (n & 1) {
    sign = SEGGER_NEG(sign);
  }
  if (n) {
    x = SEGGER_ADD(SEGGER_SUB(x, SEGGER_MUL(SEGGER_I2D(n), 3.1416015625)),
                   SEGGER_MUL(SEGGER_I2D(n), 8.908910206761537356617e-6));
  }



  g = SEGGER_MUL(x, x);
  x = SEGGER_FMA(__SEGGER_RTL_float64_PolyEvalP_8(g,
                                                  __SEGGER_RTL_float64_SinCos.Poly.P,
                                                  K_SINCOS_P_DBL),
                 x,
                 x);

  return __SEGGER_RTL_float64_signbit_xor(x, sign);
}
# 11753 "./floatops.c"
static __SEGGER_RTL_NEVER_INLINE double __SEGGER_RTL_float64_sin_outline(double x) {
  return __SEGGER_RTL_float64_sin_inline(x);
}
# 11772 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_cos_scaled_integer(float x) {
  __SEGGER_RTL_U32 x0;
  __SEGGER_RTL_U32 i0, i1;
  unsigned q0, q1;
  __SEGGER_RTL_U32 cos_sign;

  x0 = __SEGGER_RTL_BitcastToU32(x);



  q0 = FLOAT32_EXPONENT(x0);



  if (q0 <= 114) {
    return 1.0;
  }




  i0 = (x0 & FLOAT32_SIGNIFICAND_MASK) | FLOAT32_HIDDEN_MASK;
  q0 = 150 - q0;



  if (q0 == 150u - 255u) {




    return __SEGGER_RTL_BitcastToF32(x0 | __SEGGER_RTL_U32_C(0x400000));

  } else if ((int)q0 >= 25) {





    i0 = ((__SEGGER_RTL_I32)i0 << 7) >> (7 + q0 - 32);
    i0 = __SEGGER_RTL_SMULL_HI(i0, i0);
    i1 = __SEGGER_RTL_SMULL_HI(i0, -__SEGGER_RTL_I32_C(0x005A3E8B));
    i1 = __SEGGER_RTL_SMULL_HI(i0, +__SEGGER_RTL_I32_C(0x0AAA8DD5) + i1);
    i1 = __SEGGER_RTL_SMULL_HI(i0, -__SEGGER_RTL_I32_C(0x7FFFFED0) + i1);
    i1 = __SEGGER_RTL_U32_C(0x40000000) + ((__SEGGER_RTL_I32)(i1+2) >> 2);

    return __SEGGER_RTL_BitcastToF32(__SEGGER_RTL_PACK(0x7D, i1 << 1, 0));

  } else {





    x0 = (__SEGGER_RTL_float32_SinReduce(&i0, &q0) + 8) & 31;
    __SEGGER_RTL_float32_SinKernel(x0, i0, q0, &i1, &q1, &cos_sign);
    q0 = __SEGGER_RTL_CLZ_U32(i1);






    return __SEGGER_RTL_BitcastToF32(__SEGGER_RTL_PACK(157 - (q0+q1), i1 << (q0-1), cos_sign));
  }
}
# 11854 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE float __SEGGER_RTL_float32_cos_inline(float x) {
#if __SEGGER_RTL_SCALED_INTEGER >= 1
  return __SEGGER_RTL_float32_cos_scaled_integer(x);
#else

  if (!__SEGGER_RTL_float32_isfinite_inline(x)) {
    return K_NAN_F32;
  }

  if (__SEGGER_RTL_float32_lt_rhs_positive(x, 0)) {
    return __SEGGER_RTL_float32_sincos_fpu(SEGGER_NEGF(x), SEGGER_SUBF((float)M_PI_2, x), 1, 1);
  } else {
    return __SEGGER_RTL_float32_sincos_fpu(x, SEGGER_ADDF((float)M_PI_2, x), 1, 1);
  }
#endif
}
# 11886 "./floatops.c"
static __SEGGER_RTL_NEVER_INLINE float __SEGGER_RTL_float32_cos_outline(float x) {
  return __SEGGER_RTL_float32_cos_inline(x);
}
# 11905 "./floatops.c"
static __SEGGER_RTL_INLINE double __SEGGER_RTL_float64_cos_inline(double x) {
  double g;
  double xn;
  int n;

  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_isspecial(x))) {
    if (!__SEGGER_RTL_float64_isfinite_inline(x)) {
      return K_NAN_F64;
    } else {
      return 1;
    }
  }

  x = SEGGER_FABS(x);
  n = SEGGER_D2I(SEGGER_FMA(SEGGER_ADD(x, M_PI/2), M_INV_PI, 0.5));
  xn = SEGGER_SUB(SEGGER_I2D(n), 0.5);
  x = SEGGER_ADD(SEGGER_SUB(x, SEGGER_MUL(xn, 3.1416015625)),
                  SEGGER_MUL(xn, 8.908910206761537356617e-6));

  g = SEGGER_MUL(x, x);
  x = SEGGER_FMA(__SEGGER_RTL_float64_PolyEvalP_8(g,
                                                  __SEGGER_RTL_float64_SinCos.Poly.P,
                                                  K_SINCOS_P_DBL),
                 x,
                 x);

  return (n & 1) ? SEGGER_NEG(x) : x;
}
# 11949 "./floatops.c"
static __SEGGER_RTL_NEVER_INLINE double __SEGGER_RTL_float64_cos_outline(double x) {
  return __SEGGER_RTL_float64_cos_inline(x);
}
# 11969 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_tan_scaled_integer(float x) {
  __SEGGER_RTL_U32 x0;
  __SEGGER_RTL_U32 i0, i1, i2;
  unsigned q0, q1;
  __SEGGER_RTL_U32 sign;

  x0 = __SEGGER_RTL_BitcastToU32(x);



  q0 = x0 << 1 >> 24;





  if (q0 <= 114) {
    return x;
  }




  sign = x0;
  i0 = (x0 & __SEGGER_RTL_U32_C(0xFFFFFF)) | __SEGGER_RTL_U32_C(0x800000);
  q0 = 150 - q0;



  if (__SEGGER_RTL_UNLIKELY((int)q0 == -0x69)) {




    return __SEGGER_RTL_BitcastToF32(x0 | __SEGGER_RTL_U32_C(0x400000));

  } else if ((int)q0 >= 25) {





    i0 <<= 7;
    q0 += 7;



    q1 = (q0 - 32) << 1;
    i2 = __SEGGER_RTL_SMULL_HI(i0, i0);
    i1 = __SEGGER_RTL_SMULL_HI(i2, __SEGGER_RTL_I32_C(0x0319B19E));
    i1 = __SEGGER_RTL_SMULL_HI(i2, __SEGGER_RTL_I32_C(0x055ADD78) + ((__SEGGER_RTL_I32)i1 >> q1));
    i1 = __SEGGER_RTL_SMULL_HI(i2, __SEGGER_RTL_I32_C(0x0DD8E7C1) + ((__SEGGER_RTL_I32)i1 >> q1));
    i1 = __SEGGER_RTL_SMULL_HI(i2, __SEGGER_RTL_I32_C(0x2221AFA6) + ((__SEGGER_RTL_I32)i1 >> q1));
    i1 = __SEGGER_RTL_SMULL_HI(i2, __SEGGER_RTL_I32_C(0x55555764) + ((__SEGGER_RTL_I32)i1 >> q1));
    i1 = __SEGGER_RTL_SMULL_HI(i1, i0);




    i0 += (__SEGGER_RTL_I32)i1 >> q1;
    q1 = i0 >> 31;
    i0 >>= q1;
    q0 -= q1;



    q1 = __SEGGER_RTL_CLZ_U32(i0);
    i0 <<= q1-1;
    q0 += q1;

    return __SEGGER_RTL_BitcastToF32(__SEGGER_RTL_PACK(157-q0, i0, sign));

  } else {



    __SEGGER_RTL_U32 sin_i0, cos_i0, tan_i0;
    unsigned sin_q0, cos_q0, tan_q0;
    __SEGGER_RTL_U32 sin_sign, cos_sign;





    x0 = __SEGGER_RTL_float32_SinReduce(&i0, &q0);
    __SEGGER_RTL_float32_SinKernel(x0, i0, q0, &sin_i0, &sin_q0, &sin_sign);
    __SEGGER_RTL_float32_SinKernel((x0+8) & 31, i0, q0, &cos_i0, &cos_q0, &cos_sign);



    q0 = __SEGGER_RTL_CLZ_U32(cos_i0);
    cos_i0 <<= q0;
    cos_q0 += q0;



    tan_i0 = __SEGGER_RTL_Div64by32_Moeller(sin_i0, cos_i0) >> 1;
    tan_q0 = sin_q0 - cos_q0 + 32;



    q0 = __SEGGER_RTL_CLZ_U32(tan_i0) - 1;
    tan_i0 <<= q0;
    tan_q0 += q0;

    return __SEGGER_RTL_BitcastToF32(__SEGGER_RTL_PACK(157 - tan_q0, tan_i0, sign ^ sin_sign ^ cos_sign));
  }
}
# 12094 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_tan_fpu(float x) {
  int n;
  float f, y, xnum, xden;

  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_isspecial(x))) {
    if (!__SEGGER_RTL_float32_isfinite_inline(x)) {
      return K_NAN_F32;
    } else {
      return x;
    }
  }

  y = SEGGER_FABSF(x);
  n = SEGGER_F2I(SEGGER_DIVF(SEGGER_ADDF(SEGGER_MUL2F(y), (float)M_PI_2), (float)M_PI));
  if (__SEGGER_RTL_float32_lt_rhs_positive(x, 0)) {
    n = -n;
  }

  xnum = SEGGER_I2F(n);
  f = SEGGER_FMAF(xnum, 4.454455103380768678308e-6f, SEGGER_FMAF(xnum, -1.57080078125f, x));

  if (__SEGGER_RTL_float32_gt_rhs_positive(SEGGER_FABSF(f), 1.e-10f)) {



    y = SEGGER_MULF(f, f);
    xnum = SEGGER_FMAF(__SEGGER_RTL_float32_PolyEvalP_3(y, __SEGGER_RTL_float32_Tan.Poly.P, K_TAN_P_FLT), f, f);
    xden = SEGGER_ADDF(__SEGGER_RTL_float32_PolyEvalP_4(y, __SEGGER_RTL_float32_Tan.Poly.Q, K_TAN_Q_FLT), 1);
  } else {



    xnum = f;
    xden = 1;
  }

  if (n & 1) {
    return SEGGER_NEGF(SEGGER_DIVF(xden, xnum));
  } else {
    return SEGGER_DIVF(xnum, xden);
  }
}
# 12153 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_tan_inline(float x) {
#if __SEGGER_RTL_SCALED_INTEGER >= 1
  return __SEGGER_RTL_float32_tan_scaled_integer(x);
#else
  return __SEGGER_RTL_float32_tan_fpu(x);
#endif
}
# 12177 "./floatops.c"
static __SEGGER_RTL_NEVER_INLINE float __SEGGER_RTL_float32_tan_outline(float x) {
  return __SEGGER_RTL_float32_tan_inline(x);
}
# 12197 "./floatops.c"
static __SEGGER_RTL_INLINE double __SEGGER_RTL_float64_tan_inline(double x) {
  int n;
  double f, y, xnum, xden;

  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_isspecial(x))) {
    if (!__SEGGER_RTL_float64_isfinite_inline(x)) {
      return K_NAN_F64;
    } else {
      return x;
    }
  }

  y = SEGGER_FABS(x);
  n = SEGGER_D2I(SEGGER_DIV(SEGGER_ADD(SEGGER_MUL2(y), M_PI_2), M_PI));
  xnum = __SEGGER_RTL_float64_signbit_xor(SEGGER_I2D(n), x);
  f = SEGGER_FMA(xnum, 4.454455103380768678308e-6, SEGGER_FMA(xnum, -1.57080078125, x));

  if (__SEGGER_RTL_float64_gt_rhs_positive(SEGGER_FABS(f), 1.e-10)) {
    y = SEGGER_MUL(f, f);
    xnum = SEGGER_FMA(__SEGGER_RTL_float64_PolyEvalP_3(y, __SEGGER_RTL_float64_Tan.Poly.P, K_TAN_P_DBL), f, f);
    xden = SEGGER_ADD(__SEGGER_RTL_float64_PolyEvalP_4(y, __SEGGER_RTL_float64_Tan.Poly.Q, K_TAN_Q_DBL), 1);
  } else {



    xnum = f;
    xden = 1;
  }

  if (n & 1) {
    return SEGGER_NEG(SEGGER_DIV(xden, xnum));
  } else {
    return SEGGER_DIV(xnum, xden);
  }
}
# 12249 "./floatops.c"
static __SEGGER_RTL_NEVER_INLINE double __SEGGER_RTL_float64_tan_outline(double x) {
  return __SEGGER_RTL_float64_tan_inline(x);
}






static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_asinacos_fpu(float x, int flag) {
  int i;
  float y;
  float g;

  y = SEGGER_FABSF(x);




  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_isnan_inline(y))) {
    return x;
  }

  if (__SEGGER_RTL_float32_lt_rhs_positive(y, 1.e-10f)) {
    i = flag;
  } else {
    if (__SEGGER_RTL_float32_gt_rhs_positive(y, 0.5f)) {
      if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_gt_rhs_positive(y, 1))) {
        return K_NAN_F32;
      }
      i = 1 - flag;
      g = SEGGER_DIV2F(SEGGER_ADDF(SEGGER_SUBF(0.5f, y), 0.5f));
      y = SEGGER_MULM2F(SEGGER_SQRTF(g));
    } else {
      i = flag;
      g = SEGGER_MULF(y, y);
    }
    y = SEGGER_FMAF(y,
                    SEGGER_DIVF(__SEGGER_RTL_float32_PolyEvalP_5(g, __SEGGER_RTL_float32_ASinACos.Poly.P, K_ASINACOS_P_FLT),
                                __SEGGER_RTL_float32_PolyEvalQ_5(g, __SEGGER_RTL_float32_ASinACos.Poly.Q, K_ASINACOS_Q_FLT)),
                    y);
  }

  if (!flag) {
    y = SEGGER_ADDF(SEGGER_ADDF(__SEGGER_RTL_float32_ASinACos.Quadrant.A[i], y), __SEGGER_RTL_float32_ASinACos.Quadrant.A[i]);
    y = __SEGGER_RTL_float32_signbit_xor(y, x);
  } else if (__SEGGER_RTL_float32_lt0_true(x)) {
    y = SEGGER_ADDF(SEGGER_ADDF(__SEGGER_RTL_float32_ASinACos.Quadrant.B[i], y), __SEGGER_RTL_float32_ASinACos.Quadrant.B[i]);
  } else {
    y = SEGGER_ADDF(SEGGER_SUBF(__SEGGER_RTL_float32_ASinACos.Quadrant.A[i], y), __SEGGER_RTL_float32_ASinACos.Quadrant.A[i]);
  }

  return y;
}
# 12324 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_asin_inline(float x) {
  return __SEGGER_RTL_float32_asinacos_fpu(x, 0);
}
# 12348 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_acos_scaled_integer(float x) {
  __SEGGER_RTL_U32 x0, abs_x0, p;
  __SEGGER_RTL_U32 i0, i1, i2;
  unsigned q0, q1, q2;

  x0 = __SEGGER_RTL_BitcastToU32(x);



  abs_x0 = x0 << 1;



  if (abs_x0 < __SEGGER_RTL_X2(__SEGGER_RTL_U32_C(0x32900000))) {
    return __SEGGER_RTL_BitcastToF32(K_PiOver2_U32);
  }



  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_X2(K_one_U32) <= abs_x0)) {
    if (abs_x0 == __SEGGER_RTL_X2(K_one_U32)) {



      return (x0 & FLOAT32_SIGN_MASK) ? __SEGGER_RTL_BitcastToF32(K_Pi_U32) : 0;

    } else if (abs_x0 > __SEGGER_RTL_X2(__SEGGER_RTL_U32_C(0x7F800000))) {



      return __SEGGER_RTL_BitcastToF32(x0 | __SEGGER_RTL_U32_C(0x400000));

    } else {



      return __SEGGER_RTL_BitcastToF32(__SEGGER_RTL_U32_C(0xFFC00000));
    }
  }



  i0 = ((x0 & __SEGGER_RTL_U32_C(0xFFFFFF)) | __SEGGER_RTL_U32_C(0x800000)) << 7;



  if (abs_x0 <= __SEGGER_RTL_X2(__SEGGER_RTL_U32_C(0x3F300000))) {
# 12430 "./floatops.c"
    q0 = 0x9D - 30 - (abs_x0 >> 24);



    i2 = __SEGGER_RTL_U64_L((__SEGGER_RTL_UMULL_X(i0, i0) + (__SEGGER_RTL_U32_C(1)<<30)) >> 31);
    q2 = (q0 << 1) - 3;
    __SEGGER_RTL_NORMALIZE_1UP(i2, q2);



    if (q2 >= 32) {







    } else {

      if (q0 <= 2) {
        if (q0 < 2) {



          p = __SEGGER_RTL_U32_C(0x349CBDB2);
          p = __SEGGER_RTL_U32_C(0x36A6B7FD) + __SEGGER_RTL_UMULL_HI(i2, p);
          p = __SEGGER_RTL_U32_C(0x3A8EF970) + __SEGGER_RTL_UMULL_HI(i2, p);
          p = __SEGGER_RTL_U32_C(0x3F9A4F33) + __SEGGER_RTL_UMULL_HI(i2, p);
          p = __SEGGER_RTL_U32_C(0x22BDCCC8) + (__SEGGER_RTL_UMULL_HI(i2, p) >> 1);
          p = __SEGGER_RTL_U32_C(0x262D020D) + __SEGGER_RTL_UMULL_HI(i2, p);
          p = __SEGGER_RTL_U32_C(0x2A374442) + __SEGGER_RTL_UMULL_HI(i2, p);
          p = __SEGGER_RTL_U32_C(0x2F05B99A) + __SEGGER_RTL_UMULL_HI(i2, p);
          p = __SEGGER_RTL_U32_C(0x34D0C7AC) + __SEGGER_RTL_UMULL_HI(i2, p);
          p = __SEGGER_RTL_U32_C(0x3BE77A7E) + __SEGGER_RTL_UMULL_HI(i2, p);
          p = __SEGGER_RTL_U32_C(0x225DE79E) + (__SEGGER_RTL_UMULL_HI(i2, p) >> 1);
        } else {

          p = __SEGGER_RTL_U32_C(0x225DE79E);
        }

        p = __SEGGER_RTL_UMULL_HI(i2, p);
        p = __SEGGER_RTL_UMULL_HI(i2, __SEGGER_RTL_U32_C(0x27FBCA1A) + (p >> q2));
        p = __SEGGER_RTL_UMULL_HI(i2, __SEGGER_RTL_U32_C(0x2F50F0F0) + (p >> q2));
        p = __SEGGER_RTL_UMULL_HI(i2, __SEGGER_RTL_U32_C(0x39333333) + (p >> q2));
        p = __SEGGER_RTL_UMULL_HI(i2, __SEGGER_RTL_U32_C(0x2389D89D) + (p >> q2 >> 1));
        p = __SEGGER_RTL_U32_C(0x2DD1745D) + (p >> q2);

      } else {
        p = __SEGGER_RTL_U32_C(0x2DD1745D);
      }

      p = __SEGGER_RTL_UMULL_HI(i2, p);
      p = __SEGGER_RTL_UMULL_HI(i2, __SEGGER_RTL_U32_C(0x3E38E38E) + (p >> q2));
      p = __SEGGER_RTL_UMULL_HI(i2, __SEGGER_RTL_U32_C(0x2DB6DB6D) + (p >> q2 >> 1));
      p = __SEGGER_RTL_UMULL_HI(i2, __SEGGER_RTL_U32_C(0x26666666) + (p >> q2 >> 1));
      p = __SEGGER_RTL_UMULL_HI(i2, __SEGGER_RTL_U32_C(0x2AAAAAAA) + (p >> q2 >> 1));





      i0 += __SEGGER_RTL_UMULL_HI(i0, p) >> q2;



      __SEGGER_RTL_NORMALIZE_1DN(i0, q0);
    }



    if ((__SEGGER_RTL_I32)x0 >= 0) {



      i0 = K_Pi_2Q29 - (i0 >> q0);

#if defined(__SEGGER_RTL_CLZ_U32) && !defined(__SEGGER_RTL_CLZ_U32_SYNTHESIZED)
      q1 = __SEGGER_RTL_CLZ_U32(i0) - 1;
      i0 <<= q1;
      q0 = 30 + q1;
#else




      q0 = 30;
      __SEGGER_RTL_NORMALIZE_1UP(i0, q0);
#endif

    } else {
# 12532 "./floatops.c"
      i0 = K_Pi_2Q29 + (i0 >> q0);
      q0 = 30;
      __SEGGER_RTL_NORMALIZE_1DN(i0, q0);
    }



    return __SEGGER_RTL_BitcastToF32(((__SEGGER_RTL_U32)(0x9C - q0) << 23) + ((i0 + (1<<6)) >> 7));

  } else if (abs_x0 < __SEGGER_RTL_X2(K_Sqrt_0v75_U32)) {
# 12554 "./floatops.c"
    q0 = i0 >> 27;




    i0 = (i0 << 5) + __SEGGER_RTL_U32_C(0x80000000);



    if (q0 == 11) {
# 12577 "./floatops.c"
      p = __SEGGER_RTL_SMULL_HI(i0, __SEGGER_RTL_U32_C(0x3E5EBF37));
      p = __SEGGER_RTL_SMULL_HI(i0, __SEGGER_RTL_U32_C(0x2B23C258) + ((__SEGGER_RTL_I32)p >> 3));
      p = __SEGGER_RTL_SMULL_HI(i0, __SEGGER_RTL_U32_C(0x3DAEF9E3) + ((__SEGGER_RTL_I32)p >> 2));
      p = __SEGGER_RTL_SMULL_HI(i0, __SEGGER_RTL_U32_C(0x2E2F2B1C) + ((__SEGGER_RTL_I32)p >> 3));
      p = __SEGGER_RTL_SMULL_HI(i0, __SEGGER_RTL_U32_C(0x24E94C6D) + ((__SEGGER_RTL_I32)p >> 3));
      p = __SEGGER_RTL_SMULL_HI(i0, __SEGGER_RTL_U32_C(0x215F5057) + ((__SEGGER_RTL_I32)p >> 3));
      p = __SEGGER_RTL_SMULL_HI(i0, __SEGGER_RTL_U32_C(0x2237833A) + ((__SEGGER_RTL_I32)p >> 3));
      p = __SEGGER_RTL_SMULL_HI(i0, __SEGGER_RTL_U32_C(0x2E067F20) + ((__SEGGER_RTL_I32)p >> 4));
      i0 = __SEGGER_RTL_U32_C(0x66A806EB) + ((__SEGGER_RTL_I32)p >> 2);
      q0 = 1;

    } else if (q0 == 12) {







      p = __SEGGER_RTL_SMULL_HI(i0, __SEGGER_RTL_U32_C(0x33669D21));
      p = __SEGGER_RTL_SMULL_HI(i0, __SEGGER_RTL_U32_C(0x37507EB9) + ((__SEGGER_RTL_I32)p >> 2));
      p = __SEGGER_RTL_SMULL_HI(i0, __SEGGER_RTL_U32_C(0x3D891027) + ((__SEGGER_RTL_I32)p >> 2));
      p = __SEGGER_RTL_SMULL_HI(i0, __SEGGER_RTL_U32_C(0x23D75B64) + ((__SEGGER_RTL_I32)p >> 3));
      p = __SEGGER_RTL_SMULL_HI(i0, __SEGGER_RTL_U32_C(0x2CA58F69) + ((__SEGGER_RTL_I32)p >> 2));
      p = __SEGGER_RTL_SMULL_HI(i0, __SEGGER_RTL_U32_C(0x3E7C3377) + ((__SEGGER_RTL_I32)p >> 2));
      p = __SEGGER_RTL_SMULL_HI(i0, __SEGGER_RTL_U32_C(0x3364818C) + ((__SEGGER_RTL_I32)p >> 3));
      p = __SEGGER_RTL_SMULL_HI(i0, __SEGGER_RTL_U32_C(0x33439D62) + ((__SEGGER_RTL_I32)p >> 4));
      i0 = __SEGGER_RTL_U32_C(0x72C5F212) + ((__SEGGER_RTL_I32)p >> 2);
      q0 = 1;

    } else {
# 12617 "./floatops.c"
      p = __SEGGER_RTL_SMULL_HI(i0, __SEGGER_RTL_U32_C(0x281DA51D));
      p = __SEGGER_RTL_SMULL_HI(i0, __SEGGER_RTL_U32_C(0x3DAF1D88) + ((__SEGGER_RTL_I32)p >> 1));
      p = __SEGGER_RTL_SMULL_HI(i0, __SEGGER_RTL_U32_C(0x31079BDA) + ((__SEGGER_RTL_I32)p >> 2));
      p = __SEGGER_RTL_SMULL_HI(i0, __SEGGER_RTL_U32_C(0x28CF9D7A) + ((__SEGGER_RTL_I32)p >> 2));
      p = __SEGGER_RTL_SMULL_HI(i0, __SEGGER_RTL_U32_C(0x245B89A3) + ((__SEGGER_RTL_I32)p >> 2));
      p = __SEGGER_RTL_SMULL_HI(i0, __SEGGER_RTL_U32_C(0x24465B68) + ((__SEGGER_RTL_I32)p >> 2));
      p = __SEGGER_RTL_SMULL_HI(i0, __SEGGER_RTL_U32_C(0x2BA75668) + ((__SEGGER_RTL_I32)p >> 2));
      p = __SEGGER_RTL_SMULL_HI(i0, __SEGGER_RTL_U32_C(0x3B9E9D1F) + ((__SEGGER_RTL_I32)p >> 3));
      i0 = __SEGGER_RTL_U32_C(0x40455647) + ((__SEGGER_RTL_I32)p >> 3);
      q0 = 0;
    }



    __SEGGER_RTL_NORMALIZE_1UP(i0, q0);




    if ((__SEGGER_RTL_I32)x0 >= 0) {
      i0 = (K_Pi_2Q29 - (i0 >> q0)) << 1;
      q0 = 0x9C - 30 - 1;
    } else {
      i0 = (K_Pi_2Q29 + (i0 >> q0)) >> 1;
      q0 = 0x9C - 30 + 1;
    }

    return __SEGGER_RTL_BitcastToF32(((__SEGGER_RTL_U32)q0 << 23) + ((i0 + (1<<6)) >> 7));

  } else {
# 12669 "./floatops.c"
    i0 >>= 1;



    i1 = __SEGGER_RTL_U32_C(0x40000000) - i0;
    q1 = __SEGGER_RTL_CLZ_U32(i1);
    i1 <<= q1-1;



    i0 += __SEGGER_RTL_U32_C(0x40000000);



    i1 = __SEGGER_RTL_U64_L((__SEGGER_RTL_UMULL_X(i0, i1) + (__SEGGER_RTL_U32_C(1)<<30)) >> 31);
    __SEGGER_RTL_NORMALIZE_1UP(i1, q1);
# 12715 "./floatops.c"
    q0 = q1 & 1;
    i2 = __SEGGER_RTL_rsqrt_approx_bits[(i1 >> 23) - 0x80 + (q0 << 7)] + 0x100;
    i0 = i1 << q0;



    q0 = (30 - 28) - q1;
    q0 = 30 - ((int)q0 >> 1);
    q1 = (q0 << 1) - 31 - 32;



    p = i2 * (i0 >> 8);
    i0 -= 1;
    i1 = i0 - __SEGGER_RTL_UMULL_HI(p, p);
    i1 = p + __SEGGER_RTL_U64_L(__SEGGER_RTL_UMULL_X(i2, i1) >> 9);
    i1 += (i2 * (i0 - __SEGGER_RTL_UMULL_HI(i1, i1))) >> 9;
    i1 += (i2 * (i0 - __SEGGER_RTL_UMULL_HI(i1, i1))) >> 9;
    i1 += (i2 * (i0 - __SEGGER_RTL_UMULL_HI(i1, i1))) >> 9;
    i1 = (i1 >> 1) + 1;



    i0 = __SEGGER_RTL_U64_L((__SEGGER_RTL_SMULL_X(i1, i1) + (__SEGGER_RTL_U32_C(1)<<30)) >> 31);



    p = __SEGGER_RTL_SMULL_HI(i0, __SEGGER_RTL_U32_C(0x225DE79E));
    p = __SEGGER_RTL_SMULL_HI(i0, __SEGGER_RTL_U32_C(0x27FBCA1A) + (p >> q1));
    p = __SEGGER_RTL_SMULL_HI(i0, __SEGGER_RTL_U32_C(0x2F50F0F0) + (p >> q1));
    p = __SEGGER_RTL_SMULL_HI(i0, __SEGGER_RTL_U32_C(0x39333333) + (p >> q1)) >> 1;
    p = __SEGGER_RTL_SMULL_HI(i0, __SEGGER_RTL_U32_C(0x2389D89D) + (p >> q1));
    p = __SEGGER_RTL_SMULL_HI(i0, __SEGGER_RTL_U32_C(0x2DD1745D) + (p >> q1));
    p = __SEGGER_RTL_SMULL_HI(i0, __SEGGER_RTL_U32_C(0x3E38E38E) + (p >> q1)) >> 1;
    p = __SEGGER_RTL_SMULL_HI(i0, __SEGGER_RTL_U32_C(0x2DB6DB6D) + (p >> q1)) >> 1;
    p = __SEGGER_RTL_SMULL_HI(i0, __SEGGER_RTL_U32_C(0x26666666) + (p >> q1)) >> 1;
    p = __SEGGER_RTL_SMULL_HI(i0, __SEGGER_RTL_U32_C(0x2AAAAAAA) + (p >> q1));
    p = __SEGGER_RTL_SMULL_HI(i1, p);



    i0 = i1 + ((__SEGGER_RTL_I32)p >> q1);
    __SEGGER_RTL_NORMALIZE_1DN(i0, q0);



    if ((__SEGGER_RTL_I32)x0 <= 0) {
      i0 = K_Pi_2Q29 - (i0 >> (q0-29));
      q0 = 29;
    }

    return __SEGGER_RTL_BitcastToF32(((__SEGGER_RTL_U32)(0x9C - q0) << 23) + ((i0 + (1<<6)) >> 7));
  }
}
# 12790 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_acos_fpu(float x) {
  return __SEGGER_RTL_float32_asinacos_fpu(x, 1);
}
# 12814 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_acos_inline(float x) {
#if __SEGGER_RTL_SCALED_INTEGER >= 1
  return __SEGGER_RTL_float32_acos_scaled_integer(x);
#else
  return __SEGGER_RTL_float32_acos_fpu(x);
#endif
}






static __SEGGER_RTL_INLINE double __SEGGER_RTL_float64_asinacos_fpu(double x, int cos_case) {
  int i;
  double y;
  double g;

  y = SEGGER_FABS(x);




  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_isnan_inline(y))) {
    return x;
  }

  if (__SEGGER_RTL_float64_lt_rhs_positive(y, 1.e-10)) {
    i = cos_case;
  } else {
    if (__SEGGER_RTL_float64_gt_rhs_positive(y, 0.5)) {
      if (__SEGGER_RTL_float64_gt_rhs_positive(y, 1)) {
        return K_NAN_F64;
      }

      i = 1 - cos_case;
      g = SEGGER_DIV2(SEGGER_ADD(SEGGER_SUB(0.5, y), 0.5));
      y = SEGGER_MULM2(SEGGER_SQRT(g));
    } else {
      i = cos_case;
      g = SEGGER_MUL(y, y);
    }
    y = SEGGER_FMA(y,
                   SEGGER_DIV(__SEGGER_RTL_float64_PolyEvalP_5(g, __SEGGER_RTL_float64_ASinACos.Poly.P, K_ASINACOS_P_DBL),
                              __SEGGER_RTL_float64_PolyEvalQ_5(g, __SEGGER_RTL_float64_ASinACos.Poly.Q, K_ASINACOS_Q_DBL)),
                   y);
  }
  if (!cos_case) {
    y = SEGGER_ADD(SEGGER_ADD(__SEGGER_RTL_float64_ASinACos.Quadrant.A[i], y), __SEGGER_RTL_float64_ASinACos.Quadrant.A[i]);
    y = __SEGGER_RTL_float64_signbit_xor(y, x);
  } else if (__SEGGER_RTL_float64_lt_rhs_positive(x, 0)) {
    y = SEGGER_ADD(SEGGER_ADD(__SEGGER_RTL_float64_ASinACos.Quadrant.B[i], y), __SEGGER_RTL_float64_ASinACos.Quadrant.B[i]);
  } else {
    y = SEGGER_ADD(SEGGER_SUB(__SEGGER_RTL_float64_ASinACos.Quadrant.A[i], y), __SEGGER_RTL_float64_ASinACos.Quadrant.A[i]);
  }
  return y;
}
# 12892 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE double __SEGGER_RTL_float64_asin_inline(double x) {
  return __SEGGER_RTL_float64_asinacos_fpu(x, 0);
}
# 12916 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE double __SEGGER_RTL_float64_acos_inline(double x) {
  return __SEGGER_RTL_float64_asinacos_fpu(x, 1);
}
# 12939 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE float __SEGGER_RTL_float32_atan_inline(float x) {
  int n;
  float f;
  float g;

  f = SEGGER_FABSF(x);




  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_isnan_inline(f))) {
    return x;
  }

  if (__SEGGER_RTL_float32_gt_rhs_positive(f, 1)) {
    f = SEGGER_DIVF(1, f);
    n = 2;
  } else {
    n = 0;
  }

  if (__SEGGER_RTL_float32_gt_rhs_positive(f, 0.26794919243112270647f)) {
    f = SEGGER_DIVF(
          SEGGER_ADDF(SEGGER_ADDF(SEGGER_ADDF(SEGGER_MULF(0.73205080756887729353f, f), -0.5f), -0.5f), f),
          SEGGER_ADDF(1.73205080756887729353f, f));
    ++n;
  }

  if (__SEGGER_RTL_float32_gt_rhs_positive(SEGGER_FABSF(f), 1.e-10f)) {
    g = SEGGER_MULF(f, f);
    f = SEGGER_ADDF(f, SEGGER_MULF(f, SEGGER_DIVF(__SEGGER_RTL_float32_PolyEvalP_4(g, __SEGGER_RTL_float32_ATan.Poly.P, K_ATAN_P_FLT),
                                                   __SEGGER_RTL_float32_PolyEvalQ_4(g, __SEGGER_RTL_float32_ATan.Poly.Q, K_ATAN_Q_FLT))));
  }
  if (n > 1) {
    f = SEGGER_NEGF(f);
  }
  if (n) {
    f = SEGGER_ADDF(f, __SEGGER_RTL_float32_ATan.Quadrant.A[n]);
  }
  return __SEGGER_RTL_float32_signbit_xor(f, x);
}
# 13000 "./floatops.c"
static float __SEGGER_RTL_NEVER_INLINE __SEGGER_RTL_float32_atan_outline(float x) {
  return __SEGGER_RTL_float32_atan_inline(x);
}
# 13026 "./floatops.c"
static __SEGGER_RTL_INLINE double __SEGGER_RTL_float64_atan_inline(double x) {
  int n;
  double f;
  double g;

  f = SEGGER_FABS(x);




  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_isnan_inline(f))) {
    return x;
  }

  if (__SEGGER_RTL_float64_gt_rhs_positive(f, 1)) {
    f = SEGGER_DIV(1, f);
    n = 2;
  } else {
    n = 0;
  }

  if (__SEGGER_RTL_float64_gt_rhs_positive(f, 2-M_SQRT_3)) {
    f = SEGGER_DIV(SEGGER_ADD(SEGGER_ADD(SEGGER_ADD(SEGGER_MUL(M_SQRT_3-1, f), -0.5), -0.5), f),
                   SEGGER_ADD(M_SQRT_3, f));
    ++n;
  }

  if (__SEGGER_RTL_float64_gt_rhs_positive(SEGGER_FABS(f), 1.e-10)) {
    g = SEGGER_MUL(f, f);
    f = SEGGER_ADD(f,
                   SEGGER_MUL(f,
                              SEGGER_DIV(__SEGGER_RTL_float64_PolyEvalP_4(g, __SEGGER_RTL_float64_ATan.Poly.P, K_ATAN_P_DBL),
                                         __SEGGER_RTL_float64_PolyEvalQ_4(g, __SEGGER_RTL_float64_ATan.Poly.Q, K_ATAN_Q_DBL))));
  }
  if (n > 1) {
    f = SEGGER_NEG(f);
  }
  if (n) {
    f = SEGGER_ADD(f, __SEGGER_RTL_float64_ATan.Quadrant.A[n]);
  }
  return __SEGGER_RTL_float64_signbit_xor(f, x);
}
# 13088 "./floatops.c"
static double __SEGGER_RTL_NEVER_INLINE __SEGGER_RTL_float64_atan_outline(double x) {
  return __SEGGER_RTL_float64_atan_inline(x);
}
# 13112 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_atan2_inline(float y, float x) {
  float mx;
  float my;

  mx = SEGGER_FABSF(x);
  my = SEGGER_FABSF(y);

  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_isspecial(mx) || __SEGGER_RTL_float32_isspecial(my))) {

    if (__SEGGER_RTL_float32_isnan_inline(x)) {
      return x;
    } else if (__SEGGER_RTL_float32_isnan_inline(my)) {
      return y;
    } else if (__SEGGER_RTL_float32_isinf_inline(my)) {
      if (__SEGGER_RTL_float32_isinf_inline(x)) {
        return __SEGGER_RTL_float32_signbit_xor(__SEGGER_RTL_float32_lt0_nonzero_finite(x) ? (float)M_3_PI_4 : (float)M_PI_4, y);
      } else {
        return __SEGGER_RTL_float32_signbit_xor((float)M_PI_2, y);
      }
    } else if (__SEGGER_RTL_float32_putative_iszero(y) || __SEGGER_RTL_float32_isinf_inline(x)) {
      return __SEGGER_RTL_float32_signbit_xor(__SEGGER_RTL_float32_signbit_inline(x) ? (float)M_PI : 0, y);
    } else if (__SEGGER_RTL_float32_putative_iszero(x)) {
      return __SEGGER_RTL_float32_signbit_xor((float)M_PI_2, y);
    }
  }

  if (SEGGER_LTF(mx, my) && SEGGER_LTF(SEGGER_FABSF(SEGGER_DIVF(x, y)), 1.0e-20f)) {
    return __SEGGER_RTL_float32_signbit_xor((float)M_PI_2, y);
  }

  y = SEGGER_ATANF(SEGGER_DIVF(y, x));
  if (__SEGGER_RTL_float32_lt_rhs_positive(x, 0)) {
    y = SEGGER_ADDF(y, __SEGGER_RTL_float32_lt_rhs_positive(y, 0) ? +(float)M_PI : -(float)M_PI);
  }

  return y;
}
# 13170 "./floatops.c"
static __SEGGER_RTL_NEVER_INLINE float __SEGGER_RTL_float32_atan2_outline(float y, float x) {
  return __SEGGER_RTL_float32_atan2_inline(y, x);
}
# 13194 "./floatops.c"
static __SEGGER_RTL_INLINE double __SEGGER_RTL_float64_atan2_inline(double y, double x) {
  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_isspecial(x) || __SEGGER_RTL_float64_isspecial(y))) {

    if (__SEGGER_RTL_float64_isnan_inline(x)) {
      return x;
    } else if (__SEGGER_RTL_float64_isnan_inline(y)) {
      return y;
    } else if (__SEGGER_RTL_float64_isinf_inline(y)) {
      if (__SEGGER_RTL_float64_isinf_inline(x)) {
        return __SEGGER_RTL_float64_signbit_xor(SEGGER_LT0(x) ? M_3_PI_4 : M_PI_4, y);
      } else {
        return __SEGGER_RTL_float64_signbit_xor(M_PI_2, y);
      }
    } else if (SEGGER_EQ0(y) || __SEGGER_RTL_float64_isinf_inline(x)) {
      return __SEGGER_RTL_float64_signbit_xor(__SEGGER_RTL_float64_signbit_inline(x) ? M_PI : 0, y);
    } else if (SEGGER_EQ0(x)) {
      return __SEGGER_RTL_float64_signbit_xor(M_PI_2, y);
    }
  }

  if (SEGGER_LT(SEGGER_FABS(x), SEGGER_FABS(y)) && SEGGER_LT(SEGGER_FABS(SEGGER_DIV(x, y)), 1.0e-20)) {
    return __SEGGER_RTL_float64_signbit_xor(M_PI_2, y);
  }

  y = SEGGER_ATAN(SEGGER_DIV(y, x));
  if (SEGGER_LT0(x)) {
    y = SEGGER_ADD(y, SEGGER_GT0(y) ? -M_PI : +M_PI);
  }
  return y;
}
# 13245 "./floatops.c"
static __SEGGER_RTL_NEVER_INLINE double __SEGGER_RTL_float64_atan2_outline(double y, double x) {
  return __SEGGER_RTL_float64_atan2_inline(y, x);
}
# 13267 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE float __SEGGER_RTL_float32_sinh_fpu(float x) {
  float z;

  z = SEGGER_FABSF(x);

  if (__SEGGER_RTL_float32_isspecial(z)) {
    return x;
  }

  if (__SEGGER_RTL_float32_gt_rhs_positive(z, 1)) {
    if (__SEGGER_RTL_float32_gt_rhs_positive(z, M_LN_HUGEF)) {
      return K_INF_F32;
    }
    z = SEGGER_EXPF(z);
    z = SEGGER_SUBF(SEGGER_DIV2F(z), SEGGER_DIVF(0.5f, z));
    return __SEGGER_RTL_float32_signbit_xor(z, x);
  } else if (__SEGGER_RTL_float32_lt_rhs_positive(z, 1.0e-10f)) {
    return x;
  } else {
    z = SEGGER_MULF(x, x);
    return SEGGER_FMAF(SEGGER_FMAF(SEGGER_FMAF(2.03721912945e-4f, z, 8.33028376239e-3f), z, 1.66667160211e-1f),
                       SEGGER_MULF(z, x),
                       x);
  }
}
# 13308 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE float __SEGGER_RTL_float32_sinh_scaled_integer(float x) {

  __SEGGER_RTL_U32 x0, x1, x2, x3;
  __SEGGER_RTL_U32 xsq;
  __SEGGER_RTL_U32 sign;
  __SEGGER_RTL_U32 t;
  unsigned q0, q1;
  unsigned b;

  x0 = __SEGGER_RTL_BitcastToU32(x);



  sign = x0 & __SEGGER_RTL_U32_C(0x80000000);







  q0 = 0x96 - (x0 << 1 >> 24);



  if ((int)q0 > 16) {



    if ((int)q0 >= 36) {
      return x;
    }



    if ((x0 ^ sign) > __SEGGER_RTL_U32_C(0x42B2D4FC)) {
      return __SEGGER_RTL_BitcastToF32(K_INF_U32 | sign);
    }
  } else {



    if ((x0 << 1) > __SEGGER_RTL_U32_C(0xFF000000)) {
      x0 |= __SEGGER_RTL_U32_C(0x400000);
      return __SEGGER_RTL_BitcastToF32(x0);
    }



    return __SEGGER_RTL_BitcastToF32(K_INF_U32 | sign);
  }



  x0 &= __SEGGER_RTL_U32_C(0xFFFFFF);
  x0 |= __SEGGER_RTL_U32_C(0x800000);



  if (q0 < 25) {
# 13379 "./floatops.c"
    __SEGGER_RTL_SMULL(x1, x2, __SEGGER_RTL_U32_C(0x5C551D95), x0);
    q1 = q0 - 5;
    t = __SEGGER_RTL_SIGN_EXTEND(x2, q1);



    x2 -= t;
    x1 = (t << (31 - q1)) + ((__SEGGER_RTL_I32)(1 + (x1 >> q1)) >> 1) - ((((__SEGGER_RTL_I32)x0 >> 4) * 0x52) >> q0);



    q1 = (__SEGGER_RTL_I32)x2 >> q1;
    b = __SEGGER_RTL_SIGN_EXTEND(q1, 3);
    q1 -= b;



    x1 = (__SEGGER_RTL_U32)(((__SEGGER_RTL_SMULL_X(__SEGGER_RTL_U32_C(0x58B90BFC), x1) >> 30) + 1) >> 1);
    xsq = __SEGGER_RTL_SMULL_HI(x1, x1);

    x2 = __SEGGER_RTL_SMULL_HI(xsq, __SEGGER_RTL_U32_C(0x011114AD));
    x2 = __SEGGER_RTL_SMULL_HI(xsq, __SEGGER_RTL_U32_C(0x15555555) + ((__SEGGER_RTL_I32)x2 >> 4));
    x2 = __SEGGER_RTL_SMULL_HI(x1, x2);

    x3 = __SEGGER_RTL_SMULL_HI(xsq, __SEGGER_RTL_U32_C(0x05557555));
    x3 = __SEGGER_RTL_SMULL_HI(xsq, __SEGGER_RTL_U32_C(0x3FFFFFFB) + ((__SEGGER_RTL_I32)x3 >> 4));

    t = __SEGGER_RTL_float32_Exp_std_2tojby8[b + 4];
    x0 = __SEGGER_RTL_SMULL_HI(x1 + ((__SEGGER_RTL_I32)(x3 + ((__SEGGER_RTL_I32)x2 >> 2)) >> 1), t);
    x0 = t + ((__SEGGER_RTL_I32)x0 >> 2);





    q0 = (__SEGGER_RTL_I32)q1 >> 3;
    if (q0 < 16) {



      t = __SEGGER_RTL_float32_Exp_std_2tojby8[4 - b];
      x3 -= (__SEGGER_RTL_I32)x2 >> 2;
      t += (__SEGGER_RTL_I32)__SEGGER_RTL_SMULL_HI(t, (x3 >> 1) - x1) >> 2;



      x0 -= (__SEGGER_RTL_I32)t >> q0 >> q0;
    }



    if (x0 & __SEGGER_RTL_U32_C(0x40000000)) {
      q0 += 0x9D - 32;
    } else {
      q0 += 0x9C - 32;
      x0 <<= 1;
    }
  } else {







    x0 <<= 7;
    q0 += 7-32;







    xsq = (__SEGGER_RTL_I32)x0 >> q0;
    xsq = __SEGGER_RTL_SMULL_HI(xsq, xsq);
    x1 = __SEGGER_RTL_SMULL_HI(xsq, __SEGGER_RTL_U32_C(0x001A01A0));
    x1 = __SEGGER_RTL_SMULL_HI(xsq, x1 + __SEGGER_RTL_U32_C(0x04444444));
    x1 = __SEGGER_RTL_SMULL_HI(x0, x1 + __SEGGER_RTL_U32_C(0x55555555));
    x1 = __SEGGER_RTL_SMULL_HI(x0, x1);
    x1 = __SEGGER_RTL_SMULL_HI(x0, x1);



    x0 += (__SEGGER_RTL_I32)x1 >> q0 >> q0 >> 1;



    if ((__SEGGER_RTL_I32)x0 < 0) {
      q0 = 0x9D-32 - q0;
      x0 >>= 1;
    } else {
      q0 = 0x9C-32 - q0;
    }
  }



  return __SEGGER_RTL_BitcastToF32(__SEGGER_RTL_PACK(q0, x0, sign));
}
# 13495 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE float __SEGGER_RTL_float32_sinh_inline(float x) {
#if __SEGGER_RTL_SCALED_INTEGER >= 1
  return __SEGGER_RTL_float32_sinh_scaled_integer(x);
#else
  return __SEGGER_RTL_float32_sinh_fpu(x);
#endif
}
# 13518 "./floatops.c"
static __SEGGER_RTL_NEVER_INLINE float __SEGGER_RTL_float32_sinh_outline(float x) {
  return __SEGGER_RTL_float32_sinh_inline(x);
}
# 13537 "./floatops.c"
static __SEGGER_RTL_INLINE double __SEGGER_RTL_float64_sinh_inline(double x) {
  double y;

  y = SEGGER_FABS(x);



  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_isspecial(y))) {
    return x;
  }

  if (__SEGGER_RTL_float64_gt_rhs_positive(y, 1)) {
    if (__SEGGER_RTL_float64_gt_rhs_positive(y, M_LN_HUGE)) {
      return K_INF_F64;
    }
    y = SEGGER_EXP(SEGGER_ADD(y, -0.69316101074218750000));
    if (__SEGGER_RTL_float64_lt_rhs_positive(y, 1.0e10)) {
      y = SEGGER_ADD(y, SEGGER_DIV(-0.24999308500451499336, y));
    }
    y = SEGGER_FMA(0.13830277879601902638e-4, y, y);
    return __SEGGER_RTL_float64_signbit_xor(y, x);
  } else if (__SEGGER_RTL_float64_lt_rhs_positive(y, 1.0e-10)) {
    return x;
  } else {
    y = SEGGER_MUL(x, x);
    return SEGGER_FMA(x,
                      SEGGER_DIV(__SEGGER_RTL_float64_PolyEvalP_4(y, __SEGGER_RTL_float64_Sinh.P, K_SINH_P_DBL),
                                 __SEGGER_RTL_float64_PolyEvalQ_3(y, __SEGGER_RTL_float64_Sinh.Q, K_SINH_Q_DBL)),
                      x);
  }
}
# 13584 "./floatops.c"
static __SEGGER_RTL_NEVER_INLINE double __SEGGER_RTL_float64_sinh_outline(double x) {
  return __SEGGER_RTL_float64_sinh_inline(x);
}
# 13603 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_cosh_scaled_integer(float x) {
  __SEGGER_RTL_U32 x0, x1, x2, x3;
  __SEGGER_RTL_U32 xsq;
  __SEGGER_RTL_I32 i1;
  unsigned q0, q1;
  unsigned t, b;

  x0 = __SEGGER_RTL_BitcastToU32(x);
# 13621 "./floatops.c"
  q0 = 0x96 - (x0 << 1 >> 24);



  if (__SEGGER_RTL_UNLIKELY((int)q0 < 16)) {




    if ((x0 << 1) <= __SEGGER_RTL_U32_C(0xFF000000)) {
      return K_INF_F32;
    } else {
      return __SEGGER_RTL_BitcastToF32(x0 | __SEGGER_RTL_U32_C(0x400000));
    }
  } else if (__SEGGER_RTL_UNLIKELY((x0 & __SEGGER_RTL_U32_C(0x7FFFFFFF)) > __SEGGER_RTL_U32_C(0x42B2D4FC))) {



    return K_INF_F32;
  }



  x0 &= __SEGGER_RTL_U32_C(0xFFFFFF);
  x0 |= __SEGGER_RTL_U32_C(0x800000);



  if (q0 > 24) {



    if (q0 >= 36) {
      return 1.0f;
    }





    x0 <<= 7;
    q0 += 7-32;
# 13673 "./floatops.c"
    x2 = x0 >> q0;
    x2 = __SEGGER_RTL_SMULL_HI(x2, x2);
    i1 = __SEGGER_RTL_SMULL_HI(x2, __SEGGER_RTL_U32_C(0x0000D00D));
    i1 = __SEGGER_RTL_SMULL_HI(x2, i1 + __SEGGER_RTL_U32_C(0x002D82D8));
    i1 = __SEGGER_RTL_SMULL_HI(x2, i1 + __SEGGER_RTL_U32_C(0x05555555));
    i1 = __SEGGER_RTL_SMULL_HI(x0, i1 + __SEGGER_RTL_U32_C(0x40000000));
    i1 = __SEGGER_RTL_SMULL_HI(x0, i1) >> q0 >> q0;



    return __SEGGER_RTL_BitcastToF32(K_one_U32 + ((i1 + (1<<7)) >> 8));

  } else {
# 13695 "./floatops.c"
    __SEGGER_RTL_SMULL(x1, x2, __SEGGER_RTL_U32_C(0x5C551D95), x0);
    q1 = q0 - 5;

    t = __SEGGER_RTL_SIGN_EXTEND(x2, q1);



    x2 -= t;
    x1 = (t << (31 - q1)) + ((__SEGGER_RTL_I32)(1 + (x1 >> q1)) >> 1) - ((((__SEGGER_RTL_I32)x0 >> 4) * 0x52) >> q0);



    q1 = (__SEGGER_RTL_I32)x2 >> q1;
    b = __SEGGER_RTL_SIGN_EXTEND(q1, 3);
    q1 -= b;



    x1 = (__SEGGER_RTL_U32)(((__SEGGER_RTL_SMULL_X(__SEGGER_RTL_U32_C(0x58B90BFC), x1) >> 30) + 1) >> 1);
    xsq = __SEGGER_RTL_SMULL_HI(x1, x1);

    x2 = __SEGGER_RTL_SMULL_HI(xsq, __SEGGER_RTL_I32_C(0x011114AD));
    x2 = __SEGGER_RTL_SMULL_HI(xsq, __SEGGER_RTL_I32_C(0x15555555) + ((__SEGGER_RTL_I32)x2 >> 4));
    x2 = __SEGGER_RTL_SMULL_HI(x1, x2);

    x3 = __SEGGER_RTL_SMULL_HI(xsq, __SEGGER_RTL_I32_C(0x05557555));
    x3 = __SEGGER_RTL_SMULL_HI(xsq, __SEGGER_RTL_I32_C(0x3FFFFFFB) + ((__SEGGER_RTL_I32)x3 >> 4));

    t = __SEGGER_RTL_float32_Exp_std_2tojby8[b + 4];
    x0 = __SEGGER_RTL_SMULL_HI(x1 + ((__SEGGER_RTL_I32)(x3 + ((__SEGGER_RTL_I32)x2 >> 2)) >> 1), t);
    x0 = t + ((__SEGGER_RTL_I32)x0 >> 2);





    q0 = (__SEGGER_RTL_I32)q1 >> 3;
    if (q0 < 16) {



      t = __SEGGER_RTL_float32_Exp_std_2tojby8[4-b];
      x3 -= (__SEGGER_RTL_I32)x2 >> 2;
      t += (__SEGGER_RTL_I32)__SEGGER_RTL_SMULL_HI(t, (x3 >> 1) - x1) >> 2;



      x0 += t >> q0 >> q0;
    }



    q0 += 0x9D - 32;
#if defined(__SEGGER_RTL_CLZ_U32) && !defined(__SEGGER_RTL_CLZ_U32_SYNTHESIZED)
    q1 = __SEGGER_RTL_CLZ_U32(x0 << 1);
    x0 <<= q1;
    q0 -= q1;
#else
    if ((x0 & __SEGGER_RTL_U32_C(0x40000000)) == 0) {
      x0 <<= 1;
      q0 -= 1;
    }
#endif



    return __SEGGER_RTL_BitcastToF32(((__SEGGER_RTL_U32)q0 << 23) + ((x0 + (1<<6)) >> 7));
  }
}
# 13780 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_cosh_fpu(float x) {




  x = SEGGER_FABSF(x);

  if (__SEGGER_RTL_float32_gt_rhs_positive(x, 1)) {
    x = SEGGER_EXPF(SEGGER_ADDF(x, -0.6931610107421875f));
    if (__SEGGER_RTL_float32_lt_rhs_positive(x, 1.0e10f)) {
      x = SEGGER_ADDF(x, SEGGER_DIVF(0.24999308500451499336f, x));
    }
    return SEGGER_FMAF(0.13830277879601902638e-4f, x, x);
  } else {
    x = SEGGER_EXPF(x);
    return SEGGER_DIV2F(SEGGER_ADDF(x, SEGGER_DIVF(1, x)));
  }
}
# 13814 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_cosh_inline(float x) {
#if __SEGGER_RTL_SCALED_INTEGER >= 1
  return __SEGGER_RTL_float32_cosh_scaled_integer(x);
#else
  return __SEGGER_RTL_float32_cosh_fpu(x);
#endif
}
# 13837 "./floatops.c"
static __SEGGER_RTL_NEVER_INLINE float __SEGGER_RTL_float32_cosh_outline(float x) {
  return __SEGGER_RTL_float32_cosh_inline(x);
}
# 13856 "./floatops.c"
static __SEGGER_RTL_INLINE double __SEGGER_RTL_float64_cosh_inline(double x) {




  x = SEGGER_FABS(x);

  if (__SEGGER_RTL_float64_gt_rhs_positive(x, 1)) {
    x = SEGGER_EXP(SEGGER_ADD(x, -0.6931610107421875));
    if (__SEGGER_RTL_float64_lt_rhs_positive(x, 1.0e10)) {
      x = SEGGER_ADD(x, SEGGER_DIV(0.24999308500451499336, x));
    }
    return SEGGER_FMA(0.13830277879601902638e-4, x, x);
  } else {
    x = SEGGER_EXP(x);
    return SEGGER_DIV2(SEGGER_ADD(x, SEGGER_DIV(1, x)));
  }
}
# 13890 "./floatops.c"
static __SEGGER_RTL_NEVER_INLINE double __SEGGER_RTL_float64_cosh_outline(double x) {
  return __SEGGER_RTL_float64_cosh_inline(x);
}
# 13908 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_tanh_fpu(float x) {
  float y;
  float sign;

  sign = x;
  x = SEGGER_FABSF(x);




  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_isnan_inline(x))) {
    return x;
  }

  if (__SEGGER_RTL_float32_gt_rhs_positive(x, 27)) {
    x = 1;
  } else if (__SEGGER_RTL_float32_gt_rhs_positive(x, 0.549306144334054846f)) {
    x = SEGGER_EXPF(SEGGER_MUL2F(x));
    x = SEGGER_SUBF(1, SEGGER_DIVF(2, SEGGER_ADDF(x, 1)));
  } else if (__SEGGER_RTL_float32_gt_rhs_positive(x, 1.0e-10f)) {
    y = SEGGER_MULF(x, x);
    x = SEGGER_FMAF(x,
                    SEGGER_DIVF(__SEGGER_RTL_float32_PolyEvalP_3(y, __SEGGER_RTL_float32_Tanh.Poly.P, K_TANH_P_FLT),
                               __SEGGER_RTL_float32_PolyEvalQ_3(y, __SEGGER_RTL_float32_Tanh.Poly.Q, K_TANH_Q_FLT)),
                    x);
  }

  return __SEGGER_RTL_float32_signbit_xor(x, sign);
}
# 13952 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_tanh_scaled_integer(float x) {
  __SEGGER_RTL_U32 sign;
  __SEGGER_RTL_U32 x0, x1, x2, x3;
  unsigned q0, q1, q2;

  x0 = __SEGGER_RTL_BitcastToU32(x);



  sign = x0 & __SEGGER_RTL_U32_C(0x80000000);



  if ((x0 << 1) > __SEGGER_RTL_U32_C(0xFF000000)) {
    return __SEGGER_RTL_BitcastToF32(x0 | __SEGGER_RTL_U32_C(0x400000));
  }



  if ((x0 << 1) >= __SEGGER_RTL_X2(__SEGGER_RTL_U32_C(0x41102CB4))) {
    return __SEGGER_RTL_BitcastToF32(sign | K_one_U32);
  }



  q0 = 0x96 - (x0 << 1 >> 24);



  if (q0 >= 39) {



    if ((__SEGGER_RTL_I32)q0 == 0x96) {
      return __SEGGER_RTL_BitcastToF32(sign);
    }



    return x;
  }



  x0 &= __SEGGER_RTL_U32_C(0xFFFFFF);
  x0 |= __SEGGER_RTL_U32_C(0x800000);

  if (q0 < 25) {







    x0 = -(__SEGGER_RTL_I32)x0;
    q2 = q0 - 6;
    __SEGGER_RTL_SMULL(x0, x1, __SEGGER_RTL_I32_C(0x5C551D95), x0);
    x0 = (x1 << (32-q2) >> 1) + ((__SEGGER_RTL_I32)((x0 >> q2) + 1) >> 1) - ((((__SEGGER_RTL_I32)x0 >> 3) * 0x52) >> q0);



    q2 = x1 >> q2;
    q0 = (__SEGGER_RTL_I32)q2 << 29 >> 29;
    q2 = q0 - q2;
    q2 = (q2 >> 3) & 31;



    x1 = __SEGGER_RTL_SMULL_HI(x0, __SEGGER_RTL_I32_C(0x002BDEDC));
    x1 = __SEGGER_RTL_SMULL_HI(x0, __SEGGER_RTL_I32_C(0x013B3101) + ((__SEGGER_RTL_I32)x1 >> 2));
    x1 = __SEGGER_RTL_SMULL_HI(x0, __SEGGER_RTL_I32_C(0x071AC1F1) + ((__SEGGER_RTL_I32)x1 >> 2));
    x1 = __SEGGER_RTL_SMULL_HI(x0, __SEGGER_RTL_I32_C(0x1EBFBDFE) + ((__SEGGER_RTL_I32)x1 >> 2));
    x1 = __SEGGER_RTL_SMULL_HI(x0, __SEGGER_RTL_I32_C(0x58B90BFC) + ((__SEGGER_RTL_I32)x1 >> 2));
    x0 = __SEGGER_RTL_float32_Exp_std_2tojby8[q0 + 4];
    x0 = __SEGGER_RTL_SMULL_HI((__SEGGER_RTL_I32)x1 >> 1, x0) + x0;
    x0 >>= q2;





    x1 = __SEGGER_RTL_U32_C(0x40000000) + x0;



    x0 = __SEGGER_RTL_U32_C(0x40000000) - x0;
    q0 = 1;
    x0 <<= 1;





    x3 = (int)(__SEGGER_RTL_I8)__SEGGER_RTL_float32_tanh_Reciprocal[(x1 >> 24) & 63];




    x1 *= x3;
    x2 = __SEGGER_RTL_SMULL_HI(x1, x1);
    x2 = __SEGGER_RTL_SMULL_HI(__SEGGER_RTL_SMULL_HI(x3 << 24, x1),
                               __SEGGER_RTL_I32_C(0x40000001) + ((__SEGGER_RTL_I32)x1 >> 6) + ((__SEGGER_RTL_I32)x2 >> 10) + ((__SEGGER_RTL_I32)x1 >> 31));
    x0 = __SEGGER_RTL_SMULL_HI(((1-(__SEGGER_RTL_I32)x2) >> 1) - (x3 << 25), x0);



#if defined(__SEGGER_RTL_CLZ_U32)



    q1 = __SEGGER_RTL_CLZ_U32(x0) - 1;
    q0 += q1;
    x0 <<= q1;

#else
# 14076 "./floatops.c"
    if ((x0 & __SEGGER_RTL_U32_C(0x40000000)) == 0) {
      x0 <<= 1;
      q0 += 1;
      if ((x0 & __SEGGER_RTL_U32_C(0x40000000)) == 0) {
        x0 <<= 1;
        q0 += 1;
      }
    }
#endif



    return __SEGGER_RTL_BitcastToF32(sign + ((__SEGGER_RTL_U32)(0x9d - q0 - 30) << 23) + ((x0 + (1<<6)) >> 7));

  } else {





    x0 <<= 7;
    q0 += 7;







    q1 = 2*q0 - 64;
    x2 = __SEGGER_RTL_SMULL_HI(x0, x0);
    x1 = __SEGGER_RTL_SMULL_HI(x2, -__SEGGER_RTL_I32_C(0x01B402EA));
    x1 = __SEGGER_RTL_SMULL_HI(x2, __SEGGER_RTL_I32_C(0x057401DA) + ((__SEGGER_RTL_I32)x1 >> q1));
    x1 = __SEGGER_RTL_SMULL_HI(x2, -__SEGGER_RTL_I32_C(0x0DCC626C) + ((__SEGGER_RTL_I32)x1 >> q1));
    x1 = __SEGGER_RTL_SMULL_HI(x2, __SEGGER_RTL_I32_C(0x2221E539) + ((__SEGGER_RTL_I32)x1 >> q1));
    x1 = __SEGGER_RTL_SMULL_HI(x2, -__SEGGER_RTL_I32_C(0x55555447) + ((__SEGGER_RTL_I32)x1 >> q1));



    x0 += (__SEGGER_RTL_I32)__SEGGER_RTL_SMULL_HI(x0, x1) >> q1;



#if defined(__SEGGER_RTL_CLZ_U32) && !defined(__SEGGER_RTL_CLZ_U32_SYNTHESIZED)



    q1 = __SEGGER_RTL_CLZ_U32(x0) - 1;
    q0 += q1;
    x0 <<= q1;

#else
# 14136 "./floatops.c"
    if ((x0 & __SEGGER_RTL_U32_C(0x40000000)) == 0) {
      x0 <<= 1;
      q0 += 1;
      if ((x0 & __SEGGER_RTL_U32_C(0x40000000)) == 0) {
        x0 <<= 1;
        q0 += 1;
      }
    }
#endif



    return __SEGGER_RTL_BitcastToF32(sign + ((__SEGGER_RTL_U32)(0x9d - q0 - 1) << 23) + ((x0 + (1<<6)) >> 7));
  }
}
# 14166 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE float __SEGGER_RTL_float32_tanh_inline(float x) {
#if __SEGGER_RTL_SCALED_INTEGER >= 1
  return __SEGGER_RTL_float32_tanh_scaled_integer(x);
#else
  return __SEGGER_RTL_float32_tanh_fpu(x);
#endif
}
# 14188 "./floatops.c"
static __SEGGER_RTL_NEVER_INLINE float __SEGGER_RTL_float32_tanh_outline(float x) {
  return __SEGGER_RTL_float32_tanh_inline(x);
}
# 14206 "./floatops.c"
static __SEGGER_RTL_INLINE double __SEGGER_RTL_float64_tanh_inline(double x) {
  double y;
  double sign;

  sign = x;
  x = SEGGER_FABS(x);




  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_isnan_inline(x))) {
    return x;
  } else if (__SEGGER_RTL_float64_ge_rhs_positive(x, 27)) {
    x = 1;
  } else if (__SEGGER_RTL_float64_gt_rhs_positive(x, 0.549306144334054846)) {
    x = SEGGER_EXP(SEGGER_MUL2(x));
    x = SEGGER_SUB(1, SEGGER_DIV(2, SEGGER_ADD(x, 1)));
  } else if (__SEGGER_RTL_float64_gt_rhs_positive(x, 1.0e-10)) {
    y = SEGGER_MUL(x, x);
    x = SEGGER_FMA(x,
                   SEGGER_DIV(__SEGGER_RTL_float64_PolyEvalP_3(y, __SEGGER_RTL_float64_Tanh.Poly.P, K_TANH_P_DBL),
                              __SEGGER_RTL_float64_PolyEvalQ_3(y, __SEGGER_RTL_float64_Tanh.Poly.Q, K_TANH_Q_DBL)),
                   x);
  }

  return __SEGGER_RTL_float64_signbit_xor(x, sign);
}
# 14248 "./floatops.c"
static __SEGGER_RTL_NEVER_INLINE double __SEGGER_RTL_float64_tanh_outline(double x) {
  return __SEGGER_RTL_float64_tanh_inline(x);
}
# 14270 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_asinh_inline(float x) {
  float t;
  float w;

  t = SEGGER_FABSF(x);

  if (__SEGGER_RTL_UNLIKELY(!__SEGGER_RTL_float32_isfinite_inline(t))) {
    return x;
  }

  if (__SEGGER_RTL_float32_lt_rhs_positive(t, __SEGGER_RTL_FLT_SELECT(0x1p-28f, 3.7252902984619140625e-9f))) {
    return x;
  } else if (__SEGGER_RTL_float32_gt_rhs_positive(t, __SEGGER_RTL_FLT_SELECT(0x1p+28f, 268435456.0f))) {
    w = SEGGER_ADDF(SEGGER_LOGF(t), M_LN2_FLT);
  } else if (__SEGGER_RTL_float32_gt_rhs_positive(t, 2.0f)) {
    w = SEGGER_LOGF(SEGGER_ADDF(SEGGER_MUL2F(t), SEGGER_DIVF(1, SEGGER_ADDF(SEGGER_SQRTF(SEGGER_FMAF(x, x, 1)), t))));
  } else {
    w = SEGGER_MULF(x, x);
    w = SEGGER_LOG1PF(SEGGER_ADDF(t, SEGGER_DIVF(w, SEGGER_ADDF(1, SEGGER_SQRTF(SEGGER_ADDF(1, w))))));
  }

  return __SEGGER_RTL_float32_signbit_xor(w, x);
}
# 14312 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE double __SEGGER_RTL_float64_asinh_inline(double x) {
  double t;
  double w;

  t = SEGGER_FABS(x);

  if (__SEGGER_RTL_UNLIKELY(!__SEGGER_RTL_float64_isfinite_inline(t))) {
    return x;
  } else if (__SEGGER_RTL_float64_lt_rhs_positive(t, __SEGGER_RTL_FLT_SELECT(0x1p-28f, 3.7252902984619140625e-9f))) {
    return x;
  }

  if (__SEGGER_RTL_float64_ge_rhs_positive(t, __SEGGER_RTL_FLT_SELECT(0x1p28f, 268435456))) {
    w = SEGGER_ADD(SEGGER_LOG(t), M_LN2_DBL);
  } else if (__SEGGER_RTL_float64_ge_rhs_positive(t, 2)) {
    w = SEGGER_LOG(SEGGER_ADD(SEGGER_MUL2(t), SEGGER_DIV(1, SEGGER_ADD(SEGGER_SQRT(SEGGER_FMA(x, x, 1)), t))));
  } else {
    w = SEGGER_MUL(x, x);
    w = SEGGER_LOG1P(SEGGER_ADD(t, SEGGER_DIV(w, SEGGER_ADD(1, SEGGER_SQRT(SEGGER_ADD(1, w))))));
  }

  w = __SEGGER_RTL_float64_signbit_xor(w, x);

  return w;
}
# 14359 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_acosh_inline(float x) {



  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_lt_rhs_positive(x, 1))) {
    return K_NAN_F32;
  } else if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_gt_rhs_positive(x, 1500))) {
    return SEGGER_ADDF(SEGGER_LOGF(x), M_LN2_FLT);
  } else if (__SEGGER_RTL_float32_gt_rhs_positive(x, 2)) {
    return SEGGER_LOGF(SEGGER_FMSF(2, x, SEGGER_DIVF(1, SEGGER_ADDF(x, SEGGER_SQRTF(SEGGER_FMAF(x, x, -1))))));
  } else {
    x = SEGGER_ADDF(x, -1);
    return SEGGER_LOG1PF(SEGGER_ADDF(x, SEGGER_SQRTF(SEGGER_FMAF(2, x, SEGGER_MULF(x, x)))));
  }
}
# 14396 "./floatops.c"
static __SEGGER_RTL_INLINE double __SEGGER_RTL_float64_acosh_inline(double x) {



  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_lt_rhs_positive(x, 1))) {
    return K_NAN_F64;
  } else if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_ge_rhs_positive(x, __SEGGER_RTL_FLT_SELECT(0x1p28f, 268435456)))) {
    return SEGGER_ADD(SEGGER_LOG(x), M_LN2_DBL);
  } else if (__SEGGER_RTL_float64_ge_rhs_positive(x, 2)) {
    return SEGGER_LOG(SEGGER_FMS(2, x, SEGGER_DIV(1, SEGGER_ADD(x, SEGGER_SQRT(SEGGER_FMA(x, x, -1))))));
  } else {
    x = SEGGER_ADD(x, -1);
    return SEGGER_LOG1P(SEGGER_ADD(x, SEGGER_SQRT(SEGGER_FMA(2, x, SEGGER_MUL(x, x)))));
  }
}
# 14431 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_atanh_inline(float x) {
  float t;
  float mx;

  mx = __SEGGER_RTL_float32_abs_inline(x);




  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_isnan_inline(mx))) {
    return x;
  } else if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_ge_finite(mx, 1))) {
    if (__SEGGER_RTL_float32_eq_bitwise(mx, 1)) {
      return __SEGGER_RTL_float32_signbit_xor(K_INF_F32, x);
    } else {
      return K_NAN_F32;
    }
  }

  if (__SEGGER_RTL_float32_lt_rhs_positive(mx, __SEGGER_RTL_FLT_SELECT(0x1p-28f, 3.7252902984619140625e-9f))) {
    return x;
  }

  if (__SEGGER_RTL_float32_lt_rhs_positive(mx, 0.5f)) {
    t = SEGGER_MUL2F(mx);
    t = SEGGER_DIV2F(SEGGER_LOG1PF(SEGGER_ADDF(t, SEGGER_DIVF(SEGGER_MULF(t, mx), SEGGER_SUBF(1, mx)))));
  } else {
    t = SEGGER_DIV2F(SEGGER_LOG1PF(SEGGER_DIVF(SEGGER_MUL2F(mx), SEGGER_SUBF(1, mx))));
  }

  return __SEGGER_RTL_float32_signbit_xor(t, x);
}
# 14483 "./floatops.c"
static __SEGGER_RTL_INLINE double __SEGGER_RTL_float64_atanh_inline(double x) {
  double mx;
  double t;



  mx = __SEGGER_RTL_float64_abs_inline(x);




  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_isnan_inline(mx))) {
    return x;
  } else if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_ge_finite(mx, 1))) {
    if (__SEGGER_RTL_float64_eq_finite(mx, 1)) {
      return __SEGGER_RTL_float64_signbit_xor(K_INF_F64, x);
    } else {
      return K_NAN_F64;
    }
  } else if (__SEGGER_RTL_float64_lt_rhs_positive(mx, __SEGGER_RTL_FLT_SELECT(0x1p-28f, 3.7252902984619140625e-9))) {
    return x;
  }

  if (__SEGGER_RTL_float64_lt_rhs_positive(mx, 0.5)) {
    t = SEGGER_MUL2(mx);
    t = SEGGER_DIV2(SEGGER_LOG1P(SEGGER_ADD(t, SEGGER_DIV(SEGGER_MUL(t, mx), SEGGER_SUB(1, mx)))));
  } else {
    t = SEGGER_DIV2(SEGGER_LOG1P(SEGGER_DIV(SEGGER_MUL2(mx), SEGGER_SUB(1, mx))));
  }

  return __SEGGER_RTL_float64_signbit_xor(t, x);
}
# 14532 "./floatops.c"
static __SEGGER_RTL_INLINE __SEGGER_RTL_U32 __SEGGER_RTL_float32_fmax_soft_inline(__SEGGER_RTL_U32 x, __SEGGER_RTL_U32 y) {
  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_isnan_soft(x))) {
    return y;
  } else if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_isnan_soft(y))) {
    return x;
  } else if (__SEGGER_RTL_float32_signbit_soft(x | y)) {
    return (x < y) ? x : y;
  } else {
    return (x >= y) ? x : y;
  }
}
# 14560 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_fmax_fpu_inline(float x, float y) {
  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_isnan_inline(x))) {
    return y;
  } else if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_isnan_inline(y))) {
    return x;
  } else if (SEGGER_GTF(x, y)) {
    return x;
  } else {
    return y;
  }
}
# 14588 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE float __SEGGER_RTL_float32_fmax_inline(float x, float y) {
#if __SEGGER_RTL_FP_HW == 0
  return __SEGGER_RTL_BitcastToF32(__SEGGER_RTL_float32_fmax_soft_inline(__SEGGER_RTL_BitcastToU32(x), __SEGGER_RTL_BitcastToU32(y)));
#else
  return __SEGGER_RTL_float32_fmax_fpu_inline(x, y);
#endif
}
# 14612 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE double __SEGGER_RTL_float64_fmax_inline(double x, double y) {
  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_isnan_inline(x))) {
    return y;
  } else if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_isnan_inline(y))) {
    return x;
  } else if (SEGGER_GT(x, y)) {
    return x;
  } else {
    return y;
  }
}
# 14640 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_fmin_fpu_inline(float x, float y) {
  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_isnan_inline(x))) {
    return y;
  } else if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_isnan_inline(y))) {
    return x;
  } else if (SEGGER_LTF(x, y)) {
    return x;
  } else {
    return y;
  }
}
# 14668 "./floatops.c"
static __SEGGER_RTL_INLINE __SEGGER_RTL_U32 __SEGGER_RTL_float32_fmin_soft_inline(__SEGGER_RTL_U32 x, __SEGGER_RTL_U32 y) {
  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_isnan_soft(x))) {
    return y;
  } else if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_isnan_soft(y))) {
    return x;
  } else if (__SEGGER_RTL_float32_signbit_soft(x | y)) {
    return (x >= y) ? x : y;
  } else {
    return (x < y) ? x : y;
  }
}
# 14696 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE float __SEGGER_RTL_float32_fmin_inline(float x, float y) {
#if __SEGGER_RTL_FP_HW == 0
  return __SEGGER_RTL_BitcastToF32(__SEGGER_RTL_float32_fmin_soft_inline(__SEGGER_RTL_BitcastToU32(x), __SEGGER_RTL_BitcastToU32(y)));
#else
  return __SEGGER_RTL_float32_fmin_fpu_inline(x, y);
#endif
}
# 14720 "./floatops.c"
static __SEGGER_RTL_INLINE double __SEGGER_RTL_float64_fmin_inline(double x, double y) {
  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_isnan_inline(x))) {
    return y;
  } else if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_isnan_inline(y))) {
    return x;
  } else if (SEGGER_LT(x, y)) {
    return x;
  } else {
    return y;
  }
}
# 14747 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE float __SEGGER_RTL_float32_fdim_inline(float x, float y) {
  if (SEGGER_GTF(x, y)) {
    return SEGGER_SUBF(x, y);
  } else {
    return 0;
  }
}
# 14770 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE double __SEGGER_RTL_float64_fdim_inline(double x, double y) {
  if (SEGGER_GT(x, y)) {
    return SEGGER_SUB(x, y);
  } else {
    return 0;
  }
}
# 14800 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_modf_inline(float x, float *iptr) {
  __SEGGER_RTL_U32 x0;
  int exponent;

  x0 = __SEGGER_RTL_BitcastToU32(x);
  exponent = FLOAT32_EXPONENT(x0);

  exponent -= 0x7F;
  if (exponent < 0) {
    *iptr = 0.0f;
    return x;
  } else if (exponent >= 23) {
    *iptr = x;
    return __SEGGER_RTL_BitcastToF32(x0 & FLOAT32_SIGN_MASK);
  }



  x0 &= ~(FLOAT32_SIGNIFICAND_MASK >> exponent);
  *iptr = __SEGGER_RTL_BitcastToF32(x0);



  return SEGGER_SUBF(x, *iptr);
}
# 14848 "./floatops.c"
static float __SEGGER_RTL_NEVER_INLINE __SEGGER_RTL_float32_modf_outline(float x, float *iptr) {
  return __SEGGER_RTL_float32_modf_inline(x, iptr);
}
# 14874 "./floatops.c"
static __SEGGER_RTL_INLINE double __SEGGER_RTL_float64_modf_inline(double x, double *iptr) {
  __SEGGER_RTL_U64 x0;
  int exponent;

  x0 = __SEGGER_RTL_BitcastToU64(x);
  exponent = FLOAT64_EXPONENT(x0);

  exponent -= 0x3FF;
  if (exponent < 0) {
    *iptr = 0;
    return x;
  } else if (exponent >= 52) {
    *iptr = x;
    return __SEGGER_RTL_BitcastToF64(x0 & FLOAT64_SIGN_MASK);
  }



  x0 &= ~(FLOAT64_SIGNIFICAND_MASK >> exponent);
  *iptr = __SEGGER_RTL_BitcastToF64(x0);



  return SEGGER_SUB(x, *iptr);
}
# 14922 "./floatops.c"
static double __SEGGER_RTL_NEVER_INLINE __SEGGER_RTL_float64_modf_outline(double x, double *iptr) {
  return __SEGGER_RTL_float64_modf_inline(x, iptr);
}
# 14952 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_fmod_inline(float x, float y) {
  __SEGGER_RTL_U32 i;
  __SEGGER_RTL_U32 x_i0, y_i0;
  int x_q0, y_q0;
  __SEGGER_RTL_U32 x_sign;



  x_i0 = __SEGGER_RTL_BitcastToU32(x);
  y_i0 = __SEGGER_RTL_BitcastToU32(y);
  x_sign = x_i0 & FLOAT32_SIGN_MASK;



  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_isspecial_or_negative(x) ||
                            __SEGGER_RTL_float32_isspecial_or_negative(y))) {



    if (__SEGGER_RTL_float32_isnan_inline(x)) {
      return x;
    } else if (__SEGGER_RTL_float32_isnan_inline(y)) {
      return y;
    }



    if ((x_i0 << 1) == 0 && (y_i0 << 1) != 0) {
      return x;
    }



    if (__SEGGER_RTL_float32_isinf_inline(x)) {
      return K_NAN_F32;
    }



    if (__SEGGER_RTL_float32_isinf_inline(y)) {
      return x;
    }



    if ((y_i0 << 1) == 0) {
      return K_NAN_F32;
    }




    y_i0 &= ~FLOAT32_SIGN_MASK;
  }






  x_i0 ^= x_sign;
  if (__SEGGER_RTL_UNLIKELY(x_i0 <= y_i0)) {
    if (x_i0 == y_i0) {
      return __SEGGER_RTL_BitcastToF32(x_sign);
    } else {
      return x;
    }
  }



  x_q0 = FLOAT32_EXPONENT(x_i0);
  if (x_q0 != 0) {
    x_i0 &= FLOAT32_SIGNIFICAND_MASK;
    x_i0 |= FLOAT32_HIDDEN_MASK;
  } else {
    x_q0 = __SEGGER_RTL_float32_normalize(&x_i0, 0);
  }



  y_q0 = FLOAT32_EXPONENT(y_i0);
  if (y_q0 != 0) {
    y_i0 &= FLOAT32_SIGNIFICAND_MASK;
    y_i0 |= FLOAT32_HIDDEN_MASK;
  } else {
    y_q0 = __SEGGER_RTL_float32_normalize(&y_i0, 0);
  }



  while (x_q0 > y_q0) {
    i = x_i0 - y_i0;
    if ((i & __SEGGER_RTL_U32_C(0x80000000)) == 0) {
      if (i == 0) {
        return __SEGGER_RTL_BitcastToF32(x_sign);
      }
      x_i0 = i;
    }
    x_i0 <<= 1;
    x_q0 -= 1;
  }

  i = x_i0 - y_i0;
  if ((i & __SEGGER_RTL_U32_C(0x80000000)) == 0) {
    if (i == 0) {
      return __SEGGER_RTL_BitcastToF32(x_sign);
    }
    x_i0 = i;
  }



  x_q0 = __SEGGER_RTL_float32_normalize(&x_i0, x_q0);



  --x_q0;
  if (__SEGGER_RTL_UNLIKELY(x_q0 < 0)) {



    x_i0 >>= -x_q0;
    x_q0 = 0;
  }



  return __SEGGER_RTL_BitcastToF32(((__SEGGER_RTL_U32)x_q0 << 23)
                                   + x_i0
                                   + x_sign);
}
# 15111 "./floatops.c"
static __SEGGER_RTL_INLINE double __SEGGER_RTL_float64_fmod_inline(double x, double y) {

#if __SEGGER_RTL_FP_HW >= 2

  double xmag;
  double ymag;
  double ymagX;
  double r;
  int n;
  int nr;
  int ny;

  if (__SEGGER_RTL_UNLIKELY(!__SEGGER_RTL_float64_isfinite_inline(x) ||
                            __SEGGER_RTL_float64_isnan_inline(y) ||
                            __SEGGER_RTL_float64_putative_iszero(y))) {
    return K_NAN_F64;
  }

  xmag = __SEGGER_RTL_float64_abs_inline(x);
  ymag = __SEGGER_RTL_float64_abs_inline(y);

  if (SEGGER_LT(xmag, ymag)) {
    return x;
  } else if (SEGGER_EQ(xmag, ymag)) {
    return __SEGGER_RTL_float64_signbit_copy(0.0, x);
  }

  r = xmag;
  __SEGGER_RTL_float64_frexp_inline(ymag, &ny);

  while (SEGGER_GE(r, ymag)) {
    __SEGGER_RTL_float64_frexp_inline(r, &nr);
    n = nr - ny;
    ymagX = __SEGGER_RTL_float64_ldexp_inline(ymag, n);
    if (SEGGER_GT(ymagX, r)) {
      ymagX = __SEGGER_RTL_float64_ldexp_inline(ymag, n-1);
    }
    r = SEGGER_SUB(r, ymagX);
  }
  return SEGGER_LT0(x) ? SEGGER_NEG(r) : r;

#else

  __SEGGER_RTL_U64 i;
  __SEGGER_RTL_U64 x_sign;
  __SEGGER_RTL_U64 x_i0, y_i0;
  int x_q0, y_q0;




  x_i0 = __SEGGER_RTL_BitcastToU64(x);
  y_i0 = __SEGGER_RTL_BitcastToU64(y);
  x_sign = x_i0 & FLOAT64_SIGN_MASK;



  if (__SEGGER_RTL_UNLIKELY(!__SEGGER_RTL_float64_isfinite_inline(x) ||
                            __SEGGER_RTL_float64_isnan_inline(y) ||
                            __SEGGER_RTL_float64_putative_iszero(y))) {
    return K_NAN_F64;
  }

  y_i0 &= ~FLOAT64_SIGN_MASK;






  x_i0 ^= x_sign;
  if (__SEGGER_RTL_UNLIKELY(x_i0 <= y_i0)) {
    if (x_i0 == y_i0) {
      return __SEGGER_RTL_BitcastToF64(x_sign);
    } else {
      return x;
    }
  }



  x_q0 = FLOAT64_EXPONENT(x_i0);
  if (x_q0 != 0) {
    x_i0 &= FLOAT64_SIGNIFICAND_MASK;
    x_i0 |= FLOAT64_HIDDEN_MASK;
  } else {
    x_q0 = __SEGGER_RTL_float64_normalize(&x_i0, 0);
  }



  y_q0 = FLOAT64_EXPONENT(y_i0);
  if (y_q0 != 0) {
    y_i0 &= FLOAT64_SIGNIFICAND_MASK;
    y_i0 |= FLOAT64_HIDDEN_MASK;
  } else {
    y_q0 = __SEGGER_RTL_float64_normalize(&y_i0, 0);
  }



  while (x_q0 > y_q0) {
    i = x_i0 - y_i0;
    if ((i & __SEGGER_RTL_U64_C(0x8000000000000000)) == 0) {
      if (i == 0) {
        return __SEGGER_RTL_BitcastToF64(x_sign);
      }
      x_i0 = i;
    }
    x_i0 <<= 1;
    x_q0 -= 1;
  }

  i = x_i0 - y_i0;
  if ((i & __SEGGER_RTL_U64_C(0x8000000000000000)) == 0) {
    if (i == 0) {
      return __SEGGER_RTL_BitcastToF64(x_sign);
    }
    x_i0 = i;
  }




  while ((x_i0 & __SEGGER_RTL_U64_C(0x0010000000000000)) == 0) {
    x_i0 <<= 1;
    x_q0 -= 1;
  }



  --x_q0;
  if (__SEGGER_RTL_UNLIKELY(x_q0 < 0)) {



    x_i0 >>= -x_q0;
    x_q0 = 0;
  }

  return __SEGGER_RTL_BitcastToF64(((__SEGGER_RTL_U64)x_q0 << 52)
                                   + x_i0
                                   + x_sign);
#endif
}
# 15285 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE float __SEGGER_RTL_float32_remainder_inline(float x, float y, int *quo) {
  float xmag;
  float ymag;
  float ymagX;
  float r;
  int n;
  int nr;
  int ny;
  unsigned parity;
  int quotient;

  if (__SEGGER_RTL_UNLIKELY(!__SEGGER_RTL_float32_isfinite_inline(x) ||
                            __SEGGER_RTL_float32_isnan_inline(y) ||
                            __SEGGER_RTL_float32_putative_iszero(y))) {
    *quo = 0;
    return K_NAN_F32;
  }

  xmag = SEGGER_FABSF(x);
  ymag = SEGGER_FABSF(y);

  if (SEGGER_LTF(xmag, SEGGER_DIV2F(ymag))) {
    *quo = 0;
    return x;
  } else if (SEGGER_EQF(xmag, ymag)) {
    *quo = 1;
    return __SEGGER_RTL_float32_signbit_copy(0.0, x);
  }

  r = xmag;
  SEGGER_FREXPF(ymag, &ny);
  quotient = 0;
  parity = 0;

  while (SEGGER_GEF(r, ymag)) {
    SEGGER_FREXPF(r, &nr);
    n = nr - ny;
    ymagX = SEGGER_LDEXPF(ymag, n);
    if (SEGGER_GTF(ymagX, r)) {
      --n;
      ymagX = SEGGER_LDEXPF(ymag, n);
    }
    if (n == 0) {
      parity = ~parity;
    }
    quotient += __SEGGER_RTL_SAFE_LSL_U32(1, n);
    r = SEGGER_SUBF(r, ymagX);
  }

  if (SEGGER_GTF(r, SEGGER_DIV2F(ymag))) {
    r = SEGGER_SUBF(r, ymag);
    parity = ~parity;
    quotient += 1;
  }
  if (parity != 0 && (SEGGER_EQF(r, SEGGER_DIV2F(ymag)))) {
    r = SEGGER_NEGF(r);
  }

  *quo = quotient;

  return SEGGER_LT0F(x) ? SEGGER_NEGF(r) : r;
}
# 15376 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE double __SEGGER_RTL_float64_remainder_inline(double x, double y, int *quo) {
  double xmag;
  double ymag;
  double ymagX;
  double r;
  int n;
  int nr;
  int ny;
  unsigned parity;
  int quotient;

  if (__SEGGER_RTL_UNLIKELY(!__SEGGER_RTL_float64_isfinite_inline(x) ||
                            __SEGGER_RTL_float64_isnan_inline(y) ||
                            __SEGGER_RTL_float64_putative_iszero(y))) {
    *quo = 0;
    return K_NAN_F64;
  }

  xmag = SEGGER_FABS(x);
  ymag = SEGGER_FABS(y);

  if (SEGGER_LT(xmag, SEGGER_DIV2(ymag))) {
    *quo = 0;
    return x;
  } else if (SEGGER_EQ(xmag, ymag)) {
    *quo = 1;
    return __SEGGER_RTL_float64_signbit_copy(0.0, x);
  }

  r = xmag;
  SEGGER_FREXP(ymag, &ny);
  parity = 0;
  quotient = 0;

  while (SEGGER_GE(r, ymag)) {
    SEGGER_FREXP(r, &nr);
    n = nr - ny;
    ymagX = SEGGER_LDEXP(ymag, n);
    if (SEGGER_GT(ymagX, r)) {
      --n;
      ymagX = SEGGER_LDEXP(ymag, n);
    }
    if (n == 0) {
      parity = ~parity;
    }
    quotient += __SEGGER_RTL_SAFE_LSL_U32(1, n);
    r = SEGGER_SUB(r, ymagX);
  }

  if (SEGGER_GT(r, SEGGER_DIV2(ymag))) {
    r = SEGGER_SUB(r, ymag);
    parity = ~parity;
    quotient += 1;
  }
  if (parity != 0 && (SEGGER_EQ(r, SEGGER_DIV2(ymag)))) {
    r = SEGGER_NEG(r);
  }

  *quo = quotient;

  return SEGGER_LT0(x) ? SEGGER_NEG(r) : r;
}
# 15461 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_hypot_inline(float x, float y) {
  if (__SEGGER_RTL_float32_isinf_inline(x) || __SEGGER_RTL_float32_isinf_inline(y)) {
    return K_INF_F32;
  } else {
    return SEGGER_SQRTF(SEGGER_ADDF(SEGGER_MULF(x, x), SEGGER_MULF(y, y)));
  }
}
# 15491 "./floatops.c"
static __SEGGER_RTL_NEVER_INLINE float __SEGGER_RTL_float32_hypot_outline(float x, float y) {
  return __SEGGER_RTL_float32_hypot_inline(x, y);
}
# 15517 "./floatops.c"
static __SEGGER_RTL_INLINE double __SEGGER_RTL_float64_hypot_inline(double x, double y) {
  if (__SEGGER_RTL_float64_isinf_inline(x) || __SEGGER_RTL_float64_isinf_inline(y)) {
    return K_INF_F64;
  }
  return SEGGER_SQRT(SEGGER_ADD(SEGGER_MUL(x, x), SEGGER_MUL(y, y)));
}
# 15546 "./floatops.c"
static __SEGGER_RTL_NEVER_INLINE double __SEGGER_RTL_float64_hypot_outline(double x, double y) {
  return __SEGGER_RTL_float64_hypot_inline(x, y);
}
# 15564 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE float __SEGGER_RTL_float32_pow_inline(float x, float y) {
  int iy;
  int reciprocate;
  float r;



  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_eq_bitwise(x, 1))) {
    return x;
  }




  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_putative_iszero(y))) {
    return 1;
  }




  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_isspecial(x) || __SEGGER_RTL_float32_isspecial(y))) {




    if (__SEGGER_RTL_float32_isnan_inline(x)) {
      return x;
    } else if (__SEGGER_RTL_float32_isnan_inline(y)) {
      return y;
    }

    if (__SEGGER_RTL_float32_putative_iszero(x)) {







      iy = SEGGER_F2I(y);
      if (__SEGGER_RTL_float32_eq_bitwise(y, SEGGER_I2F(iy))) {
        r = __SEGGER_RTL_float32_lt_rhs_positive(y, 0)
              ? K_INF_F32
              : 0;

        return (iy & 1) ? __SEGGER_RTL_float32_signbit_xor(r, x) : r;
      }
    } else if (__SEGGER_RTL_BitcastToU32(x) == K_INF_U32) {




      return __SEGGER_RTL_float32_lt_rhs_positive(y, 0)
               ? 0
               : K_INF_F32;

    } else if (__SEGGER_RTL_BitcastToU32(x) == (K_INF_U32 | FLOAT32_SIGN_MASK)) {

      r = __SEGGER_RTL_float32_lt_rhs_positive(y, 0) ? 0 : K_INF_F32;
      iy = SEGGER_F2I(y);
      if (__SEGGER_RTL_float32_eq_bitwise(y, SEGGER_I2F(iy))) {
        if (iy & 1) {
          r = __SEGGER_RTL_float32_signbit_xor(r, x);
        }
      }
      return r;

    } else if (__SEGGER_RTL_BitcastToU32(y) == (K_INF_U32 | FLOAT32_SIGN_MASK)) {





      if (__SEGGER_RTL_float32_eq_bitwise(x, -1)) {
        return +1;
      } else {
        return __SEGGER_RTL_float32_lt_rhs_positive(SEGGER_FABSF(x), 1)
                 ? K_INF_F32
                 : 0;
      }
    } else {
# 15655 "./floatops.c"
      if (__SEGGER_RTL_float32_lt_rhs_positive(SEGGER_FABSF(x), 1)) {
        return 0;
      } if (__SEGGER_RTL_float32_eq_bitwise(x, -1)) {
        return +1;
      } else {
        return K_INF_F32;
      }
    }
  }



  iy = SEGGER_F2I(y);
  if (__SEGGER_RTL_float32_eq_bitwise(y, SEGGER_I2F(iy))) {



    reciprocate = 0;
    if (iy < 0) {
      reciprocate = 1;
      iy = -iy;
    }
    y = 1;
    while (iy) {
      if (iy & 1) {
        y = SEGGER_MULF(y, x);
      }
      iy >>= 1;
      if (iy) {
        x = SEGGER_MULF(x, x);
      }
    }

    return reciprocate ? SEGGER_DIVF(1, y) : y;
  } else if (SEGGER_LT0F(x)) {
    return K_NAN_F32;
  } else {
    return SEGGER_EXPF(SEGGER_MULF(y, SEGGER_LOGF(SEGGER_FABSF(x))));
  }
}
# 15710 "./floatops.c"
static __SEGGER_RTL_NEVER_INLINE float __SEGGER_RTL_float32_pow_outline(float x, float y) {
  return __SEGGER_RTL_float32_pow_inline(x, y);
}
# 15728 "./floatops.c"
static __SEGGER_RTL_INLINE double __SEGGER_RTL_float64_pow_inline(double x, double y) {
  int iy;
  int reciprocate;
  double r;



  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_eq_bitwise(x, 1))) {
    return x;
  }




  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_putative_iszero(y))) {
    return 1;
  }




  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_isspecial(x) || __SEGGER_RTL_float64_isspecial(y))) {




    if (__SEGGER_RTL_float64_isnan_inline(x)) {
      return x;
    } else if (__SEGGER_RTL_float64_isnan_inline(y)) {
      return y;
    }

    if (__SEGGER_RTL_float64_putative_iszero(x)) {







      iy = SEGGER_D2I(y);
      if (__SEGGER_RTL_float64_eq_bitwise(y, SEGGER_I2D(iy))) {
        r = __SEGGER_RTL_float64_lt_rhs_positive(y, 0)
              ? K_INF_F64
              : 0;

        return (iy & 1) ? __SEGGER_RTL_float64_signbit_xor(r, x) : r;
      }
    } else if (__SEGGER_RTL_BitcastToU64(x) == K_INF_U64) {




      return __SEGGER_RTL_float64_lt_rhs_positive(y, 0)
               ? 0
               : K_INF_F64;

    } else if (__SEGGER_RTL_BitcastToU64(x) == (K_INF_U64 | FLOAT64_SIGN_MASK)) {

      r = __SEGGER_RTL_float64_lt_rhs_positive(y, 0) ? 0 : K_INF_F64;
      iy = SEGGER_D2I(y);
      if (__SEGGER_RTL_float64_eq_bitwise(y, SEGGER_I2D(iy))) {
        if (iy & 1) {
          r = __SEGGER_RTL_float64_signbit_xor(r, x);
        }
      }
      return r;
    } else if (__SEGGER_RTL_BitcastToU64(y) == (K_INF_U64 | FLOAT64_SIGN_MASK)) {






      if (__SEGGER_RTL_float64_eq_bitwise(x, -1)) {
        return +1;
      } else {
        return __SEGGER_RTL_float64_lt_rhs_positive(SEGGER_FABS(x), 1)
                 ? K_INF_F64
                 : 0;
      }
    } else {
# 15819 "./floatops.c"
      if (__SEGGER_RTL_float64_lt_rhs_positive(SEGGER_FABS(x), 1)) {
        return 0;
      } if (__SEGGER_RTL_float64_eq_bitwise(x, -1)) {
        return +1;
      } else {
        return K_INF_F64;
      }
    }
  }



  iy = SEGGER_D2I(y);
  if (__SEGGER_RTL_float64_eq_bitwise(y, SEGGER_I2D(iy)) && (unsigned)iy != 0x80000000u) {



    reciprocate = 0;
    if (iy < 0) {
      reciprocate = 1;
      iy = -iy;
    }
    y = 1;
    while (iy) {
      if (iy & 1) {
        y = SEGGER_MUL(y, x);
      }
      iy = (unsigned)iy >> 1;
      if (iy) {
        x = SEGGER_MUL(x, x);
      }
    }

    return reciprocate ? SEGGER_DIV(1, y) : y;
  } else if (SEGGER_LT0(x)) {
    return K_NAN_F64;
  } else {
    return SEGGER_EXP(SEGGER_MUL(y, SEGGER_LOG(SEGGER_FABS(x))));
  }
}
# 15874 "./floatops.c"
static __SEGGER_RTL_NEVER_INLINE double __SEGGER_RTL_float64_pow_outline(double x, double y) {
  return __SEGGER_RTL_float64_pow_inline(x, y);
}
# 15891 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_tgamma_inline(float x) {
  float v;

  v = SEGGER_MULF(12, x) - SEGGER_DIVF(1, SEGGER_MULF(10, x));
  v = SEGGER_ADDF(x, SEGGER_DIVF(1, v));
  v = SEGGER_DIVF(v, (float)M_E);
  v = SEGGER_POWF(v, x);
  v = SEGGER_MULF(v, SEGGER_SQRTF(SEGGER_DIVF((float)(2*M_PI), x)));

  return v;
}
# 15916 "./floatops.c"
static __SEGGER_RTL_INLINE double __SEGGER_RTL_float64_tgamma_inline(double x) {
  double v;

  v = SEGGER_MUL(12, x) - SEGGER_DIV(1, SEGGER_MUL(10, x));
  v = SEGGER_ADD(x, SEGGER_DIV(1, v));
  v = SEGGER_DIV(v, M_E);
  v = SEGGER_POW(v, x);
  v = SEGGER_MUL(v, SEGGER_SQRT(SEGGER_DIV(2*M_PI, x)));

  return v;
}
# 15941 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_lgamma_inline(float x) {
  float v;

  v = SEGGER_MULF(12, x) - SEGGER_DIVF(1, SEGGER_MULF(10, x));
  v = SEGGER_ADDF(x, SEGGER_DIVF(1, v));
  v = SEGGER_SUBF(SEGGER_LOGF(v), 1);
  v = SEGGER_MULF(v, x);
  v = SEGGER_ADDF(v, SEGGER_DIV2F((float)M_LOG_2PI - SEGGER_LOGF(x)));

  return v;
}
# 15966 "./floatops.c"
static __SEGGER_RTL_INLINE double __SEGGER_RTL_float64_lgamma_inline(double x) {
  double v;

  v = SEGGER_MUL(12, x) - SEGGER_DIV(1, SEGGER_MUL(10, x));
  v = SEGGER_ADD(x, SEGGER_DIV(1, v));
  v = SEGGER_SUB(SEGGER_LOG(v), 1);
  v = SEGGER_MUL(v, x);
  v = SEGGER_ADD(v, SEGGER_DIV2((float)M_LOG_2PI - SEGGER_LOG(x)));

  return v;
}
# 15991 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_erf_inline(float x) {
  const float a = 0.147f;
  float ax2;
  float x2;
  float v;

  x2 = SEGGER_MULF(x, x);
  ax2 = SEGGER_MULF(a, x2);
  v = SEGGER_DIVF(SEGGER_ADDF((float)(4/M_PI), ax2), SEGGER_ADDF(1, ax2));
  v = SEGGER_NEGF(SEGGER_MULF(x2, v));
  v = SEGGER_SQRTF(SEGGER_SUBF(1, SEGGER_EXPF(v)));

  return __SEGGER_RTL_float32_signbit_xor(v, x);
}
# 16019 "./floatops.c"
static __SEGGER_RTL_INLINE double __SEGGER_RTL_float64_erf_inline(double x) {
  const double a = 0.147;
  double ax2;
  double x2;
  double v;

  x2 = SEGGER_MUL(x, x);
  ax2 = SEGGER_MUL(a, x2);
  v = SEGGER_DIV(SEGGER_ADD(4/M_PI, ax2), SEGGER_ADD(1, ax2));
  v = SEGGER_NEG(SEGGER_MUL(x2, v));
  v = SEGGER_SQRT(SEGGER_SUB(1, SEGGER_EXP(v)));

  return __SEGGER_RTL_float64_signbit_xor(v, x);
}
# 16047 "./floatops.c"
static __SEGGER_RTL_INLINE float __SEGGER_RTL_float32_erfc_inline(float x) {
  return SEGGER_DIVF(
           SEGGER_MULF(SEGGER_SUBF(1, SEGGER_EXPF(SEGGER_MULF(-1.98f, x))),
                       SEGGER_EXPF(SEGGER_NEGF(SEGGER_MULF(x, x)))),
           SEGGER_MULF((float)(1.135 * M_SQRT_PI), x));
}
# 16067 "./floatops.c"
static __SEGGER_RTL_INLINE double __SEGGER_RTL_float64_erfc_inline(double x) {
  return SEGGER_DIV(
           SEGGER_MUL(SEGGER_SUB(1, SEGGER_EXP(SEGGER_MUL(-1.98, x))),
                       SEGGER_EXP(SEGGER_NEG(SEGGER_MUL(x, x)))),
           SEGGER_MUL(1.135 * M_SQRT_PI, x));
}
# 16088 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE __SEGGER_RTL_FLOAT32_C_COMPLEX __SEGGER_RTL_float32_cmplx_inline(float re, float im) {
  __SEGGER_RTL_FLOAT32_COMPLEX z;

  z.u.part.Re = re;
  z.u.part.Im = im;

  return z.u.value;
}
# 16111 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE __SEGGER_RTL_FLOAT64_C_COMPLEX __SEGGER_RTL_float64_cmplx_inline(double re, double im) {
  __SEGGER_RTL_FLOAT64_COMPLEX z;

  z.u.part.Re = re;
  z.u.part.Im = im;

  return z.u.value;
}
# 16134 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE __SEGGER_RTL_LDOUBLE_C_COMPLEX __SEGGER_RTL_ldouble_cmplx_inline(double re, double im) {
  __SEGGER_RTL_LDOUBLE_COMPLEX z;

  z.u.part.Re = re;
  z.u.part.Im = im;

  return z.u.value;
}
# 16158 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE void __SEGGER_RTL_float32_cadd(__SEGGER_RTL_FLOAT32_COMPLEX *pX, const __SEGGER_RTL_FLOAT32_COMPLEX *pY) {
  pX->u.part.Re = SEGGER_ADDF(pX->u.part.Re, pY->u.part.Re);
  pX->u.part.Im = SEGGER_ADDF(pX->u.part.Im, pY->u.part.Im);
}
# 16178 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE void __SEGGER_RTL_float64_cadd(__SEGGER_RTL_FLOAT64_COMPLEX *pX, const __SEGGER_RTL_FLOAT64_COMPLEX *pY) {
  pX->u.part.Re = SEGGER_ADD(pX->u.part.Re, pY->u.part.Re);
  pX->u.part.Im = SEGGER_ADD(pX->u.part.Im, pY->u.part.Im);
}
# 16198 "./floatops.c"
static __SEGGER_RTL_INLINE void __SEGGER_RTL_float32_csub(__SEGGER_RTL_FLOAT32_COMPLEX *pX, const __SEGGER_RTL_FLOAT32_COMPLEX *pY) {
  pX->u.part.Re = SEGGER_SUBF(pX->u.part.Re, pY->u.part.Re);
  pX->u.part.Im = SEGGER_SUBF(pX->u.part.Im, pY->u.part.Im);
}
# 16218 "./floatops.c"
static __SEGGER_RTL_INLINE void __SEGGER_RTL_float64_csub(__SEGGER_RTL_FLOAT64_COMPLEX *pX, const __SEGGER_RTL_FLOAT64_COMPLEX *pY) {
  pX->u.part.Re = SEGGER_SUB(pX->u.part.Re, pY->u.part.Re);
  pX->u.part.Im = SEGGER_SUB(pX->u.part.Im, pY->u.part.Im);
}
# 16234 "./floatops.c"
static __SEGGER_RTL_INLINE void __SEGGER_RTL_float32_cmul(__SEGGER_RTL_FLOAT32_COMPLEX *pX, const __SEGGER_RTL_FLOAT32_COMPLEX *pY) {
  float a;
  float b;
  float c;
  float d;
  float Zre;
  float Zim;
  float ac;
  float bd;
  float ad;
  float bc;
  int Recalc;

  a = pX->u.part.Re;
  b = pX->u.part.Im;
  c = pY->u.part.Re;
  d = pY->u.part.Im;

  ac = SEGGER_MULF(a, c);
  bd = SEGGER_MULF(b, d);
  ad = SEGGER_MULF(a, d);
  bc = SEGGER_MULF(b, c);

  Zre = SEGGER_SUBF(ac, bd);
  Zim = SEGGER_ADDF(ad, bc);

  if (__SEGGER_RTL_float32_isnan_inline(Zre) && __SEGGER_RTL_float32_isnan_inline(Zim)) {

    Recalc = 0;

    if (__SEGGER_RTL_float32_isinf_inline(a) || __SEGGER_RTL_float32_isinf_inline(b)) {
      a = __SEGGER_RTL_float32_signbit_copy(__SEGGER_RTL_float32_isinf_inline(a) ? 1.0f : 0.0f, a);
      b = __SEGGER_RTL_float32_signbit_copy(__SEGGER_RTL_float32_isinf_inline(b) ? 1.0f : 0.0f, b);
      if (__SEGGER_RTL_float32_isnan_inline(c)) { c = __SEGGER_RTL_float32_signbit_copy(0, c); }
      if (__SEGGER_RTL_float32_isnan_inline(d)) { d = __SEGGER_RTL_float32_signbit_copy(0, d); }

      Recalc = 1;
    }

    if (__SEGGER_RTL_float32_isinf_inline(c) || __SEGGER_RTL_float32_isinf_inline(d)) {
      c = __SEGGER_RTL_float32_signbit_copy(__SEGGER_RTL_float32_isinf_inline(c) ? 1.0f : 0.0f, c);
      d = __SEGGER_RTL_float32_signbit_copy(__SEGGER_RTL_float32_isinf_inline(d) ? 1.0f : 0.0f, d);
      if (__SEGGER_RTL_float32_isnan_inline(a)) { a = __SEGGER_RTL_float32_signbit_copy(0, a); }
      if (__SEGGER_RTL_float32_isnan_inline(b)) { b = __SEGGER_RTL_float32_signbit_copy(0, b); }

      Recalc = 1;
    }

    if (!Recalc && (__SEGGER_RTL_float32_isinf_inline(ac) || __SEGGER_RTL_float32_isinf_inline(bd) || __SEGGER_RTL_float32_isinf_inline(ad) || __SEGGER_RTL_float32_isinf_inline(bc))) {
      if (__SEGGER_RTL_float32_isnan_inline(a)) { a = __SEGGER_RTL_float32_signbit_copy(0.0f, a); }
      if (__SEGGER_RTL_float32_isnan_inline(b)) { b = __SEGGER_RTL_float32_signbit_copy(0.0f, b); }
      if (__SEGGER_RTL_float32_isnan_inline(c)) { c = __SEGGER_RTL_float32_signbit_copy(0.0f, c); }
      if (__SEGGER_RTL_float32_isnan_inline(d)) { d = __SEGGER_RTL_float32_signbit_copy(0.0f, d); }

      Recalc = 1;
    }

    if (Recalc) {
      Zre = SEGGER_MULF(K_INF_F32, SEGGER_SUBF(SEGGER_MULF(a, c), SEGGER_MULF(b, d)));
      Zim = SEGGER_MULF(K_INF_F32, SEGGER_ADDF(SEGGER_MULF(a, d), SEGGER_MULF(b, c)));
    }
  }

  pX->u.part.Re = Zre;
  pX->u.part.Im = Zim;
}
# 16312 "./floatops.c"
static __SEGGER_RTL_INLINE void __SEGGER_RTL_float64_cmul(__SEGGER_RTL_FLOAT64_COMPLEX *pX, const __SEGGER_RTL_FLOAT64_COMPLEX *pY) {
  double a;
  double b;
  double c;
  double d;
  double Zre;
  double Zim;
  double ac;
  double bd;
  double ad;
  double bc;
  int Recalc;

  a = pX->u.part.Re;
  b = pX->u.part.Im;
  c = pY->u.part.Re;
  d = pY->u.part.Im;

  ac = SEGGER_MUL(a, c);
  bd = SEGGER_MUL(b, d);
  ad = SEGGER_MUL(a, d);
  bc = SEGGER_MUL(b, c);

  Zre = SEGGER_SUB(ac, bd);
  Zim = SEGGER_ADD(ad, bc);

  if (__SEGGER_RTL_float64_isnan_inline(Zre) && __SEGGER_RTL_float64_isnan_inline(Zim)) {

    Recalc = 0;

    if (__SEGGER_RTL_float64_isinf_inline(a) || __SEGGER_RTL_float64_isinf_inline(b)) {
      a = __SEGGER_RTL_float64_signbit_copy(__SEGGER_RTL_float64_isinf_inline(a) ? 1.0 : 0.0, a);
      b = __SEGGER_RTL_float64_signbit_copy(__SEGGER_RTL_float64_isinf_inline(b) ? 1.0 : 0.0, b);
      if (__SEGGER_RTL_float64_isnan_inline(c)) { c = __SEGGER_RTL_float64_signbit_copy(0, c); }
      if (__SEGGER_RTL_float64_isnan_inline(d)) { d = __SEGGER_RTL_float64_signbit_copy(0, d); }

      Recalc = 1;
    }

    if (__SEGGER_RTL_float64_isinf_inline(c) || __SEGGER_RTL_float64_isinf_inline(d)) {
      c = __SEGGER_RTL_float64_signbit_copy(__SEGGER_RTL_float64_isinf_inline(c) ? 1.0 : 0.0, c);
      d = __SEGGER_RTL_float64_signbit_copy(__SEGGER_RTL_float64_isinf_inline(d) ? 1.0 : 0.0, d);
      if (__SEGGER_RTL_float64_isnan_inline(a)) { a = __SEGGER_RTL_float64_signbit_copy(0, a); }
      if (__SEGGER_RTL_float64_isnan_inline(b)) { b = __SEGGER_RTL_float64_signbit_copy(0, b); }

      Recalc = 1;
    }

    if (!Recalc && (__SEGGER_RTL_float64_isinf_inline(ac) || __SEGGER_RTL_float64_isinf_inline(bd) || __SEGGER_RTL_float64_isinf_inline(ad) || __SEGGER_RTL_float64_isinf_inline(bc))) {
      if (__SEGGER_RTL_float64_isnan_inline(a)) { a = __SEGGER_RTL_float64_signbit_copy(0.0, a); }
      if (__SEGGER_RTL_float64_isnan_inline(b)) { b = __SEGGER_RTL_float64_signbit_copy(0.0, b); }
      if (__SEGGER_RTL_float64_isnan_inline(c)) { c = __SEGGER_RTL_float64_signbit_copy(0.0, c); }
      if (__SEGGER_RTL_float64_isnan_inline(d)) { d = __SEGGER_RTL_float64_signbit_copy(0.0, d); }

      Recalc = 1;
    }

    if (Recalc) {
      Zre = SEGGER_MUL(K_INF_F64, SEGGER_SUB(SEGGER_MUL(a, c), SEGGER_MUL(b, d)));
      Zim = SEGGER_MUL(K_INF_F64, SEGGER_ADD(SEGGER_MUL(a, d), SEGGER_MUL(b, c)));
    }
  }

  pX->u.part.Re = Zre;
  pX->u.part.Im = Zim;
}
# 16390 "./floatops.c"
static __SEGGER_RTL_INLINE void __SEGGER_RTL_float32_cdiv(__SEGGER_RTL_FLOAT32_COMPLEX *pX, const __SEGGER_RTL_FLOAT32_COMPLEX *pY) {
  float a;
  float b;
  float c;
  float d;
  float denom;
  float x;
  float y;
  int ilogbw;

  a = pX->u.part.Re;
  b = pX->u.part.Im;
  c = pY->u.part.Re;
  d = pY->u.part.Im;

  ilogbw = SEGGER_ILOGBF(__SEGGER_RTL_float32_fmax_inline(SEGGER_FABSF(c), SEGGER_FABSF(d)));
  if (0 <= ilogbw && ilogbw < 1024) {
    c = SEGGER_LDEXPF(c, -ilogbw - 1);
    d = SEGGER_LDEXPF(d, -ilogbw - 1);
  } else {
    ilogbw = 0;
  }

  denom = SEGGER_ADDF(SEGGER_MULF(c, c), SEGGER_MULF(d, d));
  x = SEGGER_LDEXPF(SEGGER_DIVF(SEGGER_ADDF(SEGGER_MULF(a, c), SEGGER_MULF(b, d)), denom), -ilogbw - 1);
  y = SEGGER_LDEXPF(SEGGER_DIVF(SEGGER_SUBF(SEGGER_MULF(b, c), SEGGER_MULF(a, d)), denom), -ilogbw - 1);




  if (__SEGGER_RTL_float32_isnan_inline(x) && __SEGGER_RTL_float32_isnan_inline(y)) {
    if (SEGGER_EQ0F(denom) && (!__SEGGER_RTL_float32_isnan_inline(a) || !__SEGGER_RTL_float32_isnan_inline(b))) {
      x = SEGGER_MULF(__SEGGER_RTL_float32_signbit_copy(__SEGGER_RTL_INFINITY, c), a);
      y = SEGGER_MULF(__SEGGER_RTL_float32_signbit_copy(__SEGGER_RTL_INFINITY, c), b);
    } else if ((__SEGGER_RTL_float32_isinf_inline(a) || __SEGGER_RTL_float32_isinf_inline(b)) && __SEGGER_RTL_float32_isfinite_inline(c) && __SEGGER_RTL_float32_isfinite_inline(d)) {
      a = __SEGGER_RTL_float32_signbit_copy(__SEGGER_RTL_float32_isinf_inline(a) ? 1.0f : 0.0f, a);
      b = __SEGGER_RTL_float32_signbit_copy(__SEGGER_RTL_float32_isinf_inline(b) ? 1.0f : 0.0f, b);
      x = SEGGER_MULF(__SEGGER_RTL_INFINITY, SEGGER_ADDF(SEGGER_MULF(a, c), SEGGER_MULF(b, d)));
      y = SEGGER_MULF(__SEGGER_RTL_INFINITY, SEGGER_SUBF(SEGGER_MULF(b, c), SEGGER_MULF(a, d)));
    } else if ((ilogbw == K_INT_MAX) && __SEGGER_RTL_float32_isfinite_inline(a) && __SEGGER_RTL_float32_isfinite_inline(b)) {
      c = __SEGGER_RTL_float32_signbit_copy(__SEGGER_RTL_float32_isinf_inline(c) ? 1.0f : 0.0f, c);
      d = __SEGGER_RTL_float32_signbit_copy(__SEGGER_RTL_float32_isinf_inline(d) ? 1.0f : 0.0f, d);
      x = SEGGER_MULF(0.0f, SEGGER_MULF(a, c) + SEGGER_MULF(b, d));
      y = SEGGER_MULF(0.0f, SEGGER_MULF(b, c) - SEGGER_MULF(a, d));
    }
  }

  pX->u.part.Re = x;
  pX->u.part.Im = y;
}
# 16452 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE void __SEGGER_RTL_float64_cdiv_inline(__SEGGER_RTL_FLOAT64_COMPLEX *pX, const __SEGGER_RTL_FLOAT64_COMPLEX *pY) {
  double a;
  double b;
  double c;
  double d;
  double denom;
  double x;
  double y;
  int ilogbw;

  a = pX->u.part.Re;
  b = pX->u.part.Im;
  c = pY->u.part.Re;
  d = pY->u.part.Im;

  ilogbw = SEGGER_ILOGB(__SEGGER_RTL_float64_fmax_inline(SEGGER_FABS(c), SEGGER_FABS(d)));
  if (0 <= ilogbw && ilogbw < 1024) {
    c = SEGGER_LDEXP(c, -ilogbw - 1);
    d = SEGGER_LDEXP(d, -ilogbw - 1);
  } else {
    ilogbw = 0;
  }

  denom = SEGGER_ADD(SEGGER_MUL(c, c), SEGGER_MUL(d, d));
  x = SEGGER_LDEXP(SEGGER_DIV(SEGGER_ADD(SEGGER_MUL(a, c), SEGGER_MUL(b, d)), denom), -ilogbw - 1);
  y = SEGGER_LDEXP(SEGGER_DIV(SEGGER_SUB(SEGGER_MUL(b, c), SEGGER_MUL(a, d)), denom), -ilogbw - 1);




  if (__SEGGER_RTL_float64_isnan_inline(x) && __SEGGER_RTL_float64_isnan_inline(y)) {
    if (SEGGER_EQ0(denom) && (!__SEGGER_RTL_float64_isnan_inline(a) || !__SEGGER_RTL_float64_isnan_inline(b))) {
      x = SEGGER_MUL(__SEGGER_RTL_float64_signbit_copy(__SEGGER_RTL_INFINITY, c), a);
      y = SEGGER_MUL(__SEGGER_RTL_float64_signbit_copy(__SEGGER_RTL_INFINITY, c), b);
    } else if ((__SEGGER_RTL_float64_isinf_inline(a) || __SEGGER_RTL_float64_isinf_inline(b)) && __SEGGER_RTL_float64_isfinite_inline(c) && __SEGGER_RTL_float64_isfinite_inline(d)) {
      a = __SEGGER_RTL_float64_signbit_copy(__SEGGER_RTL_float64_isinf_inline(a) ? 1.0 : 0.0, a);
      b = __SEGGER_RTL_float64_signbit_copy(__SEGGER_RTL_float64_isinf_inline(b) ? 1.0 : 0.0, b);
      x = SEGGER_MUL(__SEGGER_RTL_INFINITY, SEGGER_ADD(SEGGER_MUL(a, c), SEGGER_MUL(b, d)));
      y = SEGGER_MUL(__SEGGER_RTL_INFINITY, SEGGER_SUB(SEGGER_MUL(b, c), SEGGER_MUL(a, d)));
    } else if ((ilogbw == K_INT_MAX) && __SEGGER_RTL_float64_isfinite_inline(a) && __SEGGER_RTL_float64_isfinite_inline(b)) {
      c = __SEGGER_RTL_float64_signbit_copy(__SEGGER_RTL_float64_isinf_inline(c) ? 1.0 : 0.0, c);
      d = __SEGGER_RTL_float64_signbit_copy(__SEGGER_RTL_float64_isinf_inline(d) ? 1.0 : 0.0, d);
      x = SEGGER_MUL(0.0, SEGGER_MUL(a, c) + SEGGER_MUL(b, d));
      y = SEGGER_MUL(0.0, SEGGER_MUL(b, c) - SEGGER_MUL(a, d));
    }
  }

  pX->u.part.Re = x;
  pX->u.part.Im = y;
}
# 16514 "./floatops.c"
static void __SEGGER_RTL_NEVER_INLINE __SEGGER_RTL_float64_cdiv_outline(__SEGGER_RTL_FLOAT64_COMPLEX *pX, const __SEGGER_RTL_FLOAT64_COMPLEX *pY) {
  __SEGGER_RTL_float64_cdiv_inline(pX, pY);
}
# 16532 "./floatops.c"
static __SEGGER_RTL_INLINE void __SEGGER_RTL_float32_cdiv2(__SEGGER_RTL_FLOAT32_COMPLEX *pX) {
  pX->u.part.Re = SEGGER_DIV2F(pX->u.part.Re);
  pX->u.part.Im = SEGGER_DIV2F(pX->u.part.Im);
}
# 16551 "./floatops.c"
static __SEGGER_RTL_INLINE void __SEGGER_RTL_float64_cdiv2(__SEGGER_RTL_FLOAT64_COMPLEX *pX) {
  pX->u.part.Re = SEGGER_DIV2(pX->u.part.Re);
  pX->u.part.Im = SEGGER_DIV2(pX->u.part.Im);
}
# 16571 "./floatops.c"
static __SEGGER_RTL_INLINE void __SEGGER_RTL_float32_cmuli(__SEGGER_RTL_FLOAT32_COMPLEX *pX) {
  float t;

  t = pX->u.part.Re;
  pX->u.part.Re = pX->u.part.Im;
  pX->u.part.Im = SEGGER_NEGF(t);
}
# 16594 "./floatops.c"
static __SEGGER_RTL_INLINE void __SEGGER_RTL_float64_cmuli(__SEGGER_RTL_FLOAT64_COMPLEX *pX) {
  double t;

  t = pX->u.part.Re;
  pX->u.part.Re = pX->u.part.Im;
  pX->u.part.Im = SEGGER_NEG(t);
}
# 16617 "./floatops.c"
static __SEGGER_RTL_INLINE void __SEGGER_RTL_float32_cdivi(__SEGGER_RTL_FLOAT32_COMPLEX *pX) {
  float t;

  t = pX->u.part.Re;
  pX->u.part.Re = SEGGER_NEGF(pX->u.part.Im);
  pX->u.part.Im = t;
}
# 16640 "./floatops.c"
static __SEGGER_RTL_INLINE void __SEGGER_RTL_float64_cdivi(__SEGGER_RTL_FLOAT64_COMPLEX *pX) {
  double t;

  t = pX->u.part.Re;
  pX->u.part.Re = SEGGER_NEG(pX->u.part.Im);
  pX->u.part.Im = t;
}
# 16658 "./floatops.c"
static __SEGGER_RTL_INLINE void __SEGGER_RTL_float32_cneg(__SEGGER_RTL_FLOAT32_COMPLEX *pX) {
  pX->u.part.Re = SEGGER_NEGF(pX->u.part.Re);
  pX->u.part.Im = SEGGER_NEGF(pX->u.part.Im);
}
# 16673 "./floatops.c"
static __SEGGER_RTL_INLINE void __SEGGER_RTL_float64_cneg(__SEGGER_RTL_FLOAT64_COMPLEX *pX) {
  pX->u.part.Re = SEGGER_NEG(pX->u.part.Re);
  pX->u.part.Im = SEGGER_NEG(pX->u.part.Im);
}
# 16688 "./floatops.c"
static __SEGGER_RTL_INLINE void __SEGGER_RTL_float32_ccnj(__SEGGER_RTL_FLOAT32_COMPLEX *pX) {
  pX->u.part.Im = SEGGER_NEGF(pX->u.part.Im);
}
# 16702 "./floatops.c"
static __SEGGER_RTL_INLINE void __SEGGER_RTL_float64_ccnj(__SEGGER_RTL_FLOAT64_COMPLEX *pX) {
  pX->u.part.Im = SEGGER_NEG(pX->u.part.Im);
}
# 16726 "./floatops.c"
static __SEGGER_RTL_INLINE void __SEGGER_RTL_float32_cproj(__SEGGER_RTL_FLOAT32_COMPLEX *pX) {
  if (__SEGGER_RTL_float32_isinf_inline(pX->u.part.Re) || __SEGGER_RTL_float32_isinf_inline(pX->u.part.Im)) {
    pX->u.part.Re = K_INF_F32;
    pX->u.part.Im = __SEGGER_RTL_float32_signbit_copy(0.0f, pX->u.part.Im);
  }
}
# 16753 "./floatops.c"
static __SEGGER_RTL_INLINE void __SEGGER_RTL_float64_cproj(__SEGGER_RTL_FLOAT64_COMPLEX *pX) {
  if (__SEGGER_RTL_float64_isinf_inline(pX->u.part.Re) || __SEGGER_RTL_float64_isinf_inline(pX->u.part.Im)) {
    pX->u.part.Re = K_INF_F64;
    pX->u.part.Im = __SEGGER_RTL_float64_signbit_copy(0.0, pX->u.part.Im);
  }
}
# 16770 "./floatops.c"
static __SEGGER_RTL_INLINE void __SEGGER_RTL_float32_csqrt(__SEGGER_RTL_FLOAT32_COMPLEX *pX) {
  float Re;
  float Im;
  float r;
  float s;

  Re = SEGGER_FABSF(pX->u.part.Re);
  Im = SEGGER_FABSF(pX->u.part.Im);

  if (SEGGER_GTF(Re, Im)) {
    r = SEGGER_DIVF(Im, Re);
    s = SEGGER_ADDF(SEGGER_SQRTF(SEGGER_ADDF(1, SEGGER_MULF(r, r))), 1);
    Re = SEGGER_SQRTF(SEGGER_LDEXPF(SEGGER_MULF(Re, s), -1));
    Im = SEGGER_SQRTF(SEGGER_DIVF(SEGGER_MULF(Im, r), SEGGER_LDEXPF(s, 1)));
  } else if (SEGGER_EQ0F(Im)) {
    Re = SEGGER_SQRTF(Re);
  } else {
    r = SEGGER_DIVF(Re, Im);
    s = SEGGER_ADDF(SEGGER_SQRTF(SEGGER_ADDF(1, SEGGER_MULF(r, r))), r);
    Re = SEGGER_SQRTF(SEGGER_LDEXPF(SEGGER_MULF(Im, s), -1));
    Im = SEGGER_SQRTF(SEGGER_DIVF(Im, SEGGER_LDEXPF(s, 1)));
  }

  if (__SEGGER_RTL_float32_signbit_inline(pX->u.part.Re)) {
    r = Re;
    Re = Im;
    Im = r;
  }
  if (__SEGGER_RTL_float32_signbit_inline(pX->u.part.Im)) {
    Im = SEGGER_NEGF(Im);
  }



  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_isnan_inline(Im))) {

    if (__SEGGER_RTL_float32_isinf_inline(pX->u.part.Im)) {




      Re = __SEGGER_RTL_BitcastToF32(K_INF_U32);
      Im = pX->u.part.Im;

    } else if (__SEGGER_RTL_float32_isposinf_inline(pX->u.part.Re)) {



      Re = __SEGGER_RTL_BitcastToF32(K_INF_U32);

    } else if (__SEGGER_RTL_float32_isneginf_inline(pX->u.part.Re)) {



      Im = __SEGGER_RTL_BitcastToF32(K_INF_U32);

    } else if (__SEGGER_RTL_float32_isnan_inline(pX->u.part.Re)) {



      Re = __SEGGER_RTL_BitcastToF32(K_NAN_U32);
      Im = __SEGGER_RTL_BitcastToF32(K_NAN_U32);
    }
  } else if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_isnan_inline(pX->u.part.Re))) {



    Im = __SEGGER_RTL_BitcastToF32(K_NAN_U32);
  }

  pX->u.part.Re = Re;
  pX->u.part.Im = Im;
}
# 16854 "./floatops.c"
static __SEGGER_RTL_INLINE void __SEGGER_RTL_float64_csqrt(__SEGGER_RTL_FLOAT64_COMPLEX *pX) {
  double Re;
  double Im;
  double r;
  double s;

  Re = SEGGER_FABS(pX->u.part.Re);
  Im = SEGGER_FABS(pX->u.part.Im);

  if (SEGGER_GT(Re, Im)) {
    r = SEGGER_DIV(Im, Re);
    s = SEGGER_ADD(SEGGER_SQRT(SEGGER_ADD(1, SEGGER_MUL(r, r))), 1);
    Re = SEGGER_SQRT(SEGGER_LDEXP(SEGGER_MUL(Re, s), -1));
    Im = SEGGER_SQRT(SEGGER_DIV(SEGGER_MUL(Im, r), SEGGER_LDEXP(s, 1)));
  } else if (SEGGER_EQ0(Im)) {
    Re = SEGGER_SQRT(Re);
  } else {
    r = SEGGER_DIV(Re, Im);
    s = SEGGER_ADD(SEGGER_SQRT(SEGGER_ADD(1, SEGGER_MUL(r, r))), r);
    Re = SEGGER_SQRT(SEGGER_LDEXP(SEGGER_MUL(Im, s), -1));
    Im = SEGGER_SQRT(SEGGER_DIV(Im, SEGGER_LDEXP(s, 1)));
  }

  if (__SEGGER_RTL_float64_signbit_inline(pX->u.part.Re)) {
    r = Re;
    Re = Im;
    Im = r;
  }
  if (__SEGGER_RTL_float64_signbit_inline(pX->u.part.Im)) {
    Im = SEGGER_NEG(Im);
  }



  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_isnan_inline(Im))) {

    if (__SEGGER_RTL_float64_isinf_inline(pX->u.part.Im)) {




      Re = __SEGGER_RTL_BitcastToF64(K_INF_U64);
      Im = pX->u.part.Im;

    } else if (__SEGGER_RTL_float64_isposinf_inline(pX->u.part.Re)) {



      Re = __SEGGER_RTL_BitcastToF64(K_INF_U64);

    } else if (__SEGGER_RTL_float64_isneginf_inline(pX->u.part.Re)) {



      Im = __SEGGER_RTL_BitcastToF64(K_INF_U64);

    } else if (__SEGGER_RTL_float64_isnan_inline(pX->u.part.Re)) {



      Re = __SEGGER_RTL_BitcastToF64(K_NAN_U64);
      Im = __SEGGER_RTL_BitcastToF64(K_NAN_U64);
    }
  } else if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_isnan_inline(pX->u.part.Re))) {



    Im = __SEGGER_RTL_BitcastToF64(K_NAN_U64);
  }

  pX->u.part.Re = Re;
  pX->u.part.Im = Im;
}
# 16962 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE void __SEGGER_RTL_float32_clog_inline(__SEGGER_RTL_FLOAT32_COMPLEX *pX) {
  float mag;
  float arg;

  mag = SEGGER_LOGF(SEGGER_HYPOTF(pX->u.part.Re, pX->u.part.Im));
  arg = SEGGER_ATAN2F(pX->u.part.Im, pX->u.part.Re);

  pX->u.part.Re = mag;
  pX->u.part.Im = arg;
}
# 16986 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE void __SEGGER_RTL_float64_clog_inline(__SEGGER_RTL_FLOAT64_COMPLEX *pX) {
  double mag;
  double arg;

  mag = SEGGER_LOG(SEGGER_HYPOT(pX->u.part.Re, pX->u.part.Im));
  arg = SEGGER_ATAN2(pX->u.part.Im, pX->u.part.Re);

  pX->u.part.Re = mag;
  pX->u.part.Im = arg;
}
# 17010 "./floatops.c"
static __SEGGER_RTL_INLINE void __SEGGER_RTL_float32_clog(__SEGGER_RTL_FLOAT32_COMPLEX *pX) {
  __SEGGER_RTL_float32_clog_inline(pX);
}
# 17027 "./floatops.c"
static __SEGGER_RTL_INLINE void __SEGGER_RTL_float64_clog(__SEGGER_RTL_FLOAT64_COMPLEX *pX) {
  __SEGGER_RTL_float64_clog_inline(pX);
}
# 17070 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE void __SEGGER_RTL_float32_cexp_inline(__SEGGER_RTL_FLOAT32_COMPLEX *pX) {
  __SEGGER_RTL_FLOAT32_COMPLEX Result;
  float eX;



  eX = SEGGER_EXPF(pX->u.part.Re);
  Result.u.part.Re = SEGGER_MULF(eX, SEGGER_COSF(pX->u.part.Im));
  Result.u.part.Im = SEGGER_MULF(eX, SEGGER_SINF(pX->u.part.Im));



  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_isnan_inline(Result.u.part.Im))) {

    if (__SEGGER_RTL_BitcastToU32_inline(pX->u.part.Re) == K_MINUS_INF_U32 && !__SEGGER_RTL_float32_isfinite_inline(pX->u.part.Im)) {




      Result.u.part.Re = 0;
      Result.u.part.Im = 0;

    } else if (__SEGGER_RTL_BitcastToU32_inline(pX->u.part.Re) == K_INF_U32 && !__SEGGER_RTL_float32_isfinite_inline(pX->u.part.Im)) {




      Result.u.part.Re = __SEGGER_RTL_BitcastToF32(K_INF_U32);

    } else if (!__SEGGER_RTL_float32_isfinite_inline(pX->u.part.Re) && SEGGER_EQ0F(pX->u.part.Im)) {




      Result = *pX;
    }
  }

  *pX = Result;
}
# 17124 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE void __SEGGER_RTL_float64_cexp_inline(__SEGGER_RTL_FLOAT64_COMPLEX *pX) {
  __SEGGER_RTL_FLOAT64_COMPLEX Result;
  double eX;



  eX = SEGGER_EXP(pX->u.part.Re);
  Result.u.part.Re = SEGGER_MUL(eX, SEGGER_COS(pX->u.part.Im));
  Result.u.part.Im = SEGGER_MUL(eX, SEGGER_SIN(pX->u.part.Im));



  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_isnan_inline(Result.u.part.Im))) {

    if (__SEGGER_RTL_BitcastToU64(pX->u.part.Re) == K_MINUS_INF_U64 && !__SEGGER_RTL_float64_isfinite_inline(pX->u.part.Im)) {




      Result.u.part.Re = 0;
      Result.u.part.Im = 0;

    } else if (__SEGGER_RTL_BitcastToU64(pX->u.part.Re) == K_INF_U64 && !__SEGGER_RTL_float64_isfinite_inline(pX->u.part.Im)) {




      Result.u.part.Re = __SEGGER_RTL_BitcastToF64(K_INF_U64);

    } else if (!__SEGGER_RTL_float64_isfinite_inline(pX->u.part.Re) && SEGGER_EQ0(pX->u.part.Im)) {




      Result = *pX;
    }
  }

  *pX = Result;
}
# 17178 "./floatops.c"
static __SEGGER_RTL_INLINE void __SEGGER_RTL_float32_cexp(__SEGGER_RTL_FLOAT32_COMPLEX *pX) {
  __SEGGER_RTL_float32_cexp_inline(pX);
}
# 17195 "./floatops.c"
static __SEGGER_RTL_INLINE void __SEGGER_RTL_float64_cexp(__SEGGER_RTL_FLOAT64_COMPLEX *pX) {
  __SEGGER_RTL_float64_cexp_inline(pX);
}
# 17210 "./floatops.c"
static __SEGGER_RTL_INLINE void __SEGGER_RTL_float32_cpow(__SEGGER_RTL_FLOAT32_COMPLEX *pX, const __SEGGER_RTL_FLOAT32_COMPLEX *pY) {
  __SEGGER_RTL_float32_clog(pX);
  __SEGGER_RTL_float32_cmul(pX, pY);
  __SEGGER_RTL_float32_cexp(pX);
}
# 17227 "./floatops.c"
static __SEGGER_RTL_INLINE void __SEGGER_RTL_float64_cpow(__SEGGER_RTL_FLOAT64_COMPLEX *pX, const __SEGGER_RTL_FLOAT64_COMPLEX *pY) {
  __SEGGER_RTL_float64_clog(pX);
  __SEGGER_RTL_float64_cmul(pX, pY);
  __SEGGER_RTL_float64_cexp(pX);
}
# 17246 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE void __SEGGER_RTL_float32_csinh_inline(__SEGGER_RTL_FLOAT32_COMPLEX *pX) {
  __SEGGER_RTL_FLOAT32_COMPLEX eMx;

  if (SEGGER_EQ0F(pX->u.part.Re)) {



    pX->u.part.Im = SEGGER_SINF(pX->u.part.Im);

  } else {



    eMx = *pX;
    __SEGGER_RTL_float32_cneg (&eMx);
    __SEGGER_RTL_float32_cexp (&eMx);
    __SEGGER_RTL_float32_cexp (pX);
    __SEGGER_RTL_float32_csub (pX, &eMx);
    __SEGGER_RTL_float32_cdiv2(pX);
  }
}
# 17281 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE void __SEGGER_RTL_float64_csinh_inline(__SEGGER_RTL_FLOAT64_COMPLEX *pX) {
  __SEGGER_RTL_FLOAT64_COMPLEX eMx;

  if (SEGGER_EQ0(pX->u.part.Re)) {



    pX->u.part.Im = SEGGER_SIN(pX->u.part.Im);

  } else {



    eMx = *pX;
    __SEGGER_RTL_float64_cneg (&eMx);
    __SEGGER_RTL_float64_cexp (&eMx);
    __SEGGER_RTL_float64_cexp (pX);
    __SEGGER_RTL_float64_csub (pX, &eMx);
    __SEGGER_RTL_float64_cdiv2(pX);
  }
}
# 17316 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE void __SEGGER_RTL_float32_ccosh_inline(__SEGGER_RTL_FLOAT32_COMPLEX *pX) {
  __SEGGER_RTL_FLOAT32_COMPLEX eMx;
  __SEGGER_RTL_FLOAT32_COMPLEX ePx;
  int Conjugate;

  if (__SEGGER_RTL_float32_signbit_inline(pX->u.part.Re)) {
    __SEGGER_RTL_float32_cneg(pX);
  }
  Conjugate = __SEGGER_RTL_float32_signbit_inline(pX->u.part.Im);
  if (Conjugate) {
    __SEGGER_RTL_float32_ccnj(pX);
  }

  eMx = *pX;
  ePx = *pX;

  __SEGGER_RTL_float32_cneg (&eMx);
  __SEGGER_RTL_float32_cexp (&eMx);
  __SEGGER_RTL_float32_cexp (&ePx);
  __SEGGER_RTL_float32_cadd (&ePx, &eMx);
  __SEGGER_RTL_float32_cdiv2(&ePx);



  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_isnan_inline(ePx.u.part.Re))) {

    if (!__SEGGER_RTL_float32_isfinite_inline(pX->u.part.Im)) {

      if (SEGGER_EQ0F(pX->u.part.Re)) {




        ePx.u.part.Im = 0;

      } else if (__SEGGER_RTL_float32_isinf_inline(pX->u.part.Re)) {



        ePx.u.part.Re = __SEGGER_RTL_BitcastToF32(K_INF_U32);
      }
    } else if (__SEGGER_RTL_float32_isnan_inline(pX->u.part.Re)) {

      if (SEGGER_EQ0F(pX->u.part.Im)) {



        ePx.u.part.Im = 0;
      }
    }
  }

  if (Conjugate) {
    __SEGGER_RTL_float32_ccnj(&ePx);
  }

  *pX = ePx;
}
# 17388 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE void __SEGGER_RTL_float64_ccosh_inline(__SEGGER_RTL_FLOAT64_COMPLEX *pX) {
  __SEGGER_RTL_FLOAT64_COMPLEX eMx;
  __SEGGER_RTL_FLOAT64_COMPLEX ePx;
  int Conjugate;

  if (__SEGGER_RTL_float64_signbit_inline(pX->u.part.Re)) {
    __SEGGER_RTL_float64_cneg(pX);
  }
  Conjugate = __SEGGER_RTL_float64_signbit_inline(pX->u.part.Im);
  if (Conjugate) {
    __SEGGER_RTL_float64_ccnj(pX);
  }

  eMx = *pX;
  ePx = *pX;

  __SEGGER_RTL_float64_cneg (&eMx);
  __SEGGER_RTL_float64_cexp (&eMx);
  __SEGGER_RTL_float64_cexp (&ePx);
  __SEGGER_RTL_float64_cadd (&ePx, &eMx);
  __SEGGER_RTL_float64_cdiv2(&ePx);



  if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_isnan_inline(ePx.u.part.Re))) {

    if (!__SEGGER_RTL_float64_isfinite_inline(pX->u.part.Im)) {

      if (SEGGER_EQ0(pX->u.part.Re)) {




        ePx.u.part.Im = 0;

      } else if (__SEGGER_RTL_float64_isinf_inline(pX->u.part.Re)) {



        ePx.u.part.Re = __SEGGER_RTL_BitcastToF64(K_INF_U64);
      }
    } else if (__SEGGER_RTL_float64_isnan_inline(pX->u.part.Re)) {

      if (SEGGER_EQ0(pX->u.part.Im)) {



        ePx.u.part.Im = 0;
      }
    }
  }

  if (Conjugate) {
    __SEGGER_RTL_float64_ccnj(&ePx);
  }

  *pX = ePx;
}
# 17462 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE void __SEGGER_RTL_float32_ctanh_inline(__SEGGER_RTL_FLOAT32_COMPLEX *pX) {
  __SEGGER_RTL_FLOAT32_COMPLEX Result;
  float s;

  if (SEGGER_EQ0F(pX->u.part.Re)) {



    pX->u.part.Im = SEGGER_TANF(pX->u.part.Im);



    if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_isnan_inline(pX->u.part.Im))) {




      pX->u.part.Re = pX->u.part.Im;
    }

  } else if (SEGGER_EQ0F(pX->u.part.Im)) {



    pX->u.part.Re = SEGGER_TANHF(pX->u.part.Re);

  } else {



    Result.u.part.Re = SEGGER_MUL2F(pX->u.part.Re);
    Result.u.part.Im = SEGGER_MUL2F(pX->u.part.Im);

    s = SEGGER_ADDF(SEGGER_COSHF(Result.u.part.Re), SEGGER_COSF(Result.u.part.Im));

    Result.u.part.Re = SEGGER_DIVF(SEGGER_SINHF(Result.u.part.Re), s);
    Result.u.part.Im = SEGGER_DIVF(SEGGER_SINF (Result.u.part.Im), s);



    if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float32_isnan_inline(Result.u.part.Re))) {

      if (__SEGGER_RTL_float32_isinf_inline(pX->u.part.Re)) {




        Result.u.part.Re = __SEGGER_RTL_float32_signbit_xor(1, pX->u.part.Re);
        if (__SEGGER_RTL_float32_isnan_inline(Result.u.part.Im)) {
          Result.u.part.Im = 0;
        }
      }
    }

    *pX = Result;
  }
}
# 17535 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE void __SEGGER_RTL_float64_ctanh_inline(__SEGGER_RTL_FLOAT64_COMPLEX *pX) {
  __SEGGER_RTL_FLOAT64_COMPLEX Result;
  double s;

  if (SEGGER_EQ0(pX->u.part.Re)) {



    pX->u.part.Im = SEGGER_TAN(pX->u.part.Im);



    if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_isnan_inline(pX->u.part.Im))) {




      pX->u.part.Re = pX->u.part.Im;
    }

  } else if (SEGGER_EQ0(pX->u.part.Im)) {



    pX->u.part.Re = SEGGER_TANH(pX->u.part.Re);

  } else {



    Result.u.part.Re = SEGGER_MUL2(pX->u.part.Re);
    Result.u.part.Im = SEGGER_MUL2(pX->u.part.Im);

    s = SEGGER_ADD(SEGGER_COSH(Result.u.part.Re), SEGGER_COS(Result.u.part.Im));

    Result.u.part.Re = SEGGER_DIV(SEGGER_SINH(Result.u.part.Re), s);
    Result.u.part.Im = SEGGER_DIV(SEGGER_SIN (Result.u.part.Im), s);



    if (__SEGGER_RTL_UNLIKELY(__SEGGER_RTL_float64_isnan_inline(Result.u.part.Re))) {

      if (__SEGGER_RTL_float64_isinf_inline(pX->u.part.Re)) {




        Result.u.part.Re = __SEGGER_RTL_float64_signbit_xor(1, pX->u.part.Re);
        if (__SEGGER_RTL_float64_isnan_inline(Result.u.part.Im)) {
          Result.u.part.Im = 0;
        }
      }
    }

    *pX = Result;
  }
}
# 17606 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE void __SEGGER_RTL_float32_csin_inline(__SEGGER_RTL_FLOAT32_COMPLEX *pX) {
  __SEGGER_RTL_float32_cmuli (pX);
  __SEGGER_RTL_float32_csinh_inline(pX);
  __SEGGER_RTL_float32_cdivi (pX);
}
# 17625 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE void __SEGGER_RTL_float64_csin_inline(__SEGGER_RTL_FLOAT64_COMPLEX *pX) {
  __SEGGER_RTL_float64_cmuli (pX);
  __SEGGER_RTL_float64_csinh_inline(pX);
  __SEGGER_RTL_float64_cdivi (pX);
}
# 17645 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE void __SEGGER_RTL_float32_ccos_inline(__SEGGER_RTL_FLOAT32_COMPLEX *pX) {
  __SEGGER_RTL_float32_cmuli (pX);
  __SEGGER_RTL_float32_ccosh_inline(pX);
}
# 17664 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE void __SEGGER_RTL_float64_ccos_inline(__SEGGER_RTL_FLOAT64_COMPLEX *pX) {
  __SEGGER_RTL_float64_cmuli (pX);
  __SEGGER_RTL_float64_ccosh_inline(pX);
}
# 17686 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE void __SEGGER_RTL_float32_ctan_inline(__SEGGER_RTL_FLOAT32_COMPLEX *pX) {
  __SEGGER_RTL_float32_cmuli (pX);
  __SEGGER_RTL_float32_ctanh_inline(pX);
  __SEGGER_RTL_float32_cdivi (pX);
}
# 17709 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE void __SEGGER_RTL_float64_ctan_inline(__SEGGER_RTL_FLOAT64_COMPLEX *pX) {
  __SEGGER_RTL_float64_cmuli (pX);
  __SEGGER_RTL_float64_ctanh_inline(pX);
  __SEGGER_RTL_float64_cdivi (pX);
}
# 17728 "./floatops.c"
static __SEGGER_RTL_INLINE void __SEGGER_RTL_float32_casinh(__SEGGER_RTL_FLOAT32_COMPLEX *pX) {
  __SEGGER_RTL_FLOAT32_COMPLEX Result;
  __SEGGER_RTL_FLOAT32_COMPLEX Z;
  int ReSign;
  int ImSign;

  Z = *pX;

  ReSign = __SEGGER_RTL_float32_signbit_inline(Z.u.part.Re);
  if (ReSign) {
    __SEGGER_RTL_float32_cneg(&Z);
  }
  ImSign = __SEGGER_RTL_float32_signbit_inline(Z.u.part.Im);
  if (ImSign) {
    __SEGGER_RTL_float32_ccnj(&Z);
  }

  Result = Z;
  __SEGGER_RTL_float32_cmul(&Result, &Result);
  Result.u.part.Re = SEGGER_ADDF(Result.u.part.Re, 1.0f);
  __SEGGER_RTL_float32_csqrt(&Result);
  __SEGGER_RTL_float32_cadd(&Result, &Z);
  __SEGGER_RTL_float32_clog(&Result);

  if (ImSign) {
    __SEGGER_RTL_float32_ccnj(&Result);
  }
  if (ReSign) {
    __SEGGER_RTL_float32_cneg(&Result);
  }



  if (__SEGGER_RTL_UNLIKELY(!__SEGGER_RTL_float32_isfinite_inline(Result.u.part.Re))) {

    if (__SEGGER_RTL_float32_isfinite_inline(Z.u.part.Re) && __SEGGER_RTL_float32_isinf_inline(Z.u.part.Im)) {
      Result.u.part.Im = __SEGGER_RTL_float32_signbit_xor((float)M_PI_2, Result.u.part.Im);
    } else if (__SEGGER_RTL_float32_isnan_inline(Z.u.part.Re) && SEGGER_EQ0F(Z.u.part.Im)) {
      Result.u.part.Im = pX->u.part.Im;
    } else if (__SEGGER_RTL_float32_isinf_inline(Z.u.part.Re) && __SEGGER_RTL_float32_isfinite_inline(pX->u.part.Im)) {
      Result.u.part.Im = __SEGGER_RTL_float32_signbit_copy(0.0f, pX->u.part.Im);
    }
  }

  *pX = Result;
}
# 17788 "./floatops.c"
static __SEGGER_RTL_INLINE void __SEGGER_RTL_float64_casinh(__SEGGER_RTL_FLOAT64_COMPLEX *pX) {
  __SEGGER_RTL_FLOAT64_COMPLEX Result;
  __SEGGER_RTL_FLOAT64_COMPLEX Z;
  int ReSign;
  int ImSign;

  Z = *pX;

  ReSign = __SEGGER_RTL_float64_signbit_inline(Z.u.part.Re);
  if (ReSign) {
    __SEGGER_RTL_float64_cneg(&Z);
  }
  ImSign = __SEGGER_RTL_float64_signbit_inline(Z.u.part.Im);
  if (ImSign) {
    __SEGGER_RTL_float64_ccnj(&Z);
  }

  Result = Z;
  __SEGGER_RTL_float64_cmul(&Result, &Result);
  Result.u.part.Re = SEGGER_ADD(Result.u.part.Re, 1);
  __SEGGER_RTL_float64_csqrt(&Result);
  __SEGGER_RTL_float64_cadd(&Result, &Z);
  __SEGGER_RTL_float64_clog(&Result);

  if (ImSign) {
    __SEGGER_RTL_float64_ccnj(&Result);
  }
  if (ReSign) {
    __SEGGER_RTL_float64_cneg(&Result);
  }



  if (__SEGGER_RTL_UNLIKELY(!__SEGGER_RTL_float64_isfinite_inline(Result.u.part.Re))) {

    if (__SEGGER_RTL_float64_isfinite_inline(Z.u.part.Re) && __SEGGER_RTL_float64_isinf_inline(Z.u.part.Im)) {
      Result.u.part.Im = __SEGGER_RTL_float64_signbit_xor(M_PI_2, Result.u.part.Im);
    } else if (__SEGGER_RTL_float64_isnan_inline(Z.u.part.Re) && SEGGER_EQ0(Z.u.part.Im)) {
      Result.u.part.Im = pX->u.part.Im;
    } else if (__SEGGER_RTL_float64_isinf_inline(Z.u.part.Re) && __SEGGER_RTL_float64_isfinite_inline(pX->u.part.Im)) {
      Result.u.part.Im = __SEGGER_RTL_float64_signbit_copy(0, pX->u.part.Im);
    }
  }

  *pX = Result;
}
# 17848 "./floatops.c"
static __SEGGER_RTL_INLINE void __SEGGER_RTL_float32_cacosh_inline(__SEGGER_RTL_FLOAT32_COMPLEX *pX) {
  __SEGGER_RTL_FLOAT32_COMPLEX T1;
  __SEGGER_RTL_FLOAT32_COMPLEX T2;
  int sign;

  sign = __SEGGER_RTL_float32_signbit_inline(pX->u.part.Im);
  pX->u.part.Im = SEGGER_FABSF(pX->u.part.Im);

  T1 = *pX;
  T1.u.part.Re = SEGGER_ADDF(T1.u.part.Re, 1);
  __SEGGER_RTL_float32_csqrt(&T1);

  T2 = *pX;
  T2.u.part.Re = SEGGER_SUBF(T2.u.part.Re, 1);
  __SEGGER_RTL_float32_csqrt(&T2);

  __SEGGER_RTL_float32_cmul(&T1, &T2);
  __SEGGER_RTL_float32_cadd(&T1, pX);
  __SEGGER_RTL_float32_clog(&T1);



  if (__SEGGER_RTL_BitcastToU32(T1.u.part.Re) == K_INF_U32) {

    if (__SEGGER_RTL_float32_isfinite_inline(pX->u.part.Re)) {



      T1.u.part.Im = (float)M_PI_2;

    } else if (__SEGGER_RTL_BitcastToU32(pX->u.part.Re) == K_INF_U32) {




      if (__SEGGER_RTL_float32_isfinite_inline(pX->u.part.Im)) {
        T1.u.part.Im = 0;
      } else if (__SEGGER_RTL_float32_isinf_inline(pX->u.part.Im)) {
        T1.u.part.Im = (float)M_PI_4;
      }

    } else if (__SEGGER_RTL_BitcastToU32(pX->u.part.Re) == K_MINUS_INF_U32) {




      if (__SEGGER_RTL_float32_isfinite_inline(pX->u.part.Im)) {
        T1.u.part.Im = (float)M_PI;
      } else if (__SEGGER_RTL_float32_isinf_inline(pX->u.part.Im)) {
        T1.u.part.Im = (float)(0.75 * M_PI);
      }
    }
  }

  if (sign) {
    T1.u.part.Im = SEGGER_NEGF(T1.u.part.Im);
  }

  *pX = T1;
}
# 17922 "./floatops.c"
static __SEGGER_RTL_INLINE void __SEGGER_RTL_float64_cacosh_inline(__SEGGER_RTL_FLOAT64_COMPLEX *pX) {
  __SEGGER_RTL_FLOAT64_COMPLEX T1;
  __SEGGER_RTL_FLOAT64_COMPLEX T2;
  int sign;

  sign = __SEGGER_RTL_float64_signbit_inline(pX->u.part.Im);
  pX->u.part.Im = SEGGER_FABS(pX->u.part.Im);

  T1 = *pX;
  T1.u.part.Re = SEGGER_ADD(T1.u.part.Re, 1);
  __SEGGER_RTL_float64_csqrt(&T1);

  T2 = *pX;
  T2.u.part.Re = SEGGER_SUB(T2.u.part.Re, 1);
  __SEGGER_RTL_float64_csqrt(&T2);

  __SEGGER_RTL_float64_cmul(&T1, &T2);
  __SEGGER_RTL_float64_cadd(&T1, pX);
  __SEGGER_RTL_float64_clog(&T1);



  if (__SEGGER_RTL_BitcastToU64(T1.u.part.Re) == K_INF_U64) {

    if (__SEGGER_RTL_float64_isfinite_inline(pX->u.part.Re)) {



      T1.u.part.Im = M_PI_2;

    } else if (__SEGGER_RTL_BitcastToU64(pX->u.part.Re) == K_INF_U64) {




      if (__SEGGER_RTL_float64_isfinite_inline(pX->u.part.Im)) {
        T1.u.part.Im = 0;
      } else if (__SEGGER_RTL_float64_isinf_inline(pX->u.part.Im)) {
        T1.u.part.Im = M_PI_4;
      }

    } else if (__SEGGER_RTL_BitcastToU64(pX->u.part.Re) == K_MINUS_INF_U64) {




      if (__SEGGER_RTL_float64_isfinite_inline(pX->u.part.Im)) {
        T1.u.part.Im = M_PI;
      } else if (__SEGGER_RTL_float64_isinf_inline(pX->u.part.Im)) {
        T1.u.part.Im = 3 * M_PI / 4;
      }
    }
  }

  if (sign) {
    T1.u.part.Im = SEGGER_NEG(T1.u.part.Im);
  }

  *pX = T1;
}
# 17999 "./floatops.c"
static __SEGGER_RTL_INLINE void __SEGGER_RTL_float32_catanh(__SEGGER_RTL_FLOAT32_COMPLEX *pX) {
  __SEGGER_RTL_FLOAT32_COMPLEX tp;
  __SEGGER_RTL_FLOAT32_COMPLEX tm;
  int ReSign;
  int ImSign;
  int Special;

  ReSign = __SEGGER_RTL_float32_signbit_inline(pX->u.part.Re);
  if (ReSign) {
    __SEGGER_RTL_float32_cneg(pX);
  }
  ImSign = __SEGGER_RTL_float32_signbit_inline(pX->u.part.Im);
  if (ImSign) {
    __SEGGER_RTL_float32_ccnj(pX);
  }




  Special = 0;
  if ((!__SEGGER_RTL_float32_isfinite_inline(pX->u.part.Re) || !__SEGGER_RTL_float32_isfinite_inline(pX->u.part.Im))) {

    if (__SEGGER_RTL_float32_isinf_inline(pX->u.part.Re)) {





      tp.u.part.Re = 0;
      tp.u.part.Im = __SEGGER_RTL_float32_isnan_inline(pX->u.part.Im) ? pX->u.part.Im : (float)M_PI_2;
      Special = 1;

    } else if (__SEGGER_RTL_float32_isnan_inline(pX->u.part.Re) && __SEGGER_RTL_float32_isinf_inline(pX->u.part.Im)) {



      tp.u.part.Re = 0;
      tp.u.part.Im = (float)M_PI_2;
      Special = 1;

    } else if (__SEGGER_RTL_float32_isinf_inline(pX->u.part.Im)) {



      tp.u.part.Re = 0;
      tp.u.part.Im = (float)M_PI_2;
      Special = 1;

    } else if (SEGGER_EQ0F(pX->u.part.Re)) {




      tp.u.part.Re = 0;
      tp.u.part.Im = pX->u.part.Im;
      Special = 1;

    }
  } else if (SEGGER_EQF(pX->u.part.Re, 1) && SEGGER_EQ0F(pX->u.part.Im)) {



    tp.u.part.Re = __SEGGER_RTL_BitcastToF32(K_INF_U32);
    tp.u.part.Im = 0;
    Special = 1;
  }

  if (!Special) {



    tp.u.part.Re = SEGGER_ADDF(1, pX->u.part.Re);
    tp.u.part.Im = pX->u.part.Im;

    tm.u.part.Re = SEGGER_SUBF(1, pX->u.part.Re);
    tm.u.part.Im = SEGGER_NEGF(pX->u.part.Im);

    __SEGGER_RTL_float32_cdiv(&tp, &tm);
    __SEGGER_RTL_float32_clog(&tp);
    __SEGGER_RTL_float32_cdiv2(&tp);
  }

  if (ReSign) {
    __SEGGER_RTL_float32_cneg(&tp);
  }
  if (ImSign) {
    __SEGGER_RTL_float32_ccnj(&tp);
  }

  *pX = tp;
}
# 18107 "./floatops.c"
static __SEGGER_RTL_INLINE void __SEGGER_RTL_float64_catanh(__SEGGER_RTL_FLOAT64_COMPLEX *pX) {
  __SEGGER_RTL_FLOAT64_COMPLEX tp;
  __SEGGER_RTL_FLOAT64_COMPLEX tm;
  int ReSign;
  int ImSign;
  int Special;

  ReSign = __SEGGER_RTL_float64_signbit_inline(pX->u.part.Re);
  if (ReSign) {
    __SEGGER_RTL_float64_cneg(pX);
  }
  ImSign = __SEGGER_RTL_float64_signbit_inline(pX->u.part.Im);
  if (ImSign) {
    __SEGGER_RTL_float64_ccnj(pX);
  }




  Special = 0;
  if ((!__SEGGER_RTL_float64_isfinite_inline(pX->u.part.Re) || !__SEGGER_RTL_float64_isfinite_inline(pX->u.part.Im))) {

    if (__SEGGER_RTL_float64_isinf_inline(pX->u.part.Re)) {





      tp.u.part.Re = 0;
      tp.u.part.Im = __SEGGER_RTL_float64_isnan_inline(pX->u.part.Im) ? pX->u.part.Im : M_PI_2;
      Special = 1;

    } else if (__SEGGER_RTL_float64_isnan_inline(pX->u.part.Re) && __SEGGER_RTL_float64_isinf_inline(pX->u.part.Im)) {



      tp.u.part.Re = 0;
      tp.u.part.Im = M_PI_2;
      Special = 1;

    } else if (__SEGGER_RTL_float64_isinf_inline(pX->u.part.Im)) {



      tp.u.part.Re = 0;
      tp.u.part.Im = M_PI_2;
      Special = 1;

    } else if (SEGGER_EQ0(pX->u.part.Re)) {




      tp.u.part.Re = 0;
      tp.u.part.Im = pX->u.part.Im;
      Special = 1;

    }
  } else if (SEGGER_EQ(pX->u.part.Re, 1) && SEGGER_EQ0(pX->u.part.Im)) {



    tp.u.part.Re = __SEGGER_RTL_BitcastToF64(K_INF_U64);
    tp.u.part.Im = 0;
    Special = 1;
  }

  if (!Special) {



    tp.u.part.Re = SEGGER_ADD(1, pX->u.part.Re);
    tp.u.part.Im = pX->u.part.Im;

    tm.u.part.Re = SEGGER_SUB(1, pX->u.part.Re);
    tm.u.part.Im = SEGGER_NEG(pX->u.part.Im);

    __SEGGER_RTL_float64_cdiv_outline(&tp, &tm);
    __SEGGER_RTL_float64_clog(&tp);
    __SEGGER_RTL_float64_cdiv2(&tp);
  }

  if (ReSign) {
    __SEGGER_RTL_float64_cneg(&tp);
  }
  if (ImSign) {
    __SEGGER_RTL_float64_ccnj(&tp);
  }

  *pX = tp;
}
# 18212 "./floatops.c"
static __SEGGER_RTL_INLINE void __SEGGER_RTL_float32_casin(__SEGGER_RTL_FLOAT32_COMPLEX *pX) {
  __SEGGER_RTL_float32_cmuli (pX);
  __SEGGER_RTL_float32_casinh(pX);
  __SEGGER_RTL_float32_cdivi (pX);
}
# 18231 "./floatops.c"
static __SEGGER_RTL_INLINE void __SEGGER_RTL_float64_casin(__SEGGER_RTL_FLOAT64_COMPLEX *pX) {
  __SEGGER_RTL_float64_cmuli (pX);
  __SEGGER_RTL_float64_casinh(pX);
  __SEGGER_RTL_float64_cdivi (pX);
}
# 18250 "./floatops.c"
static __SEGGER_RTL_INLINE void __SEGGER_RTL_float32_cacos(__SEGGER_RTL_FLOAT32_COMPLEX *pX) {
  __SEGGER_RTL_FLOAT32_COMPLEX iz;
  __SEGGER_RTL_FLOAT32_COMPLEX Result;



  iz = *pX;
  __SEGGER_RTL_float32_cmuli(&iz);
  Result.u.part.Re = SEGGER_SUBF(1, SEGGER_MULF(SEGGER_SUBF(pX->u.part.Re, pX->u.part.Im), SEGGER_ADDF(pX->u.part.Re, pX->u.part.Im)));
  Result.u.part.Im = SEGGER_MULM2F(SEGGER_MULF(pX->u.part.Re, pX->u.part.Im));
  __SEGGER_RTL_float32_csqrt(&Result);
  __SEGGER_RTL_float32_cadd (&Result, &iz);
  __SEGGER_RTL_float32_clog (&Result);
  __SEGGER_RTL_float32_cmuli(&Result);
  Result.u.part.Re = SEGGER_ADDF((float)M_PI_2, Result.u.part.Re);



  if (!__SEGGER_RTL_float32_isfinite_inline(Result.u.part.Im)) {

    if (__SEGGER_RTL_float32_isposinf_inline(pX->u.part.Re)) {

      if (__SEGGER_RTL_float32_isfinite_inline(pX->u.part.Im)) {




        Result.u.part.Re = 0;
        Result.u.part.Im = __SEGGER_RTL_float32_signbit_xor(__SEGGER_RTL_BitcastToF32(K_MINUS_INF_U32), pX->u.part.Im);

      } else if (__SEGGER_RTL_float32_isnan_inline(pX->u.part.Im)) {



        Result.u.part.Im = __SEGGER_RTL_BitcastToF32(K_MINUS_INF_U32);

      } else if (__SEGGER_RTL_float32_isneginf_inline(pX->u.part.Im)) {



        Result.u.part.Re = (float)M_PI_4;
        Result.u.part.Im = __SEGGER_RTL_BitcastToF32(K_INF_U32);
      }

    } else if (__SEGGER_RTL_float32_isneginf_inline(pX->u.part.Re)) {

      if (__SEGGER_RTL_float32_isfinite_inline(pX->u.part.Im)) {




        Result.u.part.Re = (float)M_PI;
        Result.u.part.Im = __SEGGER_RTL_float32_signbit_xor(__SEGGER_RTL_BitcastToF32(K_MINUS_INF_U32), pX->u.part.Im);

      } else if (__SEGGER_RTL_float32_isnan_inline(pX->u.part.Im)) {



        Result.u.part.Im = __SEGGER_RTL_BitcastToF32(K_MINUS_INF_U32);

      } else if (__SEGGER_RTL_float32_isneginf_inline(pX->u.part.Im)) {



        Result.u.part.Re = (float)M_3_PI_4;
        Result.u.part.Im = __SEGGER_RTL_BitcastToF32(K_INF_U32);
      }

    } else if (__SEGGER_RTL_float32_isnan_inline(pX->u.part.Re)) {

      if (__SEGGER_RTL_float32_isnan_inline(pX->u.part.Re) && __SEGGER_RTL_float32_isinf_inline(pX->u.part.Im)) {



        Result.u.part.Im = SEGGER_NEGF(pX->u.part.Im);
      }

    } else if (__SEGGER_RTL_float32_isfinite_inline(pX->u.part.Re) && __SEGGER_RTL_float32_isinf_inline(pX->u.part.Im)) {




      Result.u.part.Re = (float)M_PI_2;
      Result.u.part.Im = SEGGER_NEGF(pX->u.part.Im);

    } else if (SEGGER_EQ0F(pX->u.part.Re) && __SEGGER_RTL_float32_isnan_inline(pX->u.part.Im)) {



      Result.u.part.Re = (float)M_PI_2;
    }
  }

  *pX = Result;
}
# 18359 "./floatops.c"
static __SEGGER_RTL_INLINE void __SEGGER_RTL_float64_cacos(__SEGGER_RTL_FLOAT64_COMPLEX *pX) {
  __SEGGER_RTL_FLOAT64_COMPLEX iz;
  __SEGGER_RTL_FLOAT64_COMPLEX Result;



  iz = *pX;
  __SEGGER_RTL_float64_cmuli(&iz);
  Result.u.part.Re = SEGGER_SUB(1, SEGGER_MUL(SEGGER_SUB(pX->u.part.Re, pX->u.part.Im), SEGGER_ADD(pX->u.part.Re, pX->u.part.Im)));
  Result.u.part.Im = SEGGER_MULM2(SEGGER_MUL(pX->u.part.Re, pX->u.part.Im));
  __SEGGER_RTL_float64_csqrt(&Result);
  __SEGGER_RTL_float64_cadd (&Result, &iz);
  __SEGGER_RTL_float64_clog (&Result);
  __SEGGER_RTL_float64_cmuli(&Result);
  Result.u.part.Re = SEGGER_ADD(M_PI_2, Result.u.part.Re);



  if (!__SEGGER_RTL_float64_isfinite_inline(Result.u.part.Im)) {

    if (__SEGGER_RTL_float64_isposinf_inline(pX->u.part.Re)) {

      if (__SEGGER_RTL_float64_isfinite_inline(pX->u.part.Im)) {




        Result.u.part.Re = 0;
        Result.u.part.Im = __SEGGER_RTL_float64_signbit_xor(__SEGGER_RTL_BitcastToF64(K_MINUS_INF_U64), pX->u.part.Im);

      } else if (__SEGGER_RTL_float64_isnan_inline(pX->u.part.Im)) {



        Result.u.part.Im = __SEGGER_RTL_BitcastToF64(K_MINUS_INF_U64);

      } else if (__SEGGER_RTL_float64_isneginf_inline(pX->u.part.Im)) {



        Result.u.part.Re = M_PI_4;
        Result.u.part.Im = __SEGGER_RTL_BitcastToF64(K_INF_U64);
      }

    } else if (__SEGGER_RTL_float64_isneginf_inline(pX->u.part.Re)) {

      if (__SEGGER_RTL_float64_isfinite_inline(pX->u.part.Im)) {




        Result.u.part.Re = M_PI;
        Result.u.part.Im = __SEGGER_RTL_float64_signbit_xor(__SEGGER_RTL_BitcastToF64(K_MINUS_INF_U64), pX->u.part.Im);

      } else if (__SEGGER_RTL_float64_isnan_inline(pX->u.part.Im)) {



        Result.u.part.Im = __SEGGER_RTL_BitcastToF64(K_MINUS_INF_U64);

      } else if (__SEGGER_RTL_float64_isneginf_inline(pX->u.part.Im)) {



        Result.u.part.Re = M_3_PI_4;
        Result.u.part.Im = __SEGGER_RTL_BitcastToF64(K_INF_U64);
      }

    } else if (__SEGGER_RTL_float64_isnan_inline(pX->u.part.Re)) {

      if (__SEGGER_RTL_float64_isnan_inline(pX->u.part.Re) && __SEGGER_RTL_float64_isinf_inline(pX->u.part.Im)) {



        Result.u.part.Im = SEGGER_NEG(pX->u.part.Im);
      }

    } else if (__SEGGER_RTL_float64_isfinite_inline(pX->u.part.Re) && __SEGGER_RTL_float64_isinf_inline(pX->u.part.Im)) {




      Result.u.part.Re = M_PI_2;
      Result.u.part.Im = SEGGER_NEG(pX->u.part.Im);

    } else if (SEGGER_EQ0(pX->u.part.Re) && __SEGGER_RTL_float64_isnan_inline(pX->u.part.Im)) {



      Result.u.part.Re = M_PI_2;
    }
  }

  *pX = Result;
}
# 18471 "./floatops.c"
static __SEGGER_RTL_INLINE void __SEGGER_RTL_float32_catan(__SEGGER_RTL_FLOAT32_COMPLEX *pX) {
  __SEGGER_RTL_float32_cmuli (pX);
  __SEGGER_RTL_float32_catanh(pX);
  __SEGGER_RTL_float32_cdivi (pX);
}
# 18493 "./floatops.c"
static __SEGGER_RTL_INLINE void __SEGGER_RTL_float64_catan(__SEGGER_RTL_FLOAT64_COMPLEX *pX) {
  __SEGGER_RTL_float64_cmuli (pX);
  __SEGGER_RTL_float64_catanh(pX);
  __SEGGER_RTL_float64_cdivi (pX);
}
# 18512 "./floatops.c"
static __SEGGER_RTL_LDOUBLE_C_COMPLEX __SEGGER_RTL_complex_double_to_ldouble(__SEGGER_RTL_FLOAT64_C_COMPLEX x) {
  __SEGGER_RTL_FLOAT64_COMPLEX z;
  __SEGGER_RTL_LDOUBLE_COMPLEX zl;

  z.u.value = x;
  zl.u.part.Re = __SEGGER_RTL_double_to_ldouble(z.u.part.Re);
  zl.u.part.Im = __SEGGER_RTL_double_to_ldouble(z.u.part.Im);

  return zl.u.value;
}
# 18536 "./floatops.c"
static __SEGGER_RTL_FLOAT64_C_COMPLEX __SEGGER_RTL_complex_ldouble_to_double(__SEGGER_RTL_LDOUBLE_C_COMPLEX x) {
  __SEGGER_RTL_FLOAT64_COMPLEX z;
  __SEGGER_RTL_LDOUBLE_COMPLEX zl;

  zl.u.value = x;
  z.u.part.Re = __SEGGER_RTL_ldouble_to_double(zl.u.part.Re);
  z.u.part.Im = __SEGGER_RTL_ldouble_to_double(zl.u.part.Im);

  return z.u.value;
}
# 18554 "./floatops.c"
#if __SEGGER_RTL_INCLUDE_GNU_API == 1
# 18574 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __ltsf2(float x, float y) {
  return __SEGGER_RTL_float32_lt(x, y) ? -1 : 0;
}
# 18596 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __ltdf2(double x, double y) {
  return __SEGGER_RTL_float64_lt(x, y) ? -1 : 0;
}
# 18618 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __lesf2(float x, float y) {
  return __SEGGER_RTL_float32_le(x, y) ? 0 : 1;
}
# 18640 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __ledf2(double x, double y) {
  return __SEGGER_RTL_float64_le(x, y) ? 0 : 1;
}
# 18662 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __gtsf2(float x, float y) {
  return __SEGGER_RTL_float32_gt(x, y) ? 1 : 0;
}
# 18684 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __gtdf2(double x, double y) {
  return __SEGGER_RTL_float64_gt(x, y) ? 1 : 0;
}
# 18706 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __gesf2(float x, float y) {
  return __SEGGER_RTL_float32_ge(x, y) ? 0 : -1;
}
# 18728 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __gedf2(double x, double y) {
  return __SEGGER_RTL_float64_ge(x, y) ? 0 : -1;
}
# 18750 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __eqsf2(float x, float y) {
  return __SEGGER_RTL_float32_eq(x, y) ? 0 : 1;
}
# 18772 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __eqdf2(double x, double y) {
  return __SEGGER_RTL_float64_eq(x, y) ? 0 : 1;
}
# 18794 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __nesf2(float x, float y) {
  return __SEGGER_RTL_float32_ne(x, y) ? 1 : 0;
}
# 18816 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __nedf2(double x, double y) {
  return __SEGGER_RTL_float64_ne(x, y) ? 1 : 0;
}
# 18837 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __unordsf2(float x, float y) {
  return __SEGGER_RTL_float32_isnan_inline(x) || __SEGGER_RTL_float32_isnan_inline(y);
}
# 18858 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __unorddf2(double x, double y) {
  return __SEGGER_RTL_float64_isnan_inline(x) || __SEGGER_RTL_float64_isnan_inline(y);
}
# 18879 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API __addsf3(float x, float y) {
  return __SEGGER_RTL_float32_add(x, y);
}
# 18900 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API __adddf3(double x, double y) {
  return __SEGGER_RTL_float64_add(x, y);
}
# 18921 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API __subsf3(float x, float y) {
  return __SEGGER_RTL_float32_sub(x, y);
}
# 18942 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API __subdf3(double x, double y) {
  return __SEGGER_RTL_float64_sub(x, y);
}
# 18963 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API __mulsf3(float x, float y) {
  return __SEGGER_RTL_float32_mul(x, y);
}
# 18984 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API __muldf3(double x, double y) {
  return __SEGGER_RTL_float64_mul(x, y);
}
# 19005 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API __divsf3(float x, float y) {
  return __SEGGER_RTL_float32_div(x, y);
}
# 19026 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API __divdf3(double x, double y) {
  return __SEGGER_RTL_float64_div(x, y);
}
# 19046 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __fixsfsi(float x) {
  return __SEGGER_RTL_float_to_int32(x);
}
# 19066 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __fixdfsi(double x) {
  return __SEGGER_RTL_double_to_int32(x);
}
# 19090 "./floatops.c"
__SEGGER_RTL_I64 __SEGGER_RTL_PUBLIC_API __fixsfdi(float f) {
  return __SEGGER_RTL_float_to_int64(f);
}
# 19113 "./floatops.c"
__SEGGER_RTL_I64 __SEGGER_RTL_PUBLIC_API __fixdfdi(double x) {
  return __SEGGER_RTL_double_to_int64(x);
}
# 19133 "./floatops.c"
__SEGGER_RTL_U64 __SEGGER_RTL_PUBLIC_API __fixunsdfdi(double x) {
  return __SEGGER_RTL_double_to_uint64(x);
}
# 19153 "./floatops.c"
unsigned __SEGGER_RTL_PUBLIC_API __fixunssfsi(float x) {
  return __SEGGER_RTL_float_to_uint32(x);
}
# 19173 "./floatops.c"
unsigned __SEGGER_RTL_PUBLIC_API __fixunsdfsi(double x) {
  return __SEGGER_RTL_double_to_uint32(x);
}
# 19193 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API __floatsisf(__SEGGER_RTL_I32 x) {
  return __SEGGER_RTL_int32_to_float(x);
}
# 19213 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API __floatsidf(__SEGGER_RTL_I32 x) {
  return __SEGGER_RTL_int32_to_double(x);
}
# 19233 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API __floatunsisf(__SEGGER_RTL_U32 x) {
  return __SEGGER_RTL_uint32_to_float(x);
}
# 19253 "./floatops.c"
__SEGGER_RTL_U64 __SEGGER_RTL_PUBLIC_API __fixunssfdi(float f) {
  return __SEGGER_RTL_float_to_uint64(f);
}
# 19273 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API __floatunsidf(__SEGGER_RTL_U32 x) {
  return __SEGGER_RTL_uint32_to_double(x);
}
# 19293 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API __floatdisf(__SEGGER_RTL_I64 x) {
  return __SEGGER_RTL_int64_to_float(x);
}
# 19313 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API __floatdidf(__SEGGER_RTL_I64 x) {
  return __SEGGER_RTL_int64_to_double(x);
}
# 19333 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API __floatundisf(__SEGGER_RTL_U64 x) {
  return __SEGGER_RTL_uint64_to_float(x);
}
# 19353 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API __floatundidf(__SEGGER_RTL_U64 x) {
  return __SEGGER_RTL_uint64_to_double(x);
}
# 19373 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API __truncdfsf2(double x) {
  return __SEGGER_RTL_double_to_float(x);
}
# 19393 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API __extendsfdf2(float x) {
  return __SEGGER_RTL_float_to_double(x);
}

#endif



#if __SEGGER_RTL_INCLUDE_GNU_FP16_API > 0
# 19416 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE float __SEGGER_RTL_half_to_float_ieee(__SEGGER_RTL_FLOAT16 x) {
  return __SEGGER_RTL_half_to_float_ieee_soft(__SEGGER_RTL_BitcastToU16_inline(x));
}
# 19433 "./floatops.c"
static __SEGGER_RTL_ALWAYS_INLINE double __SEGGER_RTL_half_to_double_ieee(__SEGGER_RTL_FLOAT16 x) {
  return __SEGGER_RTL_half_to_double_ieee_soft(__SEGGER_RTL_BitcastToU16_inline(x));
}
# 19453 "./floatops.c"
__SEGGER_RTL_U16 __SEGGER_RTL_PUBLIC_API __gnu_f2h_ieee(float x) {
  return __SEGGER_RTL_float_to_half_ieee_soft(__SEGGER_RTL_BitcastToU32(x));
}
# 19473 "./floatops.c"
__SEGGER_RTL_U16 __SEGGER_RTL_PUBLIC_API __gnu_d2h_ieee(double x) {
  return __SEGGER_RTL_double_to_half_ieee_soft(__SEGGER_RTL_BitcastToU64(x));
}
# 19493 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API __gnu_h2f_ieee(__SEGGER_RTL_U16 x) {
  return __SEGGER_RTL_half_to_float_ieee_soft(x);
}
# 19513 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API __gnu_h2d_ieee(__SEGGER_RTL_U16 x) {
  return __SEGGER_RTL_half_to_double_ieee_soft(x);
}
# 19533 "./floatops.c"
__SEGGER_RTL_FLOAT16 __SEGGER_RTL_PUBLIC_API __truncsfhf2(float x) {
  return __SEGGER_RTL_BitcastToF16_inline(
           __SEGGER_RTL_float_to_half_ieee_soft(
             __SEGGER_RTL_BitcastToU32(x)));
}
# 19555 "./floatops.c"
__SEGGER_RTL_FLOAT16 __SEGGER_RTL_PUBLIC_API __truncdfhf2(double x) {
  return __SEGGER_RTL_BitcastToF16_inline(
           __SEGGER_RTL_double_to_half_ieee_soft(
             __SEGGER_RTL_BitcastToU64(x)));
}
# 19577 "./floatops.c"
__SEGGER_RTL_FLOAT16 __SEGGER_RTL_PUBLIC_API __trunctfhf2(long double x) {
  return __SEGGER_RTL_BitcastToF16_inline(
           __SEGGER_RTL_double_to_half_ieee(
             __SEGGER_RTL_ldouble_to_double(x)));
}
# 19599 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API __extendhfsf2(__SEGGER_RTL_FLOAT16 x) {
  return __SEGGER_RTL_half_to_float_ieee(x);
}
# 19619 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API __extendhfdf2(__SEGGER_RTL_FLOAT16 x) {
  return __SEGGER_RTL_half_to_double_ieee(x);
}
# 19639 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API __extendhftf2(__SEGGER_RTL_FLOAT16 x) {
  return __SEGGER_RTL_double_to_ldouble(__SEGGER_RTL_half_to_double_ieee(x));
}
# 19659 "./floatops.c"
__SEGGER_RTL_I32 __SEGGER_RTL_PUBLIC_API __fixhfsi(__SEGGER_RTL_FLOAT16 x) {
  return __SEGGER_RTL_float_to_int32(__SEGGER_RTL_half_to_float_ieee(x));
}
# 19679 "./floatops.c"
unsigned __SEGGER_RTL_PUBLIC_API __fixunshfsi(__SEGGER_RTL_FLOAT16 x) {
  return __SEGGER_RTL_float_to_uint32(__SEGGER_RTL_half_to_float_ieee(x));
}
# 19699 "./floatops.c"
__SEGGER_RTL_I64 __SEGGER_RTL_PUBLIC_API __fixhfdi(__SEGGER_RTL_FLOAT16 x) {
  return __SEGGER_RTL_float_to_int32(__SEGGER_RTL_half_to_float_ieee(x));
}
# 19719 "./floatops.c"
__SEGGER_RTL_I64 __SEGGER_RTL_PUBLIC_API __fixunshfdi(__SEGGER_RTL_FLOAT16 x) {
  return __SEGGER_RTL_float_to_uint32(__SEGGER_RTL_half_to_float_ieee(x));
}
# 19739 "./floatops.c"
__SEGGER_RTL_FLOAT16 __SEGGER_RTL_PUBLIC_API __floatsihf(__SEGGER_RTL_I32 x) {
  return __SEGGER_RTL_BitcastToF16_inline(
           __SEGGER_RTL_float_to_half_ieee(
             __SEGGER_RTL_int32_to_float(x)));
}
# 19761 "./floatops.c"
__SEGGER_RTL_FLOAT16 __SEGGER_RTL_PUBLIC_API __floatunsihf(__SEGGER_RTL_U32 x) {
  return __SEGGER_RTL_BitcastToF16_inline(
           __SEGGER_RTL_float_to_half_ieee(
             __SEGGER_RTL_uint32_to_float(x)));
}
# 19783 "./floatops.c"
__SEGGER_RTL_FLOAT16 __SEGGER_RTL_PUBLIC_API __floatdihf(__SEGGER_RTL_I64 x) {
  return __SEGGER_RTL_BitcastToF16_inline(
           __SEGGER_RTL_float_to_half_ieee(
             __SEGGER_RTL_int64_to_float(x)));
}
# 19805 "./floatops.c"
__SEGGER_RTL_FLOAT16 __SEGGER_RTL_PUBLIC_API __floatundihf(__SEGGER_RTL_U64 x) {
  return __SEGGER_RTL_BitcastToF16_inline(
           __SEGGER_RTL_float_to_half_ieee(
             __SEGGER_RTL_uint64_to_float(x)));
}
# 19829 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __eqhf2(__SEGGER_RTL_FLOAT16 x, __SEGGER_RTL_FLOAT16 y) {
  return __SEGGER_RTL_float32_eq(x, y) ? 0 : 1;
}
# 19851 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __nehf2(__SEGGER_RTL_FLOAT16 x, __SEGGER_RTL_FLOAT16 y) {
  return __SEGGER_RTL_float32_ne(x, y) ? 1 : 0;
}
# 19873 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __lehf2(__SEGGER_RTL_FLOAT16 x, __SEGGER_RTL_FLOAT16 y) {
  return __SEGGER_RTL_float32_le(x, y) ? 0 : 1;
}
# 19895 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __lthf2(__SEGGER_RTL_FLOAT16 x, __SEGGER_RTL_FLOAT16 y) {
  return __SEGGER_RTL_float32_lt(x, y) ? -1 : 0;
}
# 19917 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __gthf2(__SEGGER_RTL_FLOAT16 x, __SEGGER_RTL_FLOAT16 y) {
  return __SEGGER_RTL_float32_gt(x, y) ? 1 : 0;
}
# 19939 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __gehf2(__SEGGER_RTL_FLOAT16 x, __SEGGER_RTL_FLOAT16 y) {
  return __SEGGER_RTL_float32_ge(x, y) ? 0 : -1;
}

#endif

#if __SEGGER_RTL_INCLUDE_GNU_API > 0
# 19964 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __unordtf2(long double x, long double y) {
  return __SEGGER_RTL_float64_isnan_inline(__SEGGER_RTL_ldouble_to_double(x)) ||
         __SEGGER_RTL_float64_isnan_inline(__SEGGER_RTL_ldouble_to_double(y));
}
# 19986 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API __addtf3(long double x, long double y) {
  return __SEGGER_RTL_double_to_ldouble(
           SEGGER_ADD(
             __SEGGER_RTL_ldouble_to_double(x),
             __SEGGER_RTL_ldouble_to_double(y)));
}
# 20010 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API __subtf3(long double x, long double y) {
  return __SEGGER_RTL_double_to_ldouble(
           SEGGER_SUB(
             __SEGGER_RTL_ldouble_to_double(x),
             __SEGGER_RTL_ldouble_to_double(y)));
}
# 20034 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API __multf3(long double x, long double y) {
  return __SEGGER_RTL_double_to_ldouble(
           SEGGER_MUL(
             __SEGGER_RTL_ldouble_to_double(x),
             __SEGGER_RTL_ldouble_to_double(y)));
}
# 20058 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API __divtf3(long double x, long double y) {
  return __SEGGER_RTL_double_to_ldouble(
           SEGGER_DIV(
             __SEGGER_RTL_ldouble_to_double(x),
             __SEGGER_RTL_ldouble_to_double(y)));
}
# 20081 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API __floatsitf(__SEGGER_RTL_I32 x) {
  return __SEGGER_RTL_double_to_ldouble(__SEGGER_RTL_int32_to_double(x));
}
# 20101 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API __floatditf(__SEGGER_RTL_I64 x) {
  return __SEGGER_RTL_double_to_ldouble(__SEGGER_RTL_int64_to_double(x));
}
# 20121 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API __floatunsitf(__SEGGER_RTL_U32 x) {
  return __SEGGER_RTL_double_to_ldouble(__SEGGER_RTL_uint32_to_double(x));
}
# 20141 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API __floatunditf(__SEGGER_RTL_U64 x) {
  return __SEGGER_RTL_double_to_ldouble(__SEGGER_RTL_uint64_to_double(x));
}
# 20161 "./floatops.c"
__SEGGER_RTL_I32 __SEGGER_RTL_PUBLIC_API __fixtfsi(long double x) {
  return __SEGGER_RTL_double_to_int32(__SEGGER_RTL_ldouble_to_double(x));
}
# 20181 "./floatops.c"
__SEGGER_RTL_I64 __SEGGER_RTL_PUBLIC_API __fixtfdi(long double x) {
  return __SEGGER_RTL_double_to_int64(__SEGGER_RTL_ldouble_to_double(x));
}
# 20203 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __eqtf2(long double x, long double y) {
  double dx;
  double dy;

  dx = __SEGGER_RTL_ldouble_to_double(x);
  dy = __SEGGER_RTL_ldouble_to_double(y);

  return dx == dy ? 0 : 1;
}
# 20231 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __netf2(long double x, long double y) {
  double dx;
  double dy;

  dx = __SEGGER_RTL_ldouble_to_double(x);
  dy = __SEGGER_RTL_ldouble_to_double(y);

  return dx != dy ? 1 : 0;
}
# 20259 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __lttf2(long double x, long double y) {
  double dx;
  double dy;

  dx = __SEGGER_RTL_ldouble_to_double(x);
  dy = __SEGGER_RTL_ldouble_to_double(y);

  return dx < dy ? -1 : 0;
}
# 20287 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __letf2(long double x, long double y) {
  double dx;
  double dy;

  dx = __SEGGER_RTL_ldouble_to_double(x);
  dy = __SEGGER_RTL_ldouble_to_double(y);

  return dx <= dy ? -1 : 1;
}
# 20315 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __gttf2(long double x, long double y) {
  double dx;
  double dy;

  dx = __SEGGER_RTL_ldouble_to_double(x);
  dy = __SEGGER_RTL_ldouble_to_double(y);

  return dx > dy ? 1 : 0;
}
# 20343 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __getf2(long double x, long double y) {
  double dx;
  double dy;

  dx = __SEGGER_RTL_ldouble_to_double(x);
  dy = __SEGGER_RTL_ldouble_to_double(y);

  return dx >= dy ? 0 : -1;
}
# 20369 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API __extendsftf2(float x) {
  return __SEGGER_RTL_double_to_ldouble(__SEGGER_RTL_float_to_double(x));
}
# 20389 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API __extenddftf2(double x) {
  return __SEGGER_RTL_double_to_ldouble(x);
}
# 20409 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __fixunstfsi(long double x) {
  return (int)__SEGGER_RTL_ldouble_to_double(x);
}
# 20429 "./floatops.c"
__SEGGER_RTL_U64 __SEGGER_RTL_PUBLIC_API __fixunstfdi(long double x) {
  return __SEGGER_RTL_double_to_uint64(__SEGGER_RTL_ldouble_to_double(x));
}
# 20449 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API __trunctfdf2(long double x) {
  return __SEGGER_RTL_ldouble_to_double(x);
}
# 20469 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API __trunctfsf2(long double x) {
  return (float)__SEGGER_RTL_ldouble_to_double(x);
}

#endif
# 20497 "./floatops.c"
__SEGGER_RTL_FLOAT32_C_COMPLEX __SEGGER_RTL_PUBLIC_API __mulsc3(float a, float b, float c, float d) {
  __SEGGER_RTL_FLOAT32_COMPLEX x;
  __SEGGER_RTL_FLOAT32_COMPLEX y;

  x.u.part.Re = a;
  x.u.part.Im = b;
  y.u.part.Re = c;
  y.u.part.Im = d;

  __SEGGER_RTL_float32_cmul(&x, &y);

  return x.u.value;
}
# 20533 "./floatops.c"
__SEGGER_RTL_FLOAT64_C_COMPLEX __SEGGER_RTL_PUBLIC_API __muldc3(double a, double b, double c, double d) {
  __SEGGER_RTL_FLOAT64_COMPLEX x;
  __SEGGER_RTL_FLOAT64_COMPLEX y;

  x.u.part.Re = a;
  x.u.part.Im = b;
  y.u.part.Re = c;
  y.u.part.Im = d;

  __SEGGER_RTL_float64_cmul(&x, &y);

  return x.u.value;
}
# 20569 "./floatops.c"
__SEGGER_RTL_LDOUBLE_C_COMPLEX __SEGGER_RTL_PUBLIC_API __multc3(long double a, long double b, long double c, long double d) {
  __SEGGER_RTL_FLOAT64_COMPLEX x;
  __SEGGER_RTL_FLOAT64_COMPLEX y;

  x.u.part.Re = __SEGGER_RTL_ldouble_to_double(a);
  x.u.part.Im = __SEGGER_RTL_ldouble_to_double(b);
  y.u.part.Re = __SEGGER_RTL_ldouble_to_double(c);
  y.u.part.Im = __SEGGER_RTL_ldouble_to_double(d);

  __SEGGER_RTL_float64_cmul(&x, &y);

  return __SEGGER_RTL_float64_cmplx_inline(
           __SEGGER_RTL_double_to_ldouble(x.u.part.Re),
           __SEGGER_RTL_double_to_ldouble(x.u.part.Im));
}
# 20607 "./floatops.c"
__SEGGER_RTL_FLOAT32_C_COMPLEX __SEGGER_RTL_PUBLIC_API __divsc3(float a, float b, float c, float d) {
  __SEGGER_RTL_FLOAT32_COMPLEX x;
  __SEGGER_RTL_FLOAT32_COMPLEX y;

  x.u.part.Re = a;
  x.u.part.Im = b;
  y.u.part.Re = c;
  y.u.part.Im = d;

  __SEGGER_RTL_float32_cdiv(&x, &y);

  return x.u.value;
}
# 20643 "./floatops.c"
__SEGGER_RTL_FLOAT64_C_COMPLEX __SEGGER_RTL_PUBLIC_API __divdc3(double a, double b, double c, double d) {
  __SEGGER_RTL_FLOAT64_COMPLEX x;
  __SEGGER_RTL_FLOAT64_COMPLEX y;

  x.u.part.Re = a;
  x.u.part.Im = b;
  y.u.part.Re = c;
  y.u.part.Im = d;

  __SEGGER_RTL_float64_cdiv_inline(&x, &y);

  return x.u.value;
}
# 20679 "./floatops.c"
__SEGGER_RTL_LDOUBLE_C_COMPLEX __SEGGER_RTL_PUBLIC_API __divtc3(long double a, long double b, long double c, long double d) {
  __SEGGER_RTL_FLOAT64_COMPLEX x;
  __SEGGER_RTL_FLOAT64_COMPLEX y;

  x.u.part.Re = __SEGGER_RTL_ldouble_to_double(a);
  x.u.part.Im = __SEGGER_RTL_ldouble_to_double(b);
  y.u.part.Re = __SEGGER_RTL_ldouble_to_double(c);
  y.u.part.Im = __SEGGER_RTL_ldouble_to_double(d);

  __SEGGER_RTL_float64_cdiv_inline(&x, &y);

  return __SEGGER_RTL_float64_cmplx_inline(
           __SEGGER_RTL_double_to_ldouble(x.u.part.Re),
           __SEGGER_RTL_double_to_ldouble(x.u.part.Im));
}
# 20702 "./floatops.c"
#if __SEGGER_RTL_INCLUDE_SEGGER_API
# 20718 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_addf(float x, float y) {
  return __SEGGER_RTL_float32_add(x, y);
}
# 20736 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_add(double x, double y) {
   return __SEGGER_RTL_float64_add(x, y);
}
# 20754 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_subf(float x, float y) {
  return __SEGGER_RTL_float32_sub(x, y);
}
# 20772 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_sub(double x, double y) {
  return __SEGGER_RTL_float64_sub(x, y);
}
# 20790 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_mulf(float x, float y) {
  return __SEGGER_RTL_float32_mul(x, y);
}
# 20808 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_mul(double x, double y) {
  return __SEGGER_RTL_float64_mul(x, y);
}
# 20826 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_divf(float x, float y) {
  return __SEGGER_RTL_float32_div(x, y);
}
# 20844 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_div(double x, double y) {
  return __SEGGER_RTL_float64_div(x, y);
}
# 20861 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_negf(float x) {
  return __SEGGER_RTL_float32_signbit_xor(x, -0.0f);
}
# 20878 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_neg(double x) {
  return __SEGGER_RTL_float64_signbit_xor(x, -0.0);
}
# 20897 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API SEGGER_eqf(float x, float y) {
  return __SEGGER_RTL_float32_eq(x, y);
}
# 20916 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API SEGGER_eq(double x, double y) {
  return __SEGGER_RTL_float64_eq(x, y);
}
# 20935 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API SEGGER_ne(double x, double y) {
  return __SEGGER_RTL_float64_ne(x, y);
}
# 20954 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API SEGGER_nef(float x, float y) {
  return __SEGGER_RTL_float32_ne(x, y);
}
# 20973 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API SEGGER_ltf(float x, float y) {
  return __SEGGER_RTL_float32_lt(x, y);
}
# 20992 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API SEGGER_lt(double x, double y) {
  return __SEGGER_RTL_float64_lt(x, y);
}
# 21011 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API SEGGER_lef(float x, float y) {
  return __SEGGER_RTL_float32_le(x, y);
}
# 21030 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API SEGGER_le(double x, double y) {
  return __SEGGER_RTL_float64_le(x, y);
}
# 21049 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API SEGGER_gtf(float x, float y) {
  return __SEGGER_RTL_float32_gt(x, y);
}
# 21068 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API SEGGER_gt(double x, double y) {
  return __SEGGER_RTL_float64_gt(x, y);
}
# 21087 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API SEGGER_gef(float x, float y) {
  return __SEGGER_RTL_float32_ge(x, y);
}
# 21106 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API SEGGER_ge(double x, double y) {
  return __SEGGER_RTL_float64_ge(x, y);
}
# 21124 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API SEGGER_isnanf(float x) {
  return __SEGGER_RTL_float32_isnan_inline(x);
}
# 21142 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API SEGGER_isinff(float x) {
  return __SEGGER_RTL_float32_isinf_inline(x);
}
# 21160 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API SEGGER_isfinitef(float x) {
  return __SEGGER_RTL_float32_isfinite_inline(x);
}
# 21178 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API SEGGER_isnormalf(float x) {
  return __SEGGER_RTL_float32_isnormal_inline(x);
}
# 21199 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API SEGGER_classifyf(float x) {
  if (__SEGGER_RTL_float32_iszero_inline(x)) {
    return __SEGGER_RTL_FP_ZERO;
  } else if (__SEGGER_RTL_float32_isnan_inline(x)) {
    return __SEGGER_RTL_FP_NAN;
  } else if (__SEGGER_RTL_float32_isinf_inline(x)) {
    return __SEGGER_RTL_FP_INFINITE;
  } else if (__SEGGER_RTL_float32_isnormal_inline(x)) {
    return __SEGGER_RTL_FP_NORMAL;
  } else {
    return __SEGGER_RTL_FP_SUBNORMAL;
  }
}
# 21227 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API SEGGER_isnan(double x) {
  return __SEGGER_RTL_float64_isnan_inline(x);
}
# 21245 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API SEGGER_isinf(double x) {
  return __SEGGER_RTL_float64_isinf_inline(x);
}
# 21263 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API SEGGER_isfinite(double x) {
  return __SEGGER_RTL_float64_isfinite_inline(x);
}
# 21281 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API SEGGER_isnormal(double x) {
  return __SEGGER_RTL_float64_isnormal_inline(x);
}
# 21302 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API SEGGER_classify(double x) {
  if (__SEGGER_RTL_float64_iszero_inline(x)) {
    return __SEGGER_RTL_FP_ZERO;
  } else if (__SEGGER_RTL_float64_isnan_inline(x)) {
    return __SEGGER_RTL_FP_NAN;
  } else if (__SEGGER_RTL_float64_isinf_inline(x)) {
    return __SEGGER_RTL_FP_INFINITE;
  } else if (__SEGGER_RTL_float64_isnormal_inline(x)) {
    return __SEGGER_RTL_FP_NORMAL;
  } else {
    return __SEGGER_RTL_FP_SUBNORMAL;
  }
}
# 21330 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API SEGGER_signbitf(float x) {
  return __SEGGER_RTL_float32_signbit_soft(__SEGGER_RTL_BitcastToU32(x));
}
# 21348 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API SEGGER_signbit(double x) {
  return __SEGGER_RTL_float64_signbit_soft(__SEGGER_RTL_BitcastToU64(x));
}
# 21367 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_copysignf(float x, float y) {
  return __SEGGER_RTL_float32_signbit_copy(x, y);
}
# 21386 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_copysign(double x, double y) {
  return __SEGGER_RTL_float64_signbit_copy(x, y);
}
# 21403 "./floatops.c"
__SEGGER_RTL_I32 __SEGGER_RTL_PUBLIC_API SEGGER_float_to_int32(float x) {
  return __SEGGER_RTL_float_to_int32(x);
}
# 21420 "./floatops.c"
__SEGGER_RTL_I32 __SEGGER_RTL_PUBLIC_API SEGGER_double_to_int32(double x) {
  return __SEGGER_RTL_double_to_int32(x);
}
# 21437 "./floatops.c"
__SEGGER_RTL_U32 __SEGGER_RTL_PUBLIC_API SEGGER_float_to_uint32(float x) {
  return __SEGGER_RTL_float_to_uint32(x);
}
# 21454 "./floatops.c"
__SEGGER_RTL_U32 __SEGGER_RTL_PUBLIC_API SEGGER_double_to_uint32(double x) {
  return __SEGGER_RTL_double_to_uint32(x);
}
# 21475 "./floatops.c"
__SEGGER_RTL_I64 __SEGGER_RTL_PUBLIC_API SEGGER_float_to_int64(float f) {
  return __SEGGER_RTL_float_to_int64(f);
}
# 21495 "./floatops.c"
__SEGGER_RTL_I64 __SEGGER_RTL_PUBLIC_API SEGGER_double_to_int64(double x) {
  return __SEGGER_RTL_double_to_int64(x);
}
# 21512 "./floatops.c"
__SEGGER_RTL_U64 __SEGGER_RTL_PUBLIC_API SEGGER_float_to_uint64(float f) {
  return __SEGGER_RTL_float_to_uint64(f);
}
# 21532 "./floatops.c"
__SEGGER_RTL_U64 __SEGGER_RTL_PUBLIC_API SEGGER_double_to_uint64(double x) {
  return __SEGGER_RTL_double_to_uint64(x);
}
# 21549 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_int32_to_float(__SEGGER_RTL_I32 x) {
  return __SEGGER_RTL_int32_to_float(x);
}
# 21566 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_int32_to_double(__SEGGER_RTL_I32 x) {
  return __SEGGER_RTL_int32_to_double(x);
}
# 21583 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_uint32_to_float(__SEGGER_RTL_U32 x) {
  return __SEGGER_RTL_uint32_to_float(x);
}
# 21600 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_uint32_to_double(__SEGGER_RTL_U32 x) {
  return __SEGGER_RTL_uint32_to_double(x);
}
# 21617 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_int64_to_float(__SEGGER_RTL_I64 x) {
  return __SEGGER_RTL_int64_to_float(x);
}
# 21634 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_int64_to_double(__SEGGER_RTL_I64 x) {
  return __SEGGER_RTL_int64_to_double(x);
}
# 21651 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_uint64_to_float(__SEGGER_RTL_U64 x) {
  return __SEGGER_RTL_uint64_to_float(x);
}
# 21668 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_uint64_to_double(__SEGGER_RTL_U64 x) {
  return __SEGGER_RTL_uint64_to_double(x);
}
# 21685 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_float_to_double(float x) {
  return __SEGGER_RTL_float_to_double(x);
}
# 21702 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_double_to_float(double x) {
  return __SEGGER_RTL_double_to_float(x);
}
# 21719 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API SEGGER_float_to_int(float x) {
  return sizeof(int) <= 4 ? (int)SEGGER_float_to_int32(x)
                          : (int)SEGGER_float_to_int64(x);
}
# 21737 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_int_to_float(int x) {
  return sizeof(int) <= 4 ? __SEGGER_RTL_int32_to_float((__SEGGER_RTL_I32)x)
                          : __SEGGER_RTL_int64_to_float((__SEGGER_RTL_I64)x);
}
# 21755 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API SEGGER_double_to_int(double x) {
  return sizeof(int) <= 4 ? (int)__SEGGER_RTL_double_to_int32(x)
                          : (int)__SEGGER_RTL_double_to_int64(x);
}
# 21773 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_int_to_double(int x) {
  return sizeof(int) <= 4 ? __SEGGER_RTL_int32_to_double((__SEGGER_RTL_I32)x)
                          : __SEGGER_RTL_int64_to_double((__SEGGER_RTL_I64)x);
}
# 21791 "./floatops.c"
unsigned __SEGGER_RTL_PUBLIC_API SEGGER_float_to_uint(float x) {
  return sizeof(unsigned) <= 4 ? (unsigned)__SEGGER_RTL_float_to_uint32(x)
                               : (unsigned)__SEGGER_RTL_float_to_uint64(x);
}
# 21809 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_uint_to_float(unsigned x) {
  return sizeof(unsigned) <= 4 ? __SEGGER_RTL_uint32_to_float((__SEGGER_RTL_U32)x)
                               : __SEGGER_RTL_uint64_to_float((__SEGGER_RTL_U64)x);
}
# 21827 "./floatops.c"
unsigned __SEGGER_RTL_PUBLIC_API SEGGER_double_to_uint(double x) {
  return sizeof(unsigned) <= 4 ? (unsigned)__SEGGER_RTL_double_to_uint32(x)
                               : (unsigned)__SEGGER_RTL_double_to_uint64(x);
}
# 21845 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_uint_to_double(unsigned x) {
  return sizeof(unsigned) <= 4 ? __SEGGER_RTL_uint32_to_double((__SEGGER_RTL_U32)x)
                               : __SEGGER_RTL_uint64_to_double((__SEGGER_RTL_U64)x);
}
# 21863 "./floatops.c"
long __SEGGER_RTL_PUBLIC_API SEGGER_float_to_long(float x) {
  return sizeof(long) <= 4 ? (long)__SEGGER_RTL_float_to_int32(x)
                           : (long)__SEGGER_RTL_float_to_int64(x);
}
# 21881 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_long_to_float(long x) {
  return sizeof(long) <= 4 ? __SEGGER_RTL_int32_to_float((__SEGGER_RTL_I32)x)
                           : __SEGGER_RTL_int64_to_float((__SEGGER_RTL_I64)x);
}
# 21899 "./floatops.c"
long __SEGGER_RTL_PUBLIC_API SEGGER_double_to_long(double x) {
  return sizeof(long) <= 4 ? (long)__SEGGER_RTL_double_to_int32(x)
                           : (long)__SEGGER_RTL_double_to_int64(x);
}
# 21917 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_long_to_double(long x) {
  return sizeof(long) <= 4 ? __SEGGER_RTL_int32_to_double((__SEGGER_RTL_I32)x)
                           : __SEGGER_RTL_int64_to_double((__SEGGER_RTL_I64)x);
}
# 21935 "./floatops.c"
unsigned long __SEGGER_RTL_PUBLIC_API SEGGER_float_to_ulong(float x) {
  return sizeof(unsigned long) <= 4 ? (unsigned long)__SEGGER_RTL_float_to_uint32(x)
                                    : (unsigned long)__SEGGER_RTL_float_to_uint64(x);
}
# 21953 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_ulong_to_float(unsigned long x) {
  return sizeof(long) <= 4 ? __SEGGER_RTL_uint32_to_float((__SEGGER_RTL_U32)x)
                           : __SEGGER_RTL_uint64_to_float((__SEGGER_RTL_U64)x);
}
# 21971 "./floatops.c"
unsigned long __SEGGER_RTL_PUBLIC_API SEGGER_double_to_ulong(double x) {
  return sizeof(unsigned long) <= 4 ? (unsigned long)__SEGGER_RTL_double_to_uint32(x)
                                    : (unsigned long)__SEGGER_RTL_double_to_uint64(x);
}
# 21989 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_ulong_to_double(unsigned long x) {
  return sizeof(unsigned long) <= 4 ? __SEGGER_RTL_uint32_to_double((__SEGGER_RTL_U32)x)
                                    : __SEGGER_RTL_uint64_to_double((__SEGGER_RTL_U64)x);
}
# 22007 "./floatops.c"
long long __SEGGER_RTL_PUBLIC_API SEGGER_float_to_llong(float x) {
  return __SEGGER_RTL_float_to_int64(x);
}
# 22024 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_llong_to_float(long long x) {
  return __SEGGER_RTL_int64_to_float(x);
}
# 22041 "./floatops.c"
long long __SEGGER_RTL_PUBLIC_API SEGGER_double_to_llong(double x) {
  return __SEGGER_RTL_double_to_int64(x);
}
# 22058 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_llong_to_double(long long x) {
  return __SEGGER_RTL_int64_to_double(x);
}
# 22075 "./floatops.c"
unsigned long long __SEGGER_RTL_PUBLIC_API SEGGER_float_to_ullong(float x) {
  return __SEGGER_RTL_float_to_uint64(x);
}
# 22092 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_ullong_to_float(unsigned long long x) {
  return __SEGGER_RTL_uint64_to_float(x);
}
# 22109 "./floatops.c"
unsigned long long __SEGGER_RTL_PUBLIC_API SEGGER_double_to_ullong(double x) {
  return __SEGGER_RTL_double_to_uint64(x);
}
# 22126 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_ullong_to_double(unsigned long long x) {
  return __SEGGER_RTL_uint64_to_double(x);
}
# 22152 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_modff(float x, float *iptr) {
  return __SEGGER_RTL_float32_modf_inline(x, iptr);
}
# 22178 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_modf(double x, double *iptr) {
  return __SEGGER_RTL_float64_modf_inline(x, iptr);
}
# 22196 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_fabs(double x) {
  return __SEGGER_RTL_float64_abs_inline(x);
}
# 22214 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_fabsf(float x) {
  return __SEGGER_RTL_float32_abs_inline(x);
}
# 22233 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_fmaf(float x, float y, float z) {
  return __SEGGER_RTL_float32_fma_inline(x, y, z);
}
# 22252 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_fma(double x, double y, double z) {
  return __SEGGER_RTL_float64_fma_inline(x, y, z);
}
# 22271 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_fmsf(float x, float y, float z) {
  return __SEGGER_RTL_float32_fma_inline(x, y, SEGGER_NEGF(z));
}
# 22290 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_fms(double x, double y, double z) {
  return __SEGGER_RTL_float64_fma_inline(x, y, SEGGER_NEG(z));
}
# 22318 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_ldexpf(float x, int n) {
  return __SEGGER_RTL_float32_ldexp_inline(x, n);
}
# 22346 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_ldexp(double x, int n) {
  return __SEGGER_RTL_float64_ldexp_inline(x, n);
}
# 22371 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_frexpf(float x, int *exp) {
  return __SEGGER_RTL_float32_frexp_inline(x, exp);
}
# 22396 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_frexp(double x, int *exp) {
  return __SEGGER_RTL_float64_frexp_inline(x, exp);
}
# 22416 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API SEGGER_ilogbf(float x) {
  return __SEGGER_RTL_float32_ilogb_inline(x);
}
# 22436 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API SEGGER_ilogb(double x) {
  return __SEGGER_RTL_float64_ilogb_inline(x);
}
# 22456 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_ceilf(float x) {
  return __SEGGER_RTL_float32_ceil_inline(x);
}
# 22476 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_ceil(double x) {
  return __SEGGER_RTL_float64_ceil_inline(x);
}
# 22496 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_floorf(float x) {
  return __SEGGER_RTL_float32_floor_inline(x);
}
# 22516 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_floor(double x) {
  return __SEGGER_RTL_float64_floor_inline(x);
}
# 22535 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_sinf(float x) {
  return __SEGGER_RTL_float32_sin_inline(x);
}
# 22554 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_sin(double x) {
  return __SEGGER_RTL_float64_sin_inline(x);
}
# 22573 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_cosf(float x) {
  return __SEGGER_RTL_float32_cos_inline(x);
}
# 22592 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_cos(double x) {
  return __SEGGER_RTL_float64_cos_inline(x);
}
# 22612 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_tanf(float x) {
  return __SEGGER_RTL_float32_tan_inline(x);
}
# 22632 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_tan(double x) {
  return __SEGGER_RTL_float64_tan_inline(x);
}
# 22656 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_asinf(float x) {
  return __SEGGER_RTL_float32_asin_inline(x);
}
# 22680 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_asin(double x) {
  return __SEGGER_RTL_float64_asin_inline(x);
}
# 22704 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_acosf(float x) {
  return __SEGGER_RTL_float32_acos_inline(x);
}
# 22728 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_acos(double x) {
  return __SEGGER_RTL_float64_acos_inline(x);
}
# 22751 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_atanf(float x) {
  return __SEGGER_RTL_float32_atan_inline(x);
}
# 22774 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_atan(double x) {
  return __SEGGER_RTL_float64_atan_inline(x);
}
# 22798 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_atan2f(float y, float x) {
  return __SEGGER_RTL_float32_atan2_inline(y, x);
}
# 22822 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_atan2(double y, double x) {
  return __SEGGER_RTL_float64_atan2_inline(y, x);
}
# 22848 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_sqrtf(float x) {
  return __SEGGER_RTL_float32_sqrt_inline(x);
}
# 22874 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_sqrt(double x) {
  return __SEGGER_RTL_float64_sqrt_inline(x);
}
# 22894 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_cbrtf(float x) {
  return __SEGGER_RTL_float32_cbrt(x);
}
# 22914 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_cbrt(double x) {
  return __SEGGER_RTL_float64_cbrt(x);
}
# 22935 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_rsqrtf(float x) {
  return __SEGGER_RTL_float32_rsqrt_inline(x);
}
# 22956 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_rsqrt(double x) {
  return __SEGGER_RTL_float64_rsqrt_inline(x);
}
# 22986 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_fmodf(float x, float y) {
  return __SEGGER_RTL_float32_fmod_inline(x, y);
}
# 23016 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_fmod(double x, double y) {
  return __SEGGER_RTL_float64_fmod_inline(x, y);
}
# 23036 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_fmaxf(float x, float y) {
  return __SEGGER_RTL_float32_fmax_inline(x, y);
}
# 23056 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_fmax(double x, double y) {
  return __SEGGER_RTL_float64_fmax_inline(x, y);
}
# 23076 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_fminf(float x, float y) {
  return __SEGGER_RTL_float32_fmin_inline(x, y);
}
# 23096 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_fmin(double x, double y) {
  return __SEGGER_RTL_float64_fmin_inline(x, y);
}
# 23115 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_fdimf(float x, float y) {
  return __SEGGER_RTL_float32_fdim_inline(x, y);
}
# 23134 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_fdim(double x, double y) {
  return __SEGGER_RTL_float64_fdim_inline(x, y);
}
# 23160 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_hypotf(float x, float y) {
  return __SEGGER_RTL_float32_hypot_inline(x, y);
}
# 23186 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_hypot(double x, double y) {
  return __SEGGER_RTL_float64_hypot_inline(x, y);
}
# 23207 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_logf(float x) {
  return __SEGGER_RTL_float32_log_inline(x);
}
# 23228 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_log(double x) {
  return __SEGGER_RTL_float64_log_inline(x);
}
# 23249 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_log1pf(float x) {
  return __SEGGER_RTL_float32_log1p_inline(x);
}
# 23270 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_log1p(double x) {
  return __SEGGER_RTL_float64_log1p_inline(x);
}
# 23291 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_log2f(float x) {
  return __SEGGER_RTL_float32_log2(x);
}
# 23312 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_log2(double x) {
  return __SEGGER_RTL_float64_log2(x);
}
# 23333 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_log10f(float x) {
  return __SEGGER_RTL_float32_log10_inline(x);
}
# 23354 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_log10(double x) {
  return __SEGGER_RTL_float64_log10_inline(x);
}
# 23374 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_expf(float x) {
  return __SEGGER_RTL_float32_exp_inline(x);
}
# 23394 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_exp(double x) {
  return __SEGGER_RTL_float64_exp_inline(x);
}
# 23414 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_exp2f(float x) {
  return __SEGGER_RTL_float32_exp2_inline(x);
}
# 23434 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_exp2(double x) {
  return __SEGGER_RTL_float64_exp2_inline(x);
}
# 23454 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_exp10f(float x) {
  return __SEGGER_RTL_float32_exp10_inline(x);
}
# 23474 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_exp10(double x) {
  return __SEGGER_RTL_float64_exp10_inline(x);
}
# 23492 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_powf(float x, float y) {
  return __SEGGER_RTL_float32_pow_inline(x, y);
}
# 23510 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_pow(double x, double y) {
  return __SEGGER_RTL_float64_pow_inline(x, y);
}
# 23529 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_sinhf(float x) {
  return __SEGGER_RTL_float32_sinh_inline(x);
}
# 23548 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_sinh(double x) {
  return __SEGGER_RTL_float64_sinh_inline(x);
}
# 23567 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_coshf(float x) {
  return __SEGGER_RTL_float32_cosh_inline(x);
}
# 23586 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_cosh(double x) {
  return __SEGGER_RTL_float64_cosh_inline(x);
}
# 23604 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_tanhf(float x) {
  return __SEGGER_RTL_float32_tanh_inline(x);
}
# 23622 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_tanh(double x) {
  return __SEGGER_RTL_float64_tanh_inline(x);
}
# 23644 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_asinhf(float x) {
  return __SEGGER_RTL_float32_asinh_inline(x);
}
# 23666 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_asinh(double x) {
  return __SEGGER_RTL_float64_asinh_inline(x);
}
# 23688 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_acoshf(float x) {
  return __SEGGER_RTL_float32_acosh_inline(x);
}
# 23710 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_acosh(double x) {
  return __SEGGER_RTL_float64_acosh_inline(x);
}
# 23733 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_atanhf(float x) {
  return __SEGGER_RTL_float32_atanh_inline(x);
}
# 23756 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_atanh(double x) {
  return __SEGGER_RTL_float64_atanh_inline(x);
}
# 23774 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API SEGGER_nextafterf(float x, float y) {
  return __SEGGER_RTL_float32_nextafter_inline(x, y);
}
# 23792 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API SEGGER_nextafter(double x, double y) {
  return __SEGGER_RTL_float64_nextafter_inline(x, y);
}

#endif

#if __SEGGER_RTL_INCLUDE_AEABI_API == 1
# 23824 "./floatops.c"
__SEGGER_RTL_U32 __SEGGER_RTL_PUBLIC_API __aeabi_fadd(__SEGGER_RTL_U32 x, __SEGGER_RTL_U32 y) {
  return __SEGGER_RTL_BitcastToU32(
           __SEGGER_RTL_float32_add(
             __SEGGER_RTL_BitcastToF32(x),
             __SEGGER_RTL_BitcastToF32(y)));
}
# 23848 "./floatops.c"
__SEGGER_RTL_U64 __SEGGER_RTL_PUBLIC_API __aeabi_dadd(__SEGGER_RTL_U64 x, __SEGGER_RTL_U64 y) {
  return __SEGGER_RTL_BitcastToU64(
           __SEGGER_RTL_float64_add(
             __SEGGER_RTL_BitcastToF64(x),
             __SEGGER_RTL_BitcastToF64(y)));
}
# 23872 "./floatops.c"
__SEGGER_RTL_U32 __SEGGER_RTL_PUBLIC_API __aeabi_fsub(__SEGGER_RTL_U32 x, __SEGGER_RTL_U32 y) {
  return __SEGGER_RTL_BitcastToU32(
           __SEGGER_RTL_float32_sub(
             __SEGGER_RTL_BitcastToF32(x),
             __SEGGER_RTL_BitcastToF32(y)));
}
# 23896 "./floatops.c"
__SEGGER_RTL_U64 __SEGGER_RTL_PUBLIC_API __aeabi_dsub(__SEGGER_RTL_U64 x, __SEGGER_RTL_U64 y) {
  return __SEGGER_RTL_BitcastToU64(
           __SEGGER_RTL_float64_sub(
             __SEGGER_RTL_BitcastToF64(x),
             __SEGGER_RTL_BitcastToF64(y)));
}
# 23920 "./floatops.c"
__SEGGER_RTL_U32 __aeabi_frsub(__SEGGER_RTL_U32 x, __SEGGER_RTL_U32 y) {
  return __SEGGER_RTL_BitcastToU32(
           __SEGGER_RTL_float32_sub(
             __SEGGER_RTL_BitcastToF32(y),
             __SEGGER_RTL_BitcastToF32(x)));
}
# 23944 "./floatops.c"
__SEGGER_RTL_U64 __SEGGER_RTL_PUBLIC_API __aeabi_drsub(__SEGGER_RTL_U64 x, __SEGGER_RTL_U64 y) {
  return __SEGGER_RTL_BitcastToU64(
           __SEGGER_RTL_float64_sub(
             __SEGGER_RTL_BitcastToF64(y),
             __SEGGER_RTL_BitcastToF64(x)));
}
# 23968 "./floatops.c"
__SEGGER_RTL_U32 __SEGGER_RTL_PUBLIC_API __aeabi_fmul(__SEGGER_RTL_U32 x, __SEGGER_RTL_U32 y) {
  return __SEGGER_RTL_BitcastToU32(
           __SEGGER_RTL_float32_mul(
             __SEGGER_RTL_BitcastToF32(x),
             __SEGGER_RTL_BitcastToF32(y)));
}
# 23992 "./floatops.c"
__SEGGER_RTL_U64 __SEGGER_RTL_PUBLIC_API __aeabi_dmul(__SEGGER_RTL_U64 x, __SEGGER_RTL_U64 y) {
  return __SEGGER_RTL_BitcastToU64(
           __SEGGER_RTL_float64_mul(
             __SEGGER_RTL_BitcastToF64(x),
             __SEGGER_RTL_BitcastToF64(y)));
}
# 24016 "./floatops.c"
__SEGGER_RTL_U32 __SEGGER_RTL_PUBLIC_API __aeabi_fdiv(__SEGGER_RTL_U32 x, __SEGGER_RTL_U32 y) {
  return __SEGGER_RTL_BitcastToU32(
           __SEGGER_RTL_float32_div(
             __SEGGER_RTL_BitcastToF32(x),
             __SEGGER_RTL_BitcastToF32(y)));
}
# 24040 "./floatops.c"
__SEGGER_RTL_U64 __SEGGER_RTL_PUBLIC_API __aeabi_ddiv(__SEGGER_RTL_U64 x, __SEGGER_RTL_U64 y) {
  return __SEGGER_RTL_BitcastToU64(
           __SEGGER_RTL_float64_div(
             __SEGGER_RTL_BitcastToF64(x),
             __SEGGER_RTL_BitcastToF64(y)));
}
# 24065 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __aeabi_fcmpeq(__SEGGER_RTL_U32 x, __SEGGER_RTL_U32 y) {
  return __SEGGER_RTL_float32_eq(
           __SEGGER_RTL_BitcastToF32(x),
           __SEGGER_RTL_BitcastToF32(y));
}
# 24089 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __aeabi_dcmpeq(__SEGGER_RTL_U64 x, __SEGGER_RTL_U64 y) {
  return __SEGGER_RTL_float64_eq(
           __SEGGER_RTL_BitcastToF64(x),
           __SEGGER_RTL_BitcastToF64(y));
}
# 24113 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __aeabi_fcmplt(__SEGGER_RTL_U32 x, __SEGGER_RTL_U32 y) {
  return __SEGGER_RTL_float32_lt(
           __SEGGER_RTL_BitcastToF32(x),
           __SEGGER_RTL_BitcastToF32(y));
}
# 24137 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __aeabi_dcmplt(__SEGGER_RTL_U64 x, __SEGGER_RTL_U64 y) {
  return __SEGGER_RTL_float64_lt(
           __SEGGER_RTL_BitcastToF64(x),
           __SEGGER_RTL_BitcastToF64(y));
}
# 24161 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __aeabi_fcmple(__SEGGER_RTL_U32 x, __SEGGER_RTL_U32 y) {
  return __SEGGER_RTL_float32_le(
           __SEGGER_RTL_BitcastToF32(x),
           __SEGGER_RTL_BitcastToF32(y));
}
# 24185 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __aeabi_dcmple(__SEGGER_RTL_U64 x, __SEGGER_RTL_U64 y) {
  return __SEGGER_RTL_float64_le(
           __SEGGER_RTL_BitcastToF64(x),
           __SEGGER_RTL_BitcastToF64(y));
}
# 24209 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __aeabi_fcmpgt(__SEGGER_RTL_U32 x, __SEGGER_RTL_U32 y) {
  return __SEGGER_RTL_float32_gt(
           __SEGGER_RTL_BitcastToF32(x),
           __SEGGER_RTL_BitcastToF32(y));
}
# 24233 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __aeabi_dcmpgt(__SEGGER_RTL_U64 x, __SEGGER_RTL_U64 y) {
  return __SEGGER_RTL_float64_gt(
           __SEGGER_RTL_BitcastToF64(x),
           __SEGGER_RTL_BitcastToF64(y));
}
# 24257 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __aeabi_fcmpge(__SEGGER_RTL_U32 x, __SEGGER_RTL_U32 y) {
  return __SEGGER_RTL_float32_ge(
           __SEGGER_RTL_BitcastToF32(x),
           __SEGGER_RTL_BitcastToF32(y));
}
# 24281 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __aeabi_dcmpge(__SEGGER_RTL_U64 x, __SEGGER_RTL_U64 y) {
  return __SEGGER_RTL_float64_ge(
           __SEGGER_RTL_BitcastToF64(x),
           __SEGGER_RTL_BitcastToF64(y));
}
# 24304 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __aeabi_fcmpun(__SEGGER_RTL_U32 x, __SEGGER_RTL_U32 y) {
  return __SEGGER_RTL_float32_isnan_soft(x) || __SEGGER_RTL_float32_isnan_soft(y);
}
# 24325 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __aeabi_dcmpun(__SEGGER_RTL_U64 x, __SEGGER_RTL_U64 y) {
  return __SEGGER_RTL_float64_isnan_soft(x) || __SEGGER_RTL_float64_isnan_soft(y);
}
# 24345 "./floatops.c"
__SEGGER_RTL_I32 __SEGGER_RTL_PUBLIC_API __aeabi_f2iz(__SEGGER_RTL_U32 x) {
  return __SEGGER_RTL_float_to_int32(__SEGGER_RTL_BitcastToF32(x));
}
# 24365 "./floatops.c"
__SEGGER_RTL_I32 __SEGGER_RTL_PUBLIC_API __aeabi_d2iz(__SEGGER_RTL_U64 x) {
  return __SEGGER_RTL_double_to_int32(__SEGGER_RTL_BitcastToF64(x));
}
# 24385 "./floatops.c"
__SEGGER_RTL_U32 __SEGGER_RTL_PUBLIC_API __aeabi_f2uiz(__SEGGER_RTL_U32 x) {
  return __SEGGER_RTL_float_to_uint32(__SEGGER_RTL_BitcastToF32(x));
}
# 24405 "./floatops.c"
__SEGGER_RTL_U32 __SEGGER_RTL_PUBLIC_API __aeabi_d2uiz(__SEGGER_RTL_U64 x) {
  return __SEGGER_RTL_double_to_uint32(__SEGGER_RTL_BitcastToF64(x));
}
# 24429 "./floatops.c"
__SEGGER_RTL_I64 __SEGGER_RTL_PUBLIC_API __aeabi_f2lz(__SEGGER_RTL_U32 x) {
  return __SEGGER_RTL_float_to_int64(__SEGGER_RTL_BitcastToF32(x));
}
# 24452 "./floatops.c"
__SEGGER_RTL_I64 __SEGGER_RTL_PUBLIC_API __aeabi_d2lz(__SEGGER_RTL_U64 x) {
  return __SEGGER_RTL_double_to_int64(__SEGGER_RTL_BitcastToF64(x));
}
# 24472 "./floatops.c"
__SEGGER_RTL_U64 __SEGGER_RTL_PUBLIC_API __aeabi_f2ulz(__SEGGER_RTL_U32 x) {
  return __SEGGER_RTL_float_to_uint64(__SEGGER_RTL_BitcastToF32(x));
}
# 24492 "./floatops.c"
__SEGGER_RTL_U64 __SEGGER_RTL_PUBLIC_API __aeabi_d2ulz(__SEGGER_RTL_U64 x) {
  return __SEGGER_RTL_double_to_uint64(__SEGGER_RTL_BitcastToF64(x));
}
# 24512 "./floatops.c"
__SEGGER_RTL_U32 __SEGGER_RTL_PUBLIC_API __aeabi_i2f(__SEGGER_RTL_I32 x) {
  return __SEGGER_RTL_BitcastToU32(__SEGGER_RTL_int32_to_float(x));
}
# 24532 "./floatops.c"
__SEGGER_RTL_U64 __SEGGER_RTL_PUBLIC_API __aeabi_i2d(__SEGGER_RTL_I32 x) {
  return __SEGGER_RTL_BitcastToU64(__SEGGER_RTL_int32_to_double(x));
}
# 24552 "./floatops.c"
__SEGGER_RTL_U32 __SEGGER_RTL_PUBLIC_API __aeabi_ui2f(__SEGGER_RTL_U32 x) {
  return __SEGGER_RTL_BitcastToU32(__SEGGER_RTL_uint32_to_float(x));
}
# 24572 "./floatops.c"
__SEGGER_RTL_U64 __SEGGER_RTL_PUBLIC_API __aeabi_ui2d(__SEGGER_RTL_U32 x) {
  return __SEGGER_RTL_BitcastToU64(__SEGGER_RTL_uint32_to_double(x));
}
# 24592 "./floatops.c"
__SEGGER_RTL_U32 __SEGGER_RTL_PUBLIC_API __aeabi_l2f(__SEGGER_RTL_I64 x) {
  return __SEGGER_RTL_BitcastToU32(__SEGGER_RTL_int64_to_float(x));
}
# 24612 "./floatops.c"
__SEGGER_RTL_U64 __SEGGER_RTL_PUBLIC_API __aeabi_l2d(__SEGGER_RTL_I64 x) {
  return __SEGGER_RTL_BitcastToU64(__SEGGER_RTL_int64_to_double(x));
}
# 24632 "./floatops.c"
__SEGGER_RTL_U32 __SEGGER_RTL_PUBLIC_API __aeabi_ul2f(__SEGGER_RTL_U64 x) {
  return __SEGGER_RTL_BitcastToU32(__SEGGER_RTL_uint64_to_float(x));
}
# 24652 "./floatops.c"
__SEGGER_RTL_U64 __SEGGER_RTL_PUBLIC_API __aeabi_ul2d(__SEGGER_RTL_U64 x) {
  return __SEGGER_RTL_BitcastToU64(__SEGGER_RTL_uint64_to_double(x));
}
# 24672 "./floatops.c"
__SEGGER_RTL_U64 __SEGGER_RTL_PUBLIC_API __aeabi_f2d(__SEGGER_RTL_U32 x) {
  return __SEGGER_RTL_BitcastToU64(
           __SEGGER_RTL_float_to_double(
             __SEGGER_RTL_BitcastToF32(x)));
}
# 24694 "./floatops.c"
__SEGGER_RTL_U32 __SEGGER_RTL_PUBLIC_API __aeabi_d2f(__SEGGER_RTL_U64 x) {
  return __SEGGER_RTL_BitcastToU32(
           __SEGGER_RTL_double_to_float(
             __SEGGER_RTL_BitcastToF64(x)));
}

#endif

#if __SEGGER_RTL_INCLUDE_AEABI_API > 0
# 24720 "./floatops.c"
__SEGGER_RTL_U16 __SEGGER_RTL_PUBLIC_API __aeabi_f2h(__SEGGER_RTL_U32 x) {
  return __SEGGER_RTL_float_to_half_ieee_soft(x);
}
# 24740 "./floatops.c"
__SEGGER_RTL_U16 __SEGGER_RTL_PUBLIC_API __aeabi_d2h(__SEGGER_RTL_U64 x) {
  return __SEGGER_RTL_double_to_half_ieee_soft(x);
}
# 24760 "./floatops.c"
__SEGGER_RTL_U32 __SEGGER_RTL_PUBLIC_API __aeabi_h2f(__SEGGER_RTL_U16 x) {
  return __SEGGER_RTL_BitcastToU32(__SEGGER_RTL_half_to_float_ieee_soft(x));
}
# 24780 "./floatops.c"
__SEGGER_RTL_U64 __SEGGER_RTL_PUBLIC_API __aeabi_h2d(__SEGGER_RTL_U16 x) {
  return __SEGGER_RTL_BitcastToU64(__SEGGER_RTL_half_to_double_ieee_soft(x));
}

#endif
# 24793 "./floatops.c"
#if __SEGGER_RTL_INCLUDE_C_API
# 24816 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __SEGGER_RTL_float32_isnan(float x) {
  return __SEGGER_RTL_float32_isnan_inline(x);
}
# 24834 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __SEGGER_RTL_float32_isinf(float x) {
  return __SEGGER_RTL_float32_isinf_inline(x);
}
# 24852 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __SEGGER_RTL_float32_isfinite(float x) {
  return __SEGGER_RTL_float32_isfinite_inline(x);
}
# 24870 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __SEGGER_RTL_float32_isnormal(float x) {
  return __SEGGER_RTL_float32_isnormal_inline(x);
}
# 24888 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __SEGGER_RTL_float32_signbit(float x) {
  return __SEGGER_RTL_float32_signbit_soft(__SEGGER_RTL_BitcastToU32(x));
}
# 24909 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __SEGGER_RTL_float32_classify(float x) {
  if (__SEGGER_RTL_float32_iszero_inline(x)) {
    return __SEGGER_RTL_FP_ZERO;
  } else if (__SEGGER_RTL_float32_isnan_inline(x)) {
    return __SEGGER_RTL_FP_NAN;
  } else if (__SEGGER_RTL_float32_isinf_inline(x)) {
    return __SEGGER_RTL_FP_INFINITE;
  } else if (__SEGGER_RTL_float32_isnormal_inline(x)) {
    return __SEGGER_RTL_FP_NORMAL;
  } else {
    return __SEGGER_RTL_FP_SUBNORMAL;
  }
}
# 24937 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __SEGGER_RTL_float64_isnan(double x) {
  return __SEGGER_RTL_float64_isnan_inline(x);
}
# 24955 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __SEGGER_RTL_float64_isinf(double x) {
  return __SEGGER_RTL_float64_isinf_inline(x);
}
# 24973 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __SEGGER_RTL_float64_isfinite(double x) {
  return __SEGGER_RTL_float64_isfinite_inline(x);
}
# 24991 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __SEGGER_RTL_float64_isnormal(double x) {
  return __SEGGER_RTL_float64_isnormal_inline(x);
}
# 25009 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __SEGGER_RTL_float64_signbit(double x) {
  return __SEGGER_RTL_float64_signbit_soft(__SEGGER_RTL_BitcastToU64(x));
}
# 25030 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API __SEGGER_RTL_float64_classify(double x) {
  if (__SEGGER_RTL_float64_iszero_inline(x)) {
    return __SEGGER_RTL_FP_ZERO;
  } else if (__SEGGER_RTL_float64_isnan_inline(x)) {
    return __SEGGER_RTL_FP_NAN;
  } else if (__SEGGER_RTL_float64_isinf_inline(x)) {
    return __SEGGER_RTL_FP_INFINITE;
  } else if (__SEGGER_RTL_float64_isnormal_inline(x)) {
    return __SEGGER_RTL_FP_NORMAL;
  } else {
    return __SEGGER_RTL_FP_SUBNORMAL;
  }
}
# 25058 "./floatops.c"
__SEGGER_RTL_FLOAT32_C_COMPLEX __SEGGER_RTL_float32_cmplx(float re, float im) {
  return __SEGGER_RTL_float32_cmplx_inline(re, im);
}
# 25076 "./floatops.c"
__SEGGER_RTL_FLOAT64_C_COMPLEX __SEGGER_RTL_PUBLIC_API __SEGGER_RTL_float64_cmplx(double re, double im) {
  return __SEGGER_RTL_float64_cmplx_inline(re, im);
}
# 25094 "./floatops.c"
__SEGGER_RTL_LDOUBLE_C_COMPLEX __SEGGER_RTL_PUBLIC_API __SEGGER_RTL_ldouble_cmplx(long double re, long double im) {
  return __SEGGER_RTL_ldouble_cmplx_inline(re, im);
}
# 25115 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API copysignf(float x, float y) {
  return __SEGGER_RTL_float32_signbit_copy(x, y);
}
# 25136 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API copysign(double x, double y) {
  return __SEGGER_RTL_float64_signbit_copy(x, y);
}
# 25157 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API copysignl(long double x, long double y) {
  return __SEGGER_RTL_double_to_ldouble(copysign(__SEGGER_RTL_ldouble_to_double(x), __SEGGER_RTL_ldouble_to_double(y)));
}
# 25188 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API ldexpf(float x, int n) {
  return __SEGGER_RTL_float32_ldexp_inline(x, n);
}
# 25219 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API ldexp(double x, int n) {
  return __SEGGER_RTL_float64_ldexp_inline(x, n);
}
# 25250 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API ldexpl(long double x, int n) {
  return __SEGGER_RTL_double_to_ldouble(ldexp(__SEGGER_RTL_ldouble_to_double(x), n));
}
# 25277 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API logbf(float x) {
  return __SEGGER_RTL_float32_logb_inline(x);
}
# 25304 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API logb(double x) {
  return __SEGGER_RTL_float64_logb_inline(x);
}
# 25331 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API logbl(long double x) {
  return __SEGGER_RTL_double_to_ldouble(logb(__SEGGER_RTL_ldouble_to_double(x)));
}
# 25354 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API ilogbf(float x) {
  return __SEGGER_RTL_float32_ilogb_inline(x);
}
# 25377 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API ilogb(double x) {
  return __SEGGER_RTL_float64_ilogb_inline(x);
}
# 25400 "./floatops.c"
int __SEGGER_RTL_PUBLIC_API ilogbl(long double x) {
  return __SEGGER_RTL_double_to_ldouble(logb(__SEGGER_RTL_ldouble_to_double(x)));
}
# 25433 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API scalbnf(float x, int n) {
  return __SEGGER_RTL_float32_ldexp_inline(x, n);
}
# 25466 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API scalbn(double x, int n) {
  return __SEGGER_RTL_float64_ldexp_inline(x, n);
}
# 25499 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API scalbnl(long double x, int n) {
  return __SEGGER_RTL_double_to_ldouble(scalbn(__SEGGER_RTL_ldouble_to_double(x), n));
}
# 25529 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API scalblnf(float x, long n) {
  return __SEGGER_RTL_float32_ldexp_inline(x, (int)n);
}
# 25562 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API scalbln(double x, long n) {
  return __SEGGER_RTL_float64_ldexp_inline(x, (int)n);
}
# 25595 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API scalblnl(long double x, long n) {
  return __SEGGER_RTL_double_to_ldouble(scalbln(__SEGGER_RTL_ldouble_to_double(x), n));
}
# 25623 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API frexpf(float x, int *exp) {
  return __SEGGER_RTL_float32_frexp_inline(x, exp);
}
# 25651 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API frexp(double x, int *exp) {
  return __SEGGER_RTL_float64_frexp_inline(x, exp);
}
# 25679 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API frexpl(long double x, int *exp) {
  return __SEGGER_RTL_double_to_ldouble(frexp(__SEGGER_RTL_ldouble_to_double(x), exp));
}
# 25708 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API modff(float x, float *iptr) {
  return __SEGGER_RTL_float32_modf_inline(x, iptr);
}
# 25737 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API modf(double x, double *iptr) {
  return __SEGGER_RTL_float64_modf_inline(x, iptr);
}
# 25766 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API modfl(long double x, long double *iptr) {
  double i;
  double r;

  r = modf(__SEGGER_RTL_ldouble_to_double(x), &i);
  *iptr = __SEGGER_RTL_double_to_ldouble(i);

  return __SEGGER_RTL_double_to_ldouble(r);
}
# 25793 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API fabsf(float x) {
  return __SEGGER_RTL_float32_abs_inline(x);
}
# 25814 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API fabs(double x) {
  return __SEGGER_RTL_float64_abs_inline(x);
}
# 25835 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API fabsl(long double x) {
  return __SEGGER_RTL_double_to_ldouble(fabs(__SEGGER_RTL_ldouble_to_double(x)));
}
# 25857 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API fmaf(float x, float y, float z) {
  return __SEGGER_RTL_float32_fma_inline(x, y, z);
}
# 25879 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API fma(double x, double y, double z) {
  return __SEGGER_RTL_float64_fma_inline(x, y, z);
}
# 25901 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API fmal(long double x, long double y, long double z) {
  return __SEGGER_RTL_double_to_ldouble(fma(__SEGGER_RTL_ldouble_to_double(x),
                                            __SEGGER_RTL_ldouble_to_double(y),
                                            __SEGGER_RTL_ldouble_to_double(z)));
}
# 25936 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API fmodf(float x, float y) {
  return __SEGGER_RTL_float32_fmod_inline(x, y);
}
# 25969 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API fmod(double x, double y) {
  return __SEGGER_RTL_float64_fmod_inline(x, y);
}
# 26002 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API fmodl(long double x, long double y) {
  return __SEGGER_RTL_double_to_ldouble(fmod(__SEGGER_RTL_ldouble_to_double(x), __SEGGER_RTL_ldouble_to_double(y)));
}
# 26035 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API remainderf(float x, float y) {
  int q;

  return __SEGGER_RTL_float32_remainder_inline(x, y, &q);
}
# 26070 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API remainder(double x, double y) {
  int q;

  return __SEGGER_RTL_float64_remainder_inline(x, y, &q);
}
# 26105 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API remainderl(long double x, long double y) {
  return __SEGGER_RTL_double_to_ldouble(remainder(__SEGGER_RTL_ldouble_to_double(x), __SEGGER_RTL_ldouble_to_double(y)));
}
# 26140 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API remquof(float x, float y, int *quo) {
  return __SEGGER_RTL_float32_remainder_inline(x, y, quo);
}
# 26175 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API remquo(double x, double y, int *quo) {
  return __SEGGER_RTL_float64_remainder_inline(x, y, quo);
}
# 26210 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API remquol(long double x, long double y, int *quo) {
  return __SEGGER_RTL_double_to_ldouble(remquo(__SEGGER_RTL_ldouble_to_double(x), __SEGGER_RTL_ldouble_to_double(y), quo));
}
# 26233 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API fmaxf(float x, float y) {
  return __SEGGER_RTL_float32_fmax_inline(x, y);
}
# 26256 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API fmax(double x, double y) {
  return __SEGGER_RTL_float64_fmax_inline(x, y);
}
# 26279 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API fmaxl(long double x, long double y) {
  return __SEGGER_RTL_double_to_ldouble(fmax(__SEGGER_RTL_ldouble_to_double(x), __SEGGER_RTL_ldouble_to_double(y)));
}
# 26302 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API fminf(float x, float y) {
  return __SEGGER_RTL_float32_fmin_inline(x, y);
}
# 26325 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API fmin(double x, double y) {
  return __SEGGER_RTL_float64_fmin_inline(x, y);
}
# 26348 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API fminl(long double x, long double y) {
  return __SEGGER_RTL_double_to_ldouble(fmin(__SEGGER_RTL_ldouble_to_double(x), __SEGGER_RTL_ldouble_to_double(y)));
}
# 26370 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API fdimf(float x, float y) {
  return __SEGGER_RTL_float32_fdim_inline(x, y);
}
# 26392 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API fdim(double x, double y) {
  return __SEGGER_RTL_float64_fdim_inline(x, y);
}
# 26414 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API fdiml(long double x, long double y) {
  return __SEGGER_RTL_double_to_ldouble(fdim(__SEGGER_RTL_ldouble_to_double(x), __SEGGER_RTL_ldouble_to_double(y)));
}
# 26443 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API hypotf(float x, float y) {
  return __SEGGER_RTL_float32_hypot_inline(x, y);
}
# 26472 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API hypot(double x, double y) {
  return __SEGGER_RTL_float64_hypot_inline(x, y);
}
# 26501 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API hypotl(long double x, long double y) {
  return __SEGGER_RTL_double_to_ldouble(hypot(__SEGGER_RTL_ldouble_to_double(x), __SEGGER_RTL_ldouble_to_double(y)));
}
# 26524 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API ceilf(float x) {
  return __SEGGER_RTL_float32_ceil_inline(x);
}
# 26547 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API ceil(double x) {
  return __SEGGER_RTL_float64_ceil_inline(x);
}
# 26570 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API ceill(long double x) {
  return __SEGGER_RTL_double_to_ldouble(ceil(__SEGGER_RTL_ldouble_to_double(x)));
}
# 26593 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API floorf(float x) {
  return __SEGGER_RTL_float32_floor_inline(x);
}
# 26616 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API floor(double x) {
  return __SEGGER_RTL_float64_floor_inline(x);
}
# 26639 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API floorl(long double x) {
  return __SEGGER_RTL_double_to_ldouble(floor(__SEGGER_RTL_ldouble_to_double(x)));
}
# 26661 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API nearbyintf(float x) {
  return __SEGGER_RTL_float32_rint_inline(x);
}
# 26683 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API nearbyint(double x) {
  return __SEGGER_RTL_float64_rint_inline(x);
}
# 26705 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API nearbyintl(long double x) {
  return __SEGGER_RTL_double_to_ldouble(nearbyint(__SEGGER_RTL_ldouble_to_double(x)));
}
# 26727 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API truncf(float x) {
  return __SEGGER_RTL_float32_trunc_inline(x);
}
# 26749 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API trunc(double x) {
  return __SEGGER_RTL_float64_trunc_inline(x);
}
# 26771 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API truncl(long double x) {
  return __SEGGER_RTL_double_to_ldouble(trunc(__SEGGER_RTL_ldouble_to_double(x)));
}
# 26793 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API rintf(float x) {
  return __SEGGER_RTL_float32_rint_inline(x);
}
# 26815 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API rint(double x) {
  return __SEGGER_RTL_float64_rint_inline(x);
}
# 26837 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API rintl(long double x) {
  return __SEGGER_RTL_double_to_ldouble(rint(__SEGGER_RTL_ldouble_to_double(x)));
}
# 26859 "./floatops.c"
long __SEGGER_RTL_PUBLIC_API lrintf(float x) {
  return __SEGGER_RTL_float32_lrint_inline(x);
}
# 26881 "./floatops.c"
long __SEGGER_RTL_PUBLIC_API lrint(double x) {
  return __SEGGER_RTL_float64_lrint_inline(x);
}
# 26903 "./floatops.c"
long __SEGGER_RTL_PUBLIC_API lrintl(long double x) {
  return lrint(__SEGGER_RTL_ldouble_to_double(x));
}
# 26925 "./floatops.c"
long long __SEGGER_RTL_PUBLIC_API llrintf(float x) {
  return __SEGGER_RTL_float32_llrint_inline(x);
}
# 26947 "./floatops.c"
long long __SEGGER_RTL_PUBLIC_API llrint(double x) {
  return __SEGGER_RTL_float64_llrint_inline(x);
}
# 26969 "./floatops.c"
long long __SEGGER_RTL_PUBLIC_API llrintl(long double x) {
  return llrint(__SEGGER_RTL_ldouble_to_double(x));
}
# 26991 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API roundf(float x) {
  return __SEGGER_RTL_float32_round_inline(x);
}
# 27013 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API round(double x) {
  return __SEGGER_RTL_float64_round_inline(x);
}
# 27035 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API roundl(long double x) {
  return __SEGGER_RTL_double_to_ldouble(round(__SEGGER_RTL_ldouble_to_double(x)));
}
# 27057 "./floatops.c"
long __SEGGER_RTL_PUBLIC_API lroundf(float x) {
  return __SEGGER_RTL_float32_lround_inline(x);
}
# 27079 "./floatops.c"
long __SEGGER_RTL_PUBLIC_API lround(double x) {
  return __SEGGER_RTL_float64_lround_inline(x);
}
# 27101 "./floatops.c"
long __SEGGER_RTL_PUBLIC_API lroundl(long double x) {
  return lround(__SEGGER_RTL_ldouble_to_double(x));
}
# 27123 "./floatops.c"
long long __SEGGER_RTL_PUBLIC_API llroundf(float x) {
  return __SEGGER_RTL_float32_llround_inline(x);
}
# 27145 "./floatops.c"
long long __SEGGER_RTL_PUBLIC_API llround(double x) {
  return __SEGGER_RTL_float64_llround_inline(x);
}
# 27167 "./floatops.c"
long long __SEGGER_RTL_PUBLIC_API llroundl(long double x) {
  return llround(__SEGGER_RTL_ldouble_to_double(x));
}
# 27188 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API nextafterf(float x, float y) {
  return __SEGGER_RTL_float32_nextafter_inline(x, y);
}
# 27209 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API nextafter(double x, double y) {
  return __SEGGER_RTL_float64_nextafter_inline(x, y);
}
# 27230 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API nextafterl(long double x, long double y) {
  return __SEGGER_RTL_double_to_ldouble(nextafter(__SEGGER_RTL_ldouble_to_double(x), __SEGGER_RTL_ldouble_to_double(y)));
}
# 27251 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API nexttowardf(float x, long double y) {
  return __SEGGER_RTL_float32_nextafter_inline(x, SEGGER_LD2F(y));
}
# 27272 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API nexttoward(double x, long double y) {
  return __SEGGER_RTL_float64_nextafter_inline(x, SEGGER_LD2D(y));
}
# 27293 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API nexttowardl(long double x, long double y) {
  return __SEGGER_RTL_double_to_ldouble(nexttoward(__SEGGER_RTL_ldouble_to_double(x), __SEGGER_RTL_ldouble_to_double(y)));
}
# 27313 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API nanf(const char *tag) {
  return __SEGGER_RTL_float32_nan_inline(tag);
}
# 27333 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API nan(const char *tag) {
  return __SEGGER_RTL_float64_nan_inline(tag);
}
# 27353 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API nanl(const char *tag) {
  return __SEGGER_RTL_double_to_ldouble(nan(tag));
}
# 27375 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API sinf(float x) {
  return __SEGGER_RTL_float32_sin_inline(x);
}
# 27397 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API sin(double x) {
  return __SEGGER_RTL_float64_sin_inline(x);
}
# 27419 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API sinl(long double x) {
  return __SEGGER_RTL_double_to_ldouble(sin(__SEGGER_RTL_ldouble_to_double(x)));
}
# 27441 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API cosf(float x) {
  return __SEGGER_RTL_float32_cos_inline(x);
}
# 27463 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API cos(double x) {
  return __SEGGER_RTL_float64_cos_inline(x);
}
# 27485 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API cosl(long double x) {
  return __SEGGER_RTL_double_to_ldouble(cos(__SEGGER_RTL_ldouble_to_double(x)));
}
# 27508 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API tanf(float x) {
  return __SEGGER_RTL_float32_tan_inline(x);
}
# 27531 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API tan(double x) {
  return __SEGGER_RTL_float64_tan_inline(x);
}
# 27554 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API tanl(long double x) {
  return __SEGGER_RTL_double_to_ldouble(tan(__SEGGER_RTL_ldouble_to_double(x)));
}
# 27573 "./floatops.c"
void __SEGGER_RTL_PUBLIC_API sincosf(float x, float *pSin, float *pCos) {
  *pSin = __SEGGER_RTL_float32_sin_inline(x);
  *pCos = __SEGGER_RTL_float32_cos_inline(x);
}
# 27593 "./floatops.c"
void __SEGGER_RTL_PUBLIC_API sincos(double x, double *pSin, double *pCos) {
  *pSin = __SEGGER_RTL_float64_sin_inline(x);
  *pCos = __SEGGER_RTL_float64_cos_inline(x);
}
# 27613 "./floatops.c"
void __SEGGER_RTL_PUBLIC_API sincosl(long double x, long double *pSin, long double *pCos) {
  *pSin = __SEGGER_RTL_double_to_ldouble(__SEGGER_RTL_float64_sin_inline(__SEGGER_RTL_ldouble_to_double(x)));
  *pCos = __SEGGER_RTL_double_to_ldouble(__SEGGER_RTL_float64_cos_inline(__SEGGER_RTL_ldouble_to_double(x)));
}
# 27641 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API asinf(float x) {
  return __SEGGER_RTL_float32_asin_inline(x);
}
# 27668 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API asin(double x) {
  return __SEGGER_RTL_float64_asin_inline(x);
}
# 27695 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API asinl(long double x) {
  return __SEGGER_RTL_double_to_ldouble(asin(__SEGGER_RTL_ldouble_to_double(x)));
}
# 27722 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API acosf(float x) {
  return __SEGGER_RTL_float32_acos_inline(x);
}
# 27749 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API acos(double x) {
  return __SEGGER_RTL_float64_acos_inline(x);
}
# 27776 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API acosl(long double x) {
  return __SEGGER_RTL_double_to_ldouble(acos(__SEGGER_RTL_ldouble_to_double(x)));
}
# 27802 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API atanf(float x) {
  return __SEGGER_RTL_float32_atan_inline(x);
}
# 27828 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API atan(double x) {
  return __SEGGER_RTL_float64_atan_inline(x);
}
# 27854 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API atanl(long double x) {
  return __SEGGER_RTL_double_to_ldouble(atan(__SEGGER_RTL_ldouble_to_double(x)));
}
# 27881 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API atan2f(float y, float x) {
  return __SEGGER_RTL_float32_atan2_inline(y, x);
}
# 27908 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API atan2(double y, double x) {
  return __SEGGER_RTL_float64_atan2_inline(y, x);
}
# 27935 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API atan2l(long double y, long double x) {
  return __SEGGER_RTL_double_to_ldouble(atan2(__SEGGER_RTL_ldouble_to_double(y), __SEGGER_RTL_ldouble_to_double(x)));
}
# 27964 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API sqrtf(float x) {
  return __SEGGER_RTL_float32_sqrt_inline(x);
}
# 27993 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API sqrt(double x) {
  return __SEGGER_RTL_float64_sqrt_inline(x);
}
# 28022 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API sqrtl(long double x) {
  return __SEGGER_RTL_double_to_ldouble(sqrt(__SEGGER_RTL_ldouble_to_double(x)));
}
# 28045 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API cbrtf(float x) {
  return __SEGGER_RTL_float32_cbrt(x);
}
# 28068 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API cbrt(double x) {
  return __SEGGER_RTL_float64_cbrt(x);
}
# 28091 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API cbrtl(long double x) {
  return __SEGGER_RTL_double_to_ldouble(cbrt(__SEGGER_RTL_ldouble_to_double(x)));
}
# 28115 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API rsqrtf(float x) {
  return __SEGGER_RTL_float32_rsqrt_inline(x);
}
# 28139 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API rsqrt(double x) {
  return __SEGGER_RTL_float64_rsqrt_inline(x);
}
# 28163 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API rsqrtl(long double x) {
  return __SEGGER_RTL_double_to_ldouble(rsqrt(__SEGGER_RTL_ldouble_to_double(x)));
}
# 28187 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API logf(float x) {
  return __SEGGER_RTL_float32_log_inline(x);
}
# 28211 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API log(double x) {
  return __SEGGER_RTL_float64_log_inline(x);
}
# 28235 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API logl(long double x) {
  return __SEGGER_RTL_double_to_ldouble(log(__SEGGER_RTL_ldouble_to_double(x)));
}
# 28259 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API log1pf(float x) {
  return __SEGGER_RTL_float32_log1p_inline(x);
}
# 28283 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API log1p(double x) {
  return __SEGGER_RTL_float64_log1p_inline(x);
}
# 28307 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API log1pl(long double x) {
  return __SEGGER_RTL_double_to_ldouble(log1p(__SEGGER_RTL_ldouble_to_double(x)));
}
# 28331 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API log2f(float x) {
  return __SEGGER_RTL_float32_log2(x);
}
# 28355 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API log2(double x) {
  return __SEGGER_RTL_float64_log2(x);
}
# 28379 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API log2l(long double x) {
  return __SEGGER_RTL_double_to_ldouble(log2(__SEGGER_RTL_ldouble_to_double(x)));
}
# 28403 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API log10f(float x) {
  return __SEGGER_RTL_float32_log10_inline(x);
}
# 28427 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API log10(double x) {
  return __SEGGER_RTL_float64_log10_inline(x);
}
# 28451 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API log10l(long double x) {
  return __SEGGER_RTL_double_to_ldouble(log10(__SEGGER_RTL_ldouble_to_double(x)));
}
# 28474 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API expf(float x) {
  return __SEGGER_RTL_float32_exp_inline(x);
}
# 28497 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API exp(double x) {
  return __SEGGER_RTL_float64_exp_inline(x);
}
# 28520 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API expl(long double x) {
  return __SEGGER_RTL_double_to_ldouble(exp(__SEGGER_RTL_ldouble_to_double(x)));
}
# 28543 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API exp2f(float x) {
  return __SEGGER_RTL_float32_exp2_inline(x);
}
# 28566 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API exp2(double x) {
  return __SEGGER_RTL_float64_exp2_inline(x);
}
# 28589 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API exp2l(long double x) {
  return __SEGGER_RTL_double_to_ldouble(exp2(__SEGGER_RTL_ldouble_to_double(x)));
}
# 28612 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API exp10f(float x) {
  return __SEGGER_RTL_float32_exp10_inline(x);
}
# 28635 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API exp10(double x) {
  return __SEGGER_RTL_float64_exp10_inline(x);
}
# 28658 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API exp10l(long double x) {
  return __SEGGER_RTL_double_to_ldouble(exp10(__SEGGER_RTL_ldouble_to_double(x)));
}
# 28679 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API expm1f(float x) {
#if __SEGGER_RTL_SCALED_INTEGER >= 1
  return __SEGGER_RTL_float32_expm1_scaled_integer(x);
#else
  return SEGGER_SUBF(SEGGER_EXPF(x), 1);
#endif
}
# 28704 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API expm1(double x) {
  return SEGGER_SUB(SEGGER_EXP(x), 1);
}
# 28725 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API expm1l(long double x) {
  return __SEGGER_RTL_double_to_ldouble(expm1(__SEGGER_RTL_ldouble_to_double(x)));
}
# 28746 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API powf(float x, float y) {
  return __SEGGER_RTL_float32_pow_inline(x, y);
}
# 28767 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API pow(double x, double y) {
  return __SEGGER_RTL_float64_pow_inline(x, y);
}
# 28788 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API powl(long double x, long double y) {
  return __SEGGER_RTL_double_to_ldouble(pow(__SEGGER_RTL_ldouble_to_double(x), __SEGGER_RTL_ldouble_to_double(y)));
}
# 28808 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API tgammaf(float x) {
  return __SEGGER_RTL_float32_tgamma_inline(x);
}
# 28828 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API tgamma(double x) {
  return __SEGGER_RTL_float64_tgamma_inline(x);
}
# 28848 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API tgammal(long double x) {
  return __SEGGER_RTL_double_to_ldouble(tgamma(__SEGGER_RTL_ldouble_to_double(x)));
}
# 28868 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API lgammaf(float x) {
  return __SEGGER_RTL_float32_lgamma_inline(x);
}
# 28888 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API lgamma(double x) {
  return __SEGGER_RTL_float64_lgamma_inline(x);
}
# 28908 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API lgammal(long double x) {
  return __SEGGER_RTL_double_to_ldouble(lgamma(__SEGGER_RTL_ldouble_to_double(x)));
}
# 28928 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API erff(float x) {
  return __SEGGER_RTL_float32_erf_inline(x);
}
# 28948 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API erf(double x) {
  return __SEGGER_RTL_float64_erf_inline(x);
}
# 28968 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API erfl(long double x) {
  return __SEGGER_RTL_double_to_ldouble(erf(__SEGGER_RTL_ldouble_to_double(x)));
}
# 28988 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API erfcf(float x) {
  return __SEGGER_RTL_float32_erfc_inline(x);
}
# 29008 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API erfc(double x) {
  return __SEGGER_RTL_float64_erfc_inline(x);
}
# 29028 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API erfcl(long double x) {
  return __SEGGER_RTL_double_to_ldouble(erfc(__SEGGER_RTL_ldouble_to_double(x)));
}
# 29050 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API sinhf(float x) {
  return __SEGGER_RTL_float32_sinh_inline(x);
}
# 29072 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API sinh(double x) {
  return __SEGGER_RTL_float64_sinh_inline(x);
}
# 29094 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API sinhl(long double x) {
  return __SEGGER_RTL_double_to_ldouble(sinh(__SEGGER_RTL_ldouble_to_double(x)));
}
# 29116 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API coshf(float x) {
  return __SEGGER_RTL_float32_cosh_inline(x);
}
# 29138 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API cosh(double x) {
  return __SEGGER_RTL_float64_cosh_inline(x);
}
# 29160 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API coshl(long double x) {
  return __SEGGER_RTL_double_to_ldouble(cosh(__SEGGER_RTL_ldouble_to_double(x)));
}
# 29181 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API tanhf(float x) {
  return __SEGGER_RTL_float32_tanh_inline(x);
}
# 29202 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API tanh(double x) {
  return __SEGGER_RTL_float64_tanh_inline(x);
}
# 29223 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API tanhl(long double x) {
  return __SEGGER_RTL_double_to_ldouble(tanh(__SEGGER_RTL_ldouble_to_double(x)));
}
# 29248 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API asinhf(float x) {
  return __SEGGER_RTL_float32_asinh_inline(x);
}
# 29270 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API asinh(double x) {
  return __SEGGER_RTL_float64_asinh_inline(x);
}
# 29292 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API asinhl(long double x) {
  return __SEGGER_RTL_double_to_ldouble(asinh(__SEGGER_RTL_ldouble_to_double(x)));
}
# 29314 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API acoshf(float x) {
  return __SEGGER_RTL_float32_acosh_inline(x);
}
# 29336 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API acosh(double x) {
  return __SEGGER_RTL_float64_acosh_inline(x);
}
# 29358 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API acoshl(long double x) {
  return __SEGGER_RTL_double_to_ldouble(acosh(__SEGGER_RTL_ldouble_to_double(x)));
}
# 29381 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API atanhf(float x) {
  return __SEGGER_RTL_float32_atanh_inline(x);
}
# 29404 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API atanh(double x) {
  return __SEGGER_RTL_float64_atanh_inline(x);
}
# 29427 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API atanhl(long double x) {
  return __SEGGER_RTL_double_to_ldouble(atanh(__SEGGER_RTL_ldouble_to_double(x)));
}
# 29447 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API crealf(__SEGGER_RTL_FLOAT32_C_COMPLEX x) {
  __SEGGER_RTL_FLOAT32_COMPLEX z;

  z.u.value = x;

  return z.u.part.Re;
}
# 29471 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API creal(__SEGGER_RTL_FLOAT64_C_COMPLEX x) {
  __SEGGER_RTL_FLOAT64_COMPLEX z;

  z.u.value = x;

  return z.u.part.Re;
}
# 29495 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API creall(__SEGGER_RTL_LDOUBLE_C_COMPLEX x) {
  __SEGGER_RTL_LDOUBLE_COMPLEX z;

  z.u.value = x;

  return z.u.part.Re;
}
# 29519 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API cimagf(__SEGGER_RTL_FLOAT32_C_COMPLEX x) {
  __SEGGER_RTL_FLOAT32_COMPLEX z;

  z.u.value = x;

  return z.u.part.Im;
}
# 29543 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API cimag(__SEGGER_RTL_FLOAT64_C_COMPLEX x) {
  __SEGGER_RTL_FLOAT64_COMPLEX z;

  z.u.value = x;

  return z.u.part.Im;
}
# 29567 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API cimagl(__SEGGER_RTL_LDOUBLE_C_COMPLEX x) {
  __SEGGER_RTL_LDOUBLE_COMPLEX z;

  z.u.value = x;

  return z.u.part.Im;
}
# 29591 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API cabsf(__SEGGER_RTL_FLOAT32_C_COMPLEX x) {
  return SEGGER_HYPOTF(crealf(x), cimagf(x));
}
# 29611 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API cabs(__SEGGER_RTL_FLOAT64_C_COMPLEX x) {
  return SEGGER_HYPOT(creal(x), cimag(x));
}
# 29631 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API cabsl(__SEGGER_RTL_LDOUBLE_C_COMPLEX x) {
  return __SEGGER_RTL_double_to_ldouble(cabs(__SEGGER_RTL_complex_ldouble_to_double(x)));
}
# 29651 "./floatops.c"
float __SEGGER_RTL_PUBLIC_API cargf(__SEGGER_RTL_FLOAT32_C_COMPLEX x) {
  return SEGGER_ATAN2F(cimagf(x), crealf(x));
}
# 29671 "./floatops.c"
double __SEGGER_RTL_PUBLIC_API carg(__SEGGER_RTL_FLOAT64_C_COMPLEX x) {
  return SEGGER_ATAN2(cimag(x), creal(x));
}
# 29691 "./floatops.c"
long double __SEGGER_RTL_PUBLIC_API cargl(__SEGGER_RTL_LDOUBLE_C_COMPLEX x) {
  return __SEGGER_RTL_double_to_ldouble(carg(__SEGGER_RTL_complex_ldouble_to_double(x)));
}
# 29719 "./floatops.c"
__SEGGER_RTL_FLOAT32_C_COMPLEX __SEGGER_RTL_PUBLIC_API cprojf(__SEGGER_RTL_FLOAT32_C_COMPLEX x) {
  __SEGGER_RTL_FLOAT32_COMPLEX z;

  z.u.value = x;
  __SEGGER_RTL_float32_cproj(&z);

  return z.u.value;
}
# 29752 "./floatops.c"
__SEGGER_RTL_FLOAT64_C_COMPLEX __SEGGER_RTL_PUBLIC_API cproj(__SEGGER_RTL_FLOAT64_C_COMPLEX x) {
  __SEGGER_RTL_FLOAT64_COMPLEX z;

  z.u.value = x;
  __SEGGER_RTL_float64_cproj(&z);

  return z.u.value;
}
# 29785 "./floatops.c"
__SEGGER_RTL_LDOUBLE_C_COMPLEX __SEGGER_RTL_PUBLIC_API cprojl(__SEGGER_RTL_LDOUBLE_C_COMPLEX x) {
  return __SEGGER_RTL_complex_double_to_ldouble(cproj(__SEGGER_RTL_complex_ldouble_to_double(x)));
}
# 29805 "./floatops.c"
__SEGGER_RTL_FLOAT32_C_COMPLEX __SEGGER_RTL_PUBLIC_API conjf(__SEGGER_RTL_FLOAT32_C_COMPLEX x) {
  __SEGGER_RTL_FLOAT32_COMPLEX z;

  z.u.value = x;
  __SEGGER_RTL_float32_ccnj(&z);

  return z.u.value;
}
# 29830 "./floatops.c"
__SEGGER_RTL_FLOAT64_C_COMPLEX __SEGGER_RTL_PUBLIC_API conj(__SEGGER_RTL_FLOAT64_C_COMPLEX x) {
  __SEGGER_RTL_FLOAT64_COMPLEX z;

  z.u.value = x;
  __SEGGER_RTL_float64_ccnj(&z);

  return z.u.value;
}
# 29855 "./floatops.c"
__SEGGER_RTL_LDOUBLE_C_COMPLEX __SEGGER_RTL_PUBLIC_API conjl(__SEGGER_RTL_LDOUBLE_C_COMPLEX x) {
  return __SEGGER_RTL_complex_double_to_ldouble(conj(__SEGGER_RTL_complex_ldouble_to_double(x)));
}
# 29895 "./floatops.c"
__SEGGER_RTL_FLOAT32_C_COMPLEX __SEGGER_RTL_PUBLIC_API csqrtf(__SEGGER_RTL_FLOAT32_C_COMPLEX x) {
  __SEGGER_RTL_FLOAT32_COMPLEX z;

  z.u.value = x;
  __SEGGER_RTL_float32_csqrt(&z);

  return z.u.value;
}
# 29940 "./floatops.c"
__SEGGER_RTL_FLOAT64_C_COMPLEX __SEGGER_RTL_PUBLIC_API csqrt(__SEGGER_RTL_FLOAT64_C_COMPLEX x) {
  __SEGGER_RTL_FLOAT64_COMPLEX z;

  z.u.value = x;
  __SEGGER_RTL_float64_csqrt(&z);

  return z.u.value;
}
# 29985 "./floatops.c"
__SEGGER_RTL_LDOUBLE_C_COMPLEX __SEGGER_RTL_PUBLIC_API csqrtl(__SEGGER_RTL_LDOUBLE_C_COMPLEX x) {
  return __SEGGER_RTL_complex_double_to_ldouble(csqrt(__SEGGER_RTL_complex_ldouble_to_double(x)));
}
# 30026 "./floatops.c"
__SEGGER_RTL_FLOAT32_C_COMPLEX __SEGGER_RTL_PUBLIC_API clogf(__SEGGER_RTL_FLOAT32_C_COMPLEX x) {
  __SEGGER_RTL_FLOAT32_COMPLEX z;

  z.u.value = x;
  __SEGGER_RTL_float32_clog_inline(&z);

  return z.u.value;
}
# 30072 "./floatops.c"
__SEGGER_RTL_FLOAT64_C_COMPLEX __SEGGER_RTL_PUBLIC_API clog(__SEGGER_RTL_FLOAT64_C_COMPLEX x) {
  __SEGGER_RTL_FLOAT64_COMPLEX z;

  z.u.value = x;
  __SEGGER_RTL_float64_clog_inline(&z);

  return z.u.value;
}
# 30118 "./floatops.c"
__SEGGER_RTL_LDOUBLE_C_COMPLEX __SEGGER_RTL_PUBLIC_API clogl(__SEGGER_RTL_LDOUBLE_C_COMPLEX x) {
  return __SEGGER_RTL_complex_double_to_ldouble(clog(__SEGGER_RTL_complex_ldouble_to_double(x)));
}
# 30160 "./floatops.c"
__SEGGER_RTL_FLOAT32_C_COMPLEX __SEGGER_RTL_PUBLIC_API cexpf(__SEGGER_RTL_FLOAT32_C_COMPLEX x) {
  __SEGGER_RTL_FLOAT32_COMPLEX z;

  z.u.value = x;
  __SEGGER_RTL_float32_cexp(&z);

  return z.u.value;
}
# 30207 "./floatops.c"
__SEGGER_RTL_FLOAT64_C_COMPLEX __SEGGER_RTL_PUBLIC_API cexp(__SEGGER_RTL_FLOAT64_C_COMPLEX x) {
  __SEGGER_RTL_FLOAT64_COMPLEX z;

  z.u.value = x;
  __SEGGER_RTL_float64_cexp(&z);

  return z.u.value;
}
# 30254 "./floatops.c"
__SEGGER_RTL_LDOUBLE_C_COMPLEX __SEGGER_RTL_PUBLIC_API cexpl(__SEGGER_RTL_LDOUBLE_C_COMPLEX x) {
  return __SEGGER_RTL_complex_double_to_ldouble(cexp(__SEGGER_RTL_complex_ldouble_to_double(x)));
}
# 30275 "./floatops.c"
__SEGGER_RTL_FLOAT32_C_COMPLEX __SEGGER_RTL_PUBLIC_API cpowf(__SEGGER_RTL_FLOAT32_C_COMPLEX x, __SEGGER_RTL_FLOAT32_C_COMPLEX y) {
  __SEGGER_RTL_FLOAT32_COMPLEX a;
  __SEGGER_RTL_FLOAT32_COMPLEX b;

  a.u.value = x;
  b.u.value = y;
  __SEGGER_RTL_float32_cpow(&a, &b);

  return a.u.value;
}
# 30303 "./floatops.c"
__SEGGER_RTL_FLOAT64_C_COMPLEX __SEGGER_RTL_PUBLIC_API cpow(__SEGGER_RTL_FLOAT64_C_COMPLEX x, __SEGGER_RTL_FLOAT64_C_COMPLEX y) {
  __SEGGER_RTL_FLOAT64_COMPLEX a;
  __SEGGER_RTL_FLOAT64_COMPLEX b;

  a.u.value = x;
  b.u.value = y;
  __SEGGER_RTL_float64_cpow(&a, &b);

  return a.u.value;
}
# 30331 "./floatops.c"
__SEGGER_RTL_LDOUBLE_C_COMPLEX __SEGGER_RTL_PUBLIC_API cpowl(__SEGGER_RTL_LDOUBLE_C_COMPLEX x, __SEGGER_RTL_LDOUBLE_C_COMPLEX y) {
  return __SEGGER_RTL_complex_double_to_ldouble(
           cpow(__SEGGER_RTL_complex_ldouble_to_double(x),
                __SEGGER_RTL_complex_ldouble_to_double(y)));
}
# 30353 "./floatops.c"
__SEGGER_RTL_FLOAT32_C_COMPLEX __SEGGER_RTL_PUBLIC_API csinf(__SEGGER_RTL_FLOAT32_C_COMPLEX x) {
  __SEGGER_RTL_FLOAT32_COMPLEX z;

  z.u.value = x;
  __SEGGER_RTL_float32_csin_inline(&z);

  return z.u.value;
}
# 30378 "./floatops.c"
__SEGGER_RTL_FLOAT64_C_COMPLEX __SEGGER_RTL_PUBLIC_API csin(__SEGGER_RTL_FLOAT64_C_COMPLEX x) {
  __SEGGER_RTL_FLOAT64_COMPLEX z;

  z.u.value = x;
  __SEGGER_RTL_float64_csin_inline(&z);

  return z.u.value;
}
# 30403 "./floatops.c"
__SEGGER_RTL_LDOUBLE_C_COMPLEX __SEGGER_RTL_PUBLIC_API csinl(__SEGGER_RTL_LDOUBLE_C_COMPLEX x) {
  return __SEGGER_RTL_complex_double_to_ldouble(csin(__SEGGER_RTL_complex_ldouble_to_double(x)));
}
# 30423 "./floatops.c"
__SEGGER_RTL_FLOAT32_C_COMPLEX __SEGGER_RTL_PUBLIC_API ccosf(__SEGGER_RTL_FLOAT32_C_COMPLEX x) {
  __SEGGER_RTL_FLOAT32_COMPLEX z;

  z.u.value = x;
  __SEGGER_RTL_float32_ccos_inline(&z);

  return z.u.value;
}
# 30448 "./floatops.c"
__SEGGER_RTL_FLOAT64_C_COMPLEX __SEGGER_RTL_PUBLIC_API ccos(__SEGGER_RTL_FLOAT64_C_COMPLEX x) {
  __SEGGER_RTL_FLOAT64_COMPLEX z;

  z.u.value = x;
  __SEGGER_RTL_float64_ccos_inline(&z);

  return z.u.value;
}
# 30473 "./floatops.c"
__SEGGER_RTL_LDOUBLE_C_COMPLEX __SEGGER_RTL_PUBLIC_API ccosl(__SEGGER_RTL_LDOUBLE_C_COMPLEX x) {
  return __SEGGER_RTL_complex_double_to_ldouble(ccos(__SEGGER_RTL_complex_ldouble_to_double(x)));
}
# 30493 "./floatops.c"
__SEGGER_RTL_FLOAT32_C_COMPLEX __SEGGER_RTL_PUBLIC_API ctanf(__SEGGER_RTL_FLOAT32_C_COMPLEX x) {
  __SEGGER_RTL_FLOAT32_COMPLEX z;

  z.u.value = x;
  __SEGGER_RTL_float32_ctan_inline(&z);

  return z.u.value;
}
# 30518 "./floatops.c"
__SEGGER_RTL_FLOAT64_C_COMPLEX __SEGGER_RTL_PUBLIC_API ctan(__SEGGER_RTL_FLOAT64_C_COMPLEX x) {
  __SEGGER_RTL_FLOAT64_COMPLEX z;

  z.u.value = x;
  __SEGGER_RTL_float64_ctan_inline(&z);

  return z.u.value;
}
# 30543 "./floatops.c"
__SEGGER_RTL_LDOUBLE_C_COMPLEX __SEGGER_RTL_PUBLIC_API ctanl(__SEGGER_RTL_LDOUBLE_C_COMPLEX x) {
  return __SEGGER_RTL_complex_double_to_ldouble(ctan(__SEGGER_RTL_complex_ldouble_to_double(x)));
}
# 30588 "./floatops.c"
__SEGGER_RTL_FLOAT32_C_COMPLEX __SEGGER_RTL_PUBLIC_API csinhf(__SEGGER_RTL_FLOAT32_C_COMPLEX x) {
  __SEGGER_RTL_FLOAT32_COMPLEX z;

  z.u.value = x;
  __SEGGER_RTL_float32_csinh_inline(&z);

  return z.u.value;
}
# 30638 "./floatops.c"
__SEGGER_RTL_FLOAT64_C_COMPLEX __SEGGER_RTL_PUBLIC_API csinh(__SEGGER_RTL_FLOAT64_C_COMPLEX x) {
  __SEGGER_RTL_FLOAT64_COMPLEX z;

  z.u.value = x;
  __SEGGER_RTL_float64_csinh_inline(&z);

  return z.u.value;
}
# 30688 "./floatops.c"
__SEGGER_RTL_LDOUBLE_C_COMPLEX __SEGGER_RTL_PUBLIC_API csinhl(__SEGGER_RTL_LDOUBLE_C_COMPLEX x) {
  return __SEGGER_RTL_complex_double_to_ldouble(csinh(__SEGGER_RTL_complex_ldouble_to_double(x)));
}
# 30729 "./floatops.c"
__SEGGER_RTL_FLOAT32_C_COMPLEX __SEGGER_RTL_PUBLIC_API ccoshf(__SEGGER_RTL_FLOAT32_C_COMPLEX x) {
  __SEGGER_RTL_FLOAT32_COMPLEX z;

  z.u.value = x;
  __SEGGER_RTL_float32_ccosh_inline(&z);

  return z.u.value;
}
# 30775 "./floatops.c"
__SEGGER_RTL_FLOAT64_C_COMPLEX __SEGGER_RTL_PUBLIC_API ccosh(__SEGGER_RTL_FLOAT64_C_COMPLEX x) {
  __SEGGER_RTL_FLOAT64_COMPLEX z;

  z.u.value = x;
  __SEGGER_RTL_float64_ccosh_inline(&z);

  return z.u.value;
}
# 30821 "./floatops.c"
__SEGGER_RTL_LDOUBLE_C_COMPLEX __SEGGER_RTL_PUBLIC_API ccoshl(__SEGGER_RTL_LDOUBLE_C_COMPLEX x) {
  return __SEGGER_RTL_complex_double_to_ldouble(ccosh(__SEGGER_RTL_complex_ldouble_to_double(x)));
}
# 30863 "./floatops.c"
__SEGGER_RTL_FLOAT32_C_COMPLEX __SEGGER_RTL_PUBLIC_API ctanhf(__SEGGER_RTL_FLOAT32_C_COMPLEX x) {
  __SEGGER_RTL_FLOAT32_COMPLEX z;

  z.u.value = x;
  __SEGGER_RTL_float32_ctanh_inline(&z);

  return z.u.value;
}
# 30910 "./floatops.c"
__SEGGER_RTL_FLOAT64_C_COMPLEX __SEGGER_RTL_PUBLIC_API ctanh(__SEGGER_RTL_FLOAT64_C_COMPLEX x) {
  __SEGGER_RTL_FLOAT64_COMPLEX z;

  z.u.value = x;
  __SEGGER_RTL_float64_ctanh_inline(&z);

  return z.u.value;
}
# 30957 "./floatops.c"
__SEGGER_RTL_LDOUBLE_C_COMPLEX __SEGGER_RTL_PUBLIC_API ctanhl(__SEGGER_RTL_LDOUBLE_C_COMPLEX x) {
  return __SEGGER_RTL_complex_double_to_ldouble(ctanh(__SEGGER_RTL_complex_ldouble_to_double(x)));
}
# 30977 "./floatops.c"
__SEGGER_RTL_FLOAT32_C_COMPLEX __SEGGER_RTL_PUBLIC_API cacosf(__SEGGER_RTL_FLOAT32_C_COMPLEX x) {
  __SEGGER_RTL_FLOAT32_COMPLEX z;

  z.u.value = x;
  __SEGGER_RTL_float32_cacos(&z);

  return z.u.value;
}
# 31002 "./floatops.c"
__SEGGER_RTL_FLOAT64_C_COMPLEX __SEGGER_RTL_PUBLIC_API cacos(__SEGGER_RTL_FLOAT64_C_COMPLEX x) {
  __SEGGER_RTL_FLOAT64_COMPLEX z;

  z.u.value = x;
  __SEGGER_RTL_float64_cacos(&z);

  return z.u.value;
}
# 31027 "./floatops.c"
__SEGGER_RTL_LDOUBLE_C_COMPLEX __SEGGER_RTL_PUBLIC_API cacosl(__SEGGER_RTL_LDOUBLE_C_COMPLEX x) {
  return __SEGGER_RTL_complex_double_to_ldouble(cacos(__SEGGER_RTL_complex_ldouble_to_double(x)));
}
# 31050 "./floatops.c"
__SEGGER_RTL_FLOAT32_C_COMPLEX __SEGGER_RTL_PUBLIC_API casinf(__SEGGER_RTL_FLOAT32_C_COMPLEX x) {
  __SEGGER_RTL_FLOAT32_COMPLEX z;

  z.u.value = x;
  __SEGGER_RTL_float32_casin(&z);

  return z.u.value;
}
# 31078 "./floatops.c"
__SEGGER_RTL_FLOAT64_C_COMPLEX __SEGGER_RTL_PUBLIC_API casin(__SEGGER_RTL_FLOAT64_C_COMPLEX x) {
  __SEGGER_RTL_FLOAT64_COMPLEX z;

  z.u.value = x;
  __SEGGER_RTL_float64_casin(&z);

  return z.u.value;
}
# 31106 "./floatops.c"
__SEGGER_RTL_LDOUBLE_C_COMPLEX __SEGGER_RTL_PUBLIC_API casinl(__SEGGER_RTL_LDOUBLE_C_COMPLEX x) {
  return __SEGGER_RTL_complex_double_to_ldouble(casin(__SEGGER_RTL_complex_ldouble_to_double(x)));
}
# 31129 "./floatops.c"
__SEGGER_RTL_FLOAT32_C_COMPLEX __SEGGER_RTL_PUBLIC_API catanf(__SEGGER_RTL_FLOAT32_C_COMPLEX x) {
  __SEGGER_RTL_FLOAT32_COMPLEX z;

  z.u.value = x;
  __SEGGER_RTL_float32_catan(&z);

  return z.u.value;
}
# 31157 "./floatops.c"
__SEGGER_RTL_FLOAT64_C_COMPLEX __SEGGER_RTL_PUBLIC_API catan(__SEGGER_RTL_FLOAT64_C_COMPLEX x) {
  __SEGGER_RTL_FLOAT64_COMPLEX z;

  z.u.value = x;
  __SEGGER_RTL_float64_catan(&z);

  return z.u.value;
}
# 31185 "./floatops.c"
__SEGGER_RTL_LDOUBLE_C_COMPLEX __SEGGER_RTL_PUBLIC_API catanl(__SEGGER_RTL_LDOUBLE_C_COMPLEX x) {
  return __SEGGER_RTL_complex_double_to_ldouble(catan(__SEGGER_RTL_complex_ldouble_to_double(x)));
}
# 31228 "./floatops.c"
__SEGGER_RTL_FLOAT32_C_COMPLEX __SEGGER_RTL_PUBLIC_API casinhf(__SEGGER_RTL_FLOAT32_C_COMPLEX x) {
  __SEGGER_RTL_FLOAT32_COMPLEX z;

  z.u.value = x;
  __SEGGER_RTL_float32_casinh(&z);

  return z.u.value;
}
# 31276 "./floatops.c"
__SEGGER_RTL_FLOAT64_C_COMPLEX __SEGGER_RTL_PUBLIC_API casinh(__SEGGER_RTL_FLOAT64_C_COMPLEX x) {
  __SEGGER_RTL_FLOAT64_COMPLEX z;

  z.u.value = x;
  __SEGGER_RTL_float64_casinh(&z);

  return z.u.value;
}
# 31324 "./floatops.c"
__SEGGER_RTL_LDOUBLE_C_COMPLEX __SEGGER_RTL_PUBLIC_API casinhl(__SEGGER_RTL_LDOUBLE_C_COMPLEX x) {
  return __SEGGER_RTL_complex_double_to_ldouble(casinh(__SEGGER_RTL_complex_ldouble_to_double(x)));
}
# 31364 "./floatops.c"
__SEGGER_RTL_FLOAT32_C_COMPLEX __SEGGER_RTL_PUBLIC_API cacoshf(__SEGGER_RTL_FLOAT32_C_COMPLEX x) {
  __SEGGER_RTL_FLOAT32_COMPLEX z;

  z.u.value = x;
  __SEGGER_RTL_float32_cacosh_inline(&z);

  return z.u.value;
}
# 31409 "./floatops.c"
__SEGGER_RTL_FLOAT64_C_COMPLEX __SEGGER_RTL_PUBLIC_API cacosh(__SEGGER_RTL_FLOAT64_C_COMPLEX x) {
  __SEGGER_RTL_FLOAT64_COMPLEX z;

  z.u.value = x;
  __SEGGER_RTL_float64_cacosh_inline(&z);

  return z.u.value;
}
# 31454 "./floatops.c"
__SEGGER_RTL_LDOUBLE_C_COMPLEX __SEGGER_RTL_PUBLIC_API cacoshl(__SEGGER_RTL_LDOUBLE_C_COMPLEX x) {
  return __SEGGER_RTL_complex_double_to_ldouble(cacosh(__SEGGER_RTL_complex_ldouble_to_double(x)));
}
# 31497 "./floatops.c"
__SEGGER_RTL_FLOAT32_C_COMPLEX __SEGGER_RTL_PUBLIC_API catanhf(__SEGGER_RTL_FLOAT32_C_COMPLEX x) {
  __SEGGER_RTL_FLOAT32_COMPLEX z;

  z.u.value = x;
  __SEGGER_RTL_float32_catanh(&z);

  return z.u.value;
}
# 31545 "./floatops.c"
__SEGGER_RTL_FLOAT64_C_COMPLEX __SEGGER_RTL_PUBLIC_API catanh(__SEGGER_RTL_FLOAT64_C_COMPLEX x) {
  __SEGGER_RTL_FLOAT64_COMPLEX z;

  z.u.value = x;
  __SEGGER_RTL_float64_catanh(&z);

  return z.u.value;
}
# 31593 "./floatops.c"
__SEGGER_RTL_LDOUBLE_C_COMPLEX __SEGGER_RTL_PUBLIC_API catanhl(__SEGGER_RTL_LDOUBLE_C_COMPLEX x) {
  return __SEGGER_RTL_complex_double_to_ldouble(catanh(__SEGGER_RTL_complex_ldouble_to_double(x)));
}

#endif
